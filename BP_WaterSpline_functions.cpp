#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_WaterSpline

#include "Basic.hpp"

#include "BP_WaterSpline_classes.hpp"
#include "BP_WaterSpline_parameters.hpp"


namespace SDK
{

// Function BP_WaterSpline.BP_WaterSpline_C.Add Swim Volumes
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Add_Swim_Volumes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Add Swim Volumes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Align Edge Spline
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineComponent*                 Spline_0                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::Align_Edge_Spline(class USplineComponent* Spline_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Align Edge Spline");

	Params::BP_WaterSpline_C_Align_Edge_Spline Parms{};

	Parms.Spline_0 = Spline_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Bake Mesh
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDynamicMeshComponent*            Dynamic_Mesh                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UMaterialInterface*               Material                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Asset_Tag                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class UStaticMesh**                     Out_SM                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::Bake_Mesh(class UDynamicMeshComponent* Dynamic_Mesh, class UMaterialInterface* Material, const class FString& Asset_Tag, class UStaticMesh** Out_SM)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Bake Mesh");

	Params::BP_WaterSpline_C_Bake_Mesh Parms{};

	Parms.Dynamic_Mesh = Dynamic_Mesh;
	Parms.Material = Material;
	Parms.Asset_Tag = std::move(Asset_Tag);

	UObject::ProcessEvent(Func, &Parms);

	if (Out_SM != nullptr)
		*Out_SM = Parms.Out_SM;
}


// Function BP_WaterSpline.BP_WaterSpline_C.Bake UVs
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDynamicMeshComponent*            DynMesh                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::Bake_UVs(class UDynamicMeshComponent* DynMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Bake UVs");

	Params::BP_WaterSpline_C_Bake_UVs Parms{};

	Parms.DynMesh = DynMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Bake Vertex Colors
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDynamicMeshComponent*            DynMesh                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::Bake_Vertex_Colors(class UDynamicMeshComponent* DynMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Bake Vertex Colors");

	Params::BP_WaterSpline_C_Bake_Vertex_Colors Parms{};

	Parms.DynMesh = DynMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Bake Water Meshes
// (Protected, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Bake_Water_Meshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Bake Water Meshes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Build Display Mesh
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FVector2D>&               PolylineVerts                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FTransform>&              SweepPath                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<double>&                         U                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<double>&                         V                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ABP_WaterSpline_C::Build_Display_Mesh(TArray<struct FVector2D>& PolylineVerts, TArray<struct FTransform>& SweepPath, TArray<double>& U, TArray<double>& V)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Build Display Mesh");

	Params::BP_WaterSpline_C_Build_Display_Mesh Parms{};

	Parms.PolylineVerts = std::move(PolylineVerts);
	Parms.SweepPath = std::move(SweepPath);
	Parms.U = std::move(U);
	Parms.V = std::move(V);

	UObject::ProcessEvent(Func, &Parms);

	PolylineVerts = std::move(Parms.PolylineVerts);
	SweepPath = std::move(Parms.SweepPath);
	U = std::move(Parms.U);
	V = std::move(Parms.V);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Build Profile for Spline
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Width                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Divisions                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector2D>*               Positions_0                                            (Parm, OutParm)
// TArray<double>*                         UVs_0                                                  (Parm, OutParm)

void ABP_WaterSpline_C::Build_Profile_for_Spline(double Width, int32 Divisions, TArray<struct FVector2D>* Positions_0, TArray<double>* UVs_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Build Profile for Spline");

	Params::BP_WaterSpline_C_Build_Profile_for_Spline Parms{};

	Parms.Width = Width;
	Parms.Divisions = Divisions;

	UObject::ProcessEvent(Func, &Parms);

	if (Positions_0 != nullptr)
		*Positions_0 = std::move(Parms.Positions_0);

	if (UVs_0 != nullptr)
		*UVs_0 = std::move(Parms.UVs_0);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Check if Mesh Asset Exists
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    Asset_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   Exists_                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMesh**                     Return_Mesh                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::Check_if_Mesh_Asset_Exists(const class FString& Asset_Name, bool* Exists_, class UStaticMesh** Return_Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Check if Mesh Asset Exists");

	Params::BP_WaterSpline_C_Check_if_Mesh_Asset_Exists Parms{};

	Parms.Asset_Name = std::move(Asset_Name);

	UObject::ProcessEvent(Func, &Parms);

	if (Exists_ != nullptr)
		*Exists_ = Parms.Exists_;

	if (Return_Mesh != nullptr)
		*Return_Mesh = Parms.Return_Mesh;
}


// Function BP_WaterSpline.BP_WaterSpline_C.CheckInvalidateMeshes
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Invalidated_0                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::CheckInvalidateMeshes(bool* Invalidated_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "CheckInvalidateMeshes");

	Params::BP_WaterSpline_C_CheckInvalidateMeshes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Invalidated_0 != nullptr)
		*Invalidated_0 = Parms.Invalidated_0;
}


// Function BP_WaterSpline.BP_WaterSpline_C.Decompose To Volume Transforms
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  MinimumVolumeLength                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  BendTolerance                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  PitchTolerance                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RollTolerance                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::Decompose_To_Volume_Transforms(double MinimumVolumeLength, double BendTolerance, double PitchTolerance, double RollTolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Decompose To Volume Transforms");

	Params::BP_WaterSpline_C_Decompose_To_Volume_Transforms Parms{};

	Parms.MinimumVolumeLength = MinimumVolumeLength;
	Parms.BendTolerance = BendTolerance;
	Parms.PitchTolerance = PitchTolerance;
	Parms.RollTolerance = RollTolerance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Editor Water Tick
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Editor_Water_Tick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Editor Water Tick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Editor Water Update
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Editor_Water_Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Editor Water Update");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.ExecuteUbergraph_BP_WaterSpline
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::ExecuteUbergraph_BP_WaterSpline(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "ExecuteUbergraph_BP_WaterSpline");

	Params::BP_WaterSpline_C_ExecuteUbergraph_BP_WaterSpline Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Fix Up Meshes
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Fix_Up_Meshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Fix Up Meshes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Get Current at Location
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   World_Location                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D*                       Current_Velocity                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::Get_Current_at_Location(const struct FVector& World_Location, struct FVector2D* Current_Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Get Current at Location");

	Params::BP_WaterSpline_C_Get_Current_at_Location Parms{};

	Parms.World_Location = std::move(World_Location);

	UObject::ProcessEvent(Func, &Parms);

	if (Current_Velocity != nullptr)
		*Current_Velocity = std::move(Parms.Current_Velocity);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Get Samples From Spline
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class USplineComponent*           Spline_0                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// double                                  Spacing                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FTransform>*              Frames_0                                               (Parm, OutParm)
// TArray<double>*                         FrameTimes                                             (Parm, OutParm)

void ABP_WaterSpline_C::Get_Samples_From_Spline(const class USplineComponent* Spline_0, double Spacing, TArray<struct FTransform>* Frames_0, TArray<double>* FrameTimes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Get Samples From Spline");

	Params::BP_WaterSpline_C_Get_Samples_From_Spline Parms{};

	Parms.Spline_0 = Spline_0;
	Parms.Spacing = Spacing;

	UObject::ProcessEvent(Func, &Parms);

	if (Frames_0 != nullptr)
		*Frames_0 = std::move(Parms.Frames_0);

	if (FrameTimes != nullptr)
		*FrameTimes = std::move(Parms.FrameTimes);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Get Spline Dir From Local Position
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class USplineComponent*                 Spline_0                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   LocalPosition                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         SplineDir                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::Get_Spline_Dir_From_Local_Position(class USplineComponent* Spline_0, const struct FVector& LocalPosition, struct FVector* SplineDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Get Spline Dir From Local Position");

	Params::BP_WaterSpline_C_Get_Spline_Dir_From_Local_Position Parms{};

	Parms.Spline_0 = Spline_0;
	Parms.LocalPosition = std::move(LocalPosition);

	UObject::ProcessEvent(Func, &Parms);

	if (SplineDir != nullptr)
		*SplineDir = std::move(Parms.SplineDir);
}


// Function BP_WaterSpline.BP_WaterSpline_C.GetControlledPawnLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector*                         ControlledPawnLocation                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::GetControlledPawnLocation(struct FVector* ControlledPawnLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "GetControlledPawnLocation");

	Params::BP_WaterSpline_C_GetControlledPawnLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ControlledPawnLocation != nullptr)
		*ControlledPawnLocation = std::move(Parms.ControlledPawnLocation);
}


// Function BP_WaterSpline.BP_WaterSpline_C.GetPlayerControllerCameraRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FRotator*                        PlayerControllerCameraRotation                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_WaterSpline_C::GetPlayerControllerCameraRotation(struct FRotator* PlayerControllerCameraRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "GetPlayerControllerCameraRotation");

	Params::BP_WaterSpline_C_GetPlayerControllerCameraRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayerControllerCameraRotation != nullptr)
		*PlayerControllerCameraRotation = std::move(Parms.PlayerControllerCameraRotation);
}


// Function BP_WaterSpline.BP_WaterSpline_C.GetSplineComponent
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineComponent*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash)

class USplineComponent* ABP_WaterSpline_C::GetSplineComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "GetSplineComponent");

	Params::BP_WaterSpline_C_GetSplineComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_WaterSpline.BP_WaterSpline_C.GetSplineEmitterComponent
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash)

class USceneComponent* ABP_WaterSpline_C::GetSplineEmitterComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "GetSplineEmitterComponent");

	Params::BP_WaterSpline_C_GetSplineEmitterComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_WaterSpline.BP_WaterSpline_C.Init Padded Spline
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Init_Padded_Spline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Init Padded Spline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Intersect Lines
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector2D&                 P0                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector2D&                 P1                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector2D&                 P2                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector2D&                 P3                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D*                       Intersection_Point                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Intersected_                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::Intersect_Lines(const struct FVector2D& P0, const struct FVector2D& P1, const struct FVector2D& P2, const struct FVector2D& P3, struct FVector2D* Intersection_Point, bool* Intersected_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Intersect Lines");

	Params::BP_WaterSpline_C_Intersect_Lines Parms{};

	Parms.P0 = std::move(P0);
	Parms.P1 = std::move(P1);
	Parms.P2 = std::move(P2);
	Parms.P3 = std::move(P3);

	UObject::ProcessEvent(Func, &Parms);

	if (Intersection_Point != nullptr)
		*Intersection_Point = std::move(Parms.Intersection_Point);

	if (Intersected_ != nullptr)
		*Intersected_ = Parms.Intersected_;
}


// Function BP_WaterSpline.BP_WaterSpline_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_WaterSpline_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "ReceiveEndPlay");

	Params::BP_WaterSpline_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterSpline.BP_WaterSpline_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "ReceiveTick");

	Params::BP_WaterSpline_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Refresh Water Info
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Refresh_Water_Info()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Refresh Water Info");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Refresh Water Info Delayed
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Refresh_Water_Info_Delayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Refresh Water Info Delayed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Remove Spline Loops
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineComponent*                 InSpline                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::Remove_Spline_Loops(class USplineComponent* InSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Remove Spline Loops");

	Params::BP_WaterSpline_C_Remove_Spline_Loops Parms{};

	Parms.InSpline = InSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterSpline.BP_WaterSpline_C.RenderingMinimap
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Rendering                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::RenderingMinimap(bool Rendering)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "RenderingMinimap");

	Params::BP_WaterSpline_C_RenderingMinimap Parms{};

	Parms.Rendering = Rendering;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Setup StaticMesh
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UStaticMeshComponent*             Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UStaticMesh*&                     Var                                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::Setup_StaticMesh(class UStaticMesh* Mesh, class UStaticMeshComponent* Component, class UStaticMesh*& Var)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Setup StaticMesh");

	Params::BP_WaterSpline_C_Setup_StaticMesh Parms{};

	Parms.Mesh = Mesh;
	Parms.Component = Component;
	Parms.Var = Var;

	UObject::ProcessEvent(Func, &Parms);

	Var = Parms.Var;
}


// Function BP_WaterSpline.BP_WaterSpline_C.SetupDebug
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::SetupDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "SetupDebug");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Snap Spline To Lake Edge
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Snap_Spline_To_Lake_Edge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Snap Spline To Lake Edge");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Snap Spline To Spline
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Snap_Spline_To_Spline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Snap Spline To Spline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.UnwindRadians
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  R                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Out                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterSpline_C::UnwindRadians(double R, double* Out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "UnwindRadians");

	Params::BP_WaterSpline_C_UnwindRadians Parms{};

	Parms.R = R;

	UObject::ProcessEvent(Func, &Parms);

	if (Out != nullptr)
		*Out = Parms.Out;
}


// Function BP_WaterSpline.BP_WaterSpline_C.Update Dynamic Meshes
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Update_Dynamic_Meshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Update Dynamic Meshes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Update Mesh Visibility
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Update_Mesh_Visibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Update Mesh Visibility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.Update Static Meshes
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::Update_Static_Meshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "Update Static Meshes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterSpline.BP_WaterSpline_C.UserConstructionScript
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterSpline_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterSpline_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}

}

