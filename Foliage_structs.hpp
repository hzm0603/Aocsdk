#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Foliage

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "NetCore_structs.hpp"


namespace SDK
{

// Enum Foliage.FoliageVertexColorMask
// NumValues: 0x0006
enum class EFoliageVertexColorMask : uint8
{
	FOLIAGEVERTEXCOLORMASK_Disabled          = 0,
	FOLIAGEVERTEXCOLORMASK_Red               = 1,
	FOLIAGEVERTEXCOLORMASK_Green             = 2,
	FOLIAGEVERTEXCOLORMASK_Blue              = 3,
	FOLIAGEVERTEXCOLORMASK_Alpha             = 4,
	FOLIAGEVERTEXCOLORMASK_MAX               = 5,
};

// Enum Foliage.EVertexColorMaskChannel
// NumValues: 0x0006
enum class EVertexColorMaskChannel : uint8
{
	Red                                      = 0,
	Green                                    = 1,
	Blue                                     = 2,
	Alpha                                    = 3,
	MAX_None                                 = 4,
	EVertexColorMaskChannel_MAX              = 5,
};

// Enum Foliage.EFoliageScaling
// NumValues: 0x0006
enum class EFoliageScaling : uint8
{
	Uniform                                  = 0,
	Free                                     = 1,
	LockXY                                   = 2,
	LockXZ                                   = 3,
	LockYZ                                   = 4,
	EFoliageScaling_MAX                      = 5,
};

// Enum Foliage.EFoliageState
// NumValues: 0x0005
enum class EFoliageState : uint8
{
	Infancy                                  = 0,
	Juvenile                                 = 1,
	Adult                                    = 2,
	Empty                                    = 3,
	EFoliageState_MAX                        = 4,
};

// Enum Foliage.ESimulationOverlap
// NumValues: 0x0004
enum class ESimulationOverlap : uint8
{
	CollisionOverlap                         = 0,
	ShadeOverlap                             = 1,
	None                                     = 2,
	ESimulationOverlap_MAX                   = 3,
};

// Enum Foliage.ESimulationQuery
// NumValues: 0x0005
enum class ESimulationQuery : uint8
{
	None                                     = 0,
	CollisionOverlap                         = 1,
	ShadeOverlap                             = 2,
	AnyOverlap                               = 3,
	ESimulationQuery_MAX                     = 4,
};

// ScriptStruct Foliage.FoliageInstanceData
// 0x0070 (0x0070 - 0x0000)
struct FFoliageInstanceData final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFoliageState                                 FoliageState;                                      // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressed;                                       // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0xE];                                       // 0x0062(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFoliageInstanceData) == 0x000010, "Wrong alignment on FFoliageInstanceData");
static_assert(sizeof(FFoliageInstanceData) == 0x000070, "Wrong size on FFoliageInstanceData");
static_assert(offsetof(FFoliageInstanceData, Transform) == 0x000000, "Member 'FFoliageInstanceData::Transform' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceData, FoliageState) == 0x000060, "Member 'FFoliageInstanceData::FoliageState' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceData, bSuppressed) == 0x000061, "Member 'FFoliageInstanceData::bSuppressed' has a wrong offset!");

// ScriptStruct Foliage.DistanceMaterialOverrides
// 0x0010 (0x0010 - 0x0000)
struct FDistanceMaterialOverrides final
{
public:
	TArray<class UMaterialInterface*>             PerQualityMaterialOverrides;                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDistanceMaterialOverrides) == 0x000008, "Wrong alignment on FDistanceMaterialOverrides");
static_assert(sizeof(FDistanceMaterialOverrides) == 0x000010, "Wrong size on FDistanceMaterialOverrides");
static_assert(offsetof(FDistanceMaterialOverrides, PerQualityMaterialOverrides) == 0x000000, "Member 'FDistanceMaterialOverrides::PerQualityMaterialOverrides' has a wrong offset!");

// ScriptStruct Foliage.FoliageVertexColorChannelMask
// 0x000C (0x000C - 0x0000)
struct FFoliageVertexColorChannelMask final
{
public:
	uint8                                         UseMask : 1;                                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaskThreshold;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InvertMask : 1;                                    // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFoliageVertexColorChannelMask) == 0x000004, "Wrong alignment on FFoliageVertexColorChannelMask");
static_assert(sizeof(FFoliageVertexColorChannelMask) == 0x00000C, "Wrong size on FFoliageVertexColorChannelMask");
static_assert(offsetof(FFoliageVertexColorChannelMask, MaskThreshold) == 0x000004, "Member 'FFoliageVertexColorChannelMask::MaskThreshold' has a wrong offset!");

// ScriptStruct Foliage.FoliageDensityFalloff
// 0x0098 (0x0098 - 0x0000)
struct FFoliageDensityFalloff final
{
public:
	bool                                          bUseFalloffCurve;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     FalloffCurve;                                      // 0x0008(0x0090)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFoliageDensityFalloff) == 0x000008, "Wrong alignment on FFoliageDensityFalloff");
static_assert(sizeof(FFoliageDensityFalloff) == 0x000098, "Wrong size on FFoliageDensityFalloff");
static_assert(offsetof(FFoliageDensityFalloff, bUseFalloffCurve) == 0x000000, "Member 'FFoliageDensityFalloff::bUseFalloffCurve' has a wrong offset!");
static_assert(offsetof(FFoliageDensityFalloff, FalloffCurve) == 0x000008, "Member 'FFoliageDensityFalloff::FalloffCurve' has a wrong offset!");

// ScriptStruct Foliage.QualityLevelMaterialOverrides
// 0x0010 (0x0010 - 0x0000)
struct FQualityLevelMaterialOverrides final
{
public:
	TArray<class UMaterialInterface*>             PerQualityMaterialOverrides;                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQualityLevelMaterialOverrides) == 0x000008, "Wrong alignment on FQualityLevelMaterialOverrides");
static_assert(sizeof(FQualityLevelMaterialOverrides) == 0x000010, "Wrong size on FQualityLevelMaterialOverrides");
static_assert(offsetof(FQualityLevelMaterialOverrides, PerQualityMaterialOverrides) == 0x000000, "Member 'FQualityLevelMaterialOverrides::PerQualityMaterialOverrides' has a wrong offset!");

// ScriptStruct Foliage.FoliageRagdollData
// 0x0010 (0x0010 - 0x0000)
struct FFoliageRagdollData final
{
public:
	float                                         ImpulseForce;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ImpulseForceBoneName;                              // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseDirectionAngle;                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFoliageRagdollData) == 0x000004, "Wrong alignment on FFoliageRagdollData");
static_assert(sizeof(FFoliageRagdollData) == 0x000010, "Wrong size on FFoliageRagdollData");
static_assert(offsetof(FFoliageRagdollData, ImpulseForce) == 0x000000, "Member 'FFoliageRagdollData::ImpulseForce' has a wrong offset!");
static_assert(offsetof(FFoliageRagdollData, ImpulseForceBoneName) == 0x000004, "Member 'FFoliageRagdollData::ImpulseForceBoneName' has a wrong offset!");
static_assert(offsetof(FFoliageRagdollData, ImpulseDirectionAngle) == 0x00000C, "Member 'FFoliageRagdollData::ImpulseDirectionAngle' has a wrong offset!");

// ScriptStruct Foliage.FoliageScaleData
// 0x0008 (0x0008 - 0x0000)
struct FFoliageScaleData final
{
public:
	int32                                         OriginalInstanceIndex;                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFoliageState                                 ScaleState;                                        // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFoliageScaleData) == 0x000004, "Wrong alignment on FFoliageScaleData");
static_assert(sizeof(FFoliageScaleData) == 0x000008, "Wrong size on FFoliageScaleData");
static_assert(offsetof(FFoliageScaleData, OriginalInstanceIndex) == 0x000000, "Member 'FFoliageScaleData::OriginalInstanceIndex' has a wrong offset!");
static_assert(offsetof(FFoliageScaleData, ScaleState) == 0x000004, "Member 'FFoliageScaleData::ScaleState' has a wrong offset!");

// ScriptStruct Foliage.PlayerInteractionData
// 0x0018 (0x0018 - 0x0000)
struct FPlayerInteractionData final
{
public:
	class USkeletalMesh*                          ToolSkeletalMesh;                                  // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneAttachment;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PlayerAnimation;                                   // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInteractionData) == 0x000008, "Wrong alignment on FPlayerInteractionData");
static_assert(sizeof(FPlayerInteractionData) == 0x000018, "Wrong size on FPlayerInteractionData");
static_assert(offsetof(FPlayerInteractionData, ToolSkeletalMesh) == 0x000000, "Member 'FPlayerInteractionData::ToolSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FPlayerInteractionData, BoneAttachment) == 0x000008, "Member 'FPlayerInteractionData::BoneAttachment' has a wrong offset!");
static_assert(offsetof(FPlayerInteractionData, PlayerAnimation) == 0x000010, "Member 'FPlayerInteractionData::PlayerAnimation' has a wrong offset!");

// ScriptStruct Foliage.InstanceOIData
// 0x0010 (0x0010 - 0x0000)
struct FInstanceOIData final
{
public:
	TArray<uint16>                                OIData;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInstanceOIData) == 0x000008, "Wrong alignment on FInstanceOIData");
static_assert(sizeof(FInstanceOIData) == 0x000010, "Wrong size on FInstanceOIData");
static_assert(offsetof(FInstanceOIData, OIData) == 0x000000, "Member 'FInstanceOIData::OIData' has a wrong offset!");

// ScriptStruct Foliage.InstanceInteractionData
// 0x0010 (0x0010 - 0x0000)
struct FInstanceInteractionData final
{
public:
	TArray<struct FGuid>                          PlayerGuids;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInstanceInteractionData) == 0x000008, "Wrong alignment on FInstanceInteractionData");
static_assert(sizeof(FInstanceInteractionData) == 0x000010, "Wrong size on FInstanceInteractionData");
static_assert(offsetof(FInstanceInteractionData, PlayerGuids) == 0x000000, "Member 'FInstanceInteractionData::PlayerGuids' has a wrong offset!");

// ScriptStruct Foliage.RuntimeSkeletalMeshData
// 0x0020 (0x0020 - 0x0000)
struct FRuntimeSkeletalMeshData final
{
public:
	EFoliageState                                 FoliageState;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        LastInteractedTime;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRuntimeSkeletalMeshData) == 0x000008, "Wrong alignment on FRuntimeSkeletalMeshData");
static_assert(sizeof(FRuntimeSkeletalMeshData) == 0x000020, "Wrong size on FRuntimeSkeletalMeshData");
static_assert(offsetof(FRuntimeSkeletalMeshData, FoliageState) == 0x000000, "Member 'FRuntimeSkeletalMeshData::FoliageState' has a wrong offset!");
static_assert(offsetof(FRuntimeSkeletalMeshData, LastInteractedTime) == 0x000008, "Member 'FRuntimeSkeletalMeshData::LastInteractedTime' has a wrong offset!");

// ScriptStruct Foliage.MeshLifetimeData
// 0x0018 (0x0018 - 0x0000)
struct FMeshLifetimeData final
{
public:
	class UMeshComponent*                         MeshComponent;                                     // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFoliageState                                 FoliageState;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DestroyTime;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshLifetimeData) == 0x000008, "Wrong alignment on FMeshLifetimeData");
static_assert(sizeof(FMeshLifetimeData) == 0x000018, "Wrong size on FMeshLifetimeData");
static_assert(offsetof(FMeshLifetimeData, MeshComponent) == 0x000000, "Member 'FMeshLifetimeData::MeshComponent' has a wrong offset!");
static_assert(offsetof(FMeshLifetimeData, FoliageState) == 0x000008, "Member 'FMeshLifetimeData::FoliageState' has a wrong offset!");
static_assert(offsetof(FMeshLifetimeData, DestroyTime) == 0x000010, "Member 'FMeshLifetimeData::DestroyTime' has a wrong offset!");

// ScriptStruct Foliage.FoliageLifetimeData
// 0x0010 (0x0010 - 0x0000)
struct FFoliageLifetimeData final
{
public:
	double                                        RemainingTime;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFoliageState                                 TargetState;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFoliageLifetimeData) == 0x000008, "Wrong alignment on FFoliageLifetimeData");
static_assert(sizeof(FFoliageLifetimeData) == 0x000010, "Wrong size on FFoliageLifetimeData");
static_assert(offsetof(FFoliageLifetimeData, RemainingTime) == 0x000000, "Member 'FFoliageLifetimeData::RemainingTime' has a wrong offset!");
static_assert(offsetof(FFoliageLifetimeData, TargetState) == 0x000008, "Member 'FFoliageLifetimeData::TargetState' has a wrong offset!");

// ScriptStruct Foliage.FoliageCollision
// 0x0002 (0x0002 - 0x0000)
struct FFoliageCollision final
{
public:
	bool                                          bBlockPawn;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockCamera;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFoliageCollision) == 0x000001, "Wrong alignment on FFoliageCollision");
static_assert(sizeof(FFoliageCollision) == 0x000002, "Wrong size on FFoliageCollision");
static_assert(offsetof(FFoliageCollision, bBlockPawn) == 0x000000, "Member 'FFoliageCollision::bBlockPawn' has a wrong offset!");
static_assert(offsetof(FFoliageCollision, bBlockCamera) == 0x000001, "Member 'FFoliageCollision::bBlockCamera' has a wrong offset!");

// ScriptStruct Foliage.FoliageInstanceStateData
// 0x0098 (0x0098 - 0x0000)
struct FFoliageInstanceStateData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	class UStaticMesh*                            FoliageInstanceStaticMesh;                         // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          FoliageInstanceSkeletalMesh;                       // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGeometryCollection*                    FoliageFracturedMesh;                              // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            FoliageFractureSupportMesh;                        // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkeletalMeshSimulatePhysics;                      // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRuntimeMesh;                                      // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFoliageRagdollData                    SkeletalMeshRagdollData;                           // 0x003C(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           SkeletalMeshGatheredAnimation;                     // 0x0050(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SkeletalMeshGatheringEventAnimation;               // 0x0058(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerInteractionData                 PlayerInteractionData;                             // 0x0060(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         LifecycleDuration;                                 // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFoliageCollision                      CollisionDefinition;                               // 0x007C(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeshLifetimeDuration;                              // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseGatheringDuration;                             // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTransitionScale;                            // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartingScalePercentage;                           // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleLerpSpeed;                                    // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFoliageInstanceStateData) == 0x000008, "Wrong alignment on FFoliageInstanceStateData");
static_assert(sizeof(FFoliageInstanceStateData) == 0x000098, "Wrong size on FFoliageInstanceStateData");
static_assert(offsetof(FFoliageInstanceStateData, DisplayName) == 0x000000, "Member 'FFoliageInstanceStateData::DisplayName' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, FoliageInstanceStaticMesh) == 0x000018, "Member 'FFoliageInstanceStateData::FoliageInstanceStaticMesh' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, FoliageInstanceSkeletalMesh) == 0x000020, "Member 'FFoliageInstanceStateData::FoliageInstanceSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, FoliageFracturedMesh) == 0x000028, "Member 'FFoliageInstanceStateData::FoliageFracturedMesh' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, FoliageFractureSupportMesh) == 0x000030, "Member 'FFoliageInstanceStateData::FoliageFractureSupportMesh' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, bSkeletalMeshSimulatePhysics) == 0x000038, "Member 'FFoliageInstanceStateData::bSkeletalMeshSimulatePhysics' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, bRuntimeMesh) == 0x000039, "Member 'FFoliageInstanceStateData::bRuntimeMesh' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, SkeletalMeshRagdollData) == 0x00003C, "Member 'FFoliageInstanceStateData::SkeletalMeshRagdollData' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, SkeletalMeshGatheredAnimation) == 0x000050, "Member 'FFoliageInstanceStateData::SkeletalMeshGatheredAnimation' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, SkeletalMeshGatheringEventAnimation) == 0x000058, "Member 'FFoliageInstanceStateData::SkeletalMeshGatheringEventAnimation' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, PlayerInteractionData) == 0x000060, "Member 'FFoliageInstanceStateData::PlayerInteractionData' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, LifecycleDuration) == 0x000078, "Member 'FFoliageInstanceStateData::LifecycleDuration' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, CollisionDefinition) == 0x00007C, "Member 'FFoliageInstanceStateData::CollisionDefinition' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, MeshLifetimeDuration) == 0x000080, "Member 'FFoliageInstanceStateData::MeshLifetimeDuration' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, BaseGatheringDuration) == 0x000084, "Member 'FFoliageInstanceStateData::BaseGatheringDuration' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, bShouldTransitionScale) == 0x000088, "Member 'FFoliageInstanceStateData::bShouldTransitionScale' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, StartingScalePercentage) == 0x00008C, "Member 'FFoliageInstanceStateData::StartingScalePercentage' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceStateData, ScaleLerpSpeed) == 0x000090, "Member 'FFoliageInstanceStateData::ScaleLerpSpeed' has a wrong offset!");

// ScriptStruct Foliage.FoliageQuadTreeElement
// 0x0058 (0x0058 - 0x0000)
struct FFoliageQuadTreeElement final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         FoliageActorGuid;                                  // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 FoliageBox;                                        // 0x0020(0x0028)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ActorName;                                         // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFoliageQuadTreeElement) == 0x000008, "Wrong alignment on FFoliageQuadTreeElement");
static_assert(sizeof(FFoliageQuadTreeElement) == 0x000058, "Wrong size on FFoliageQuadTreeElement");
static_assert(offsetof(FFoliageQuadTreeElement, Position) == 0x000000, "Member 'FFoliageQuadTreeElement::Position' has a wrong offset!");
static_assert(offsetof(FFoliageQuadTreeElement, FoliageActorGuid) == 0x000018, "Member 'FFoliageQuadTreeElement::FoliageActorGuid' has a wrong offset!");
static_assert(offsetof(FFoliageQuadTreeElement, FoliageBox) == 0x000020, "Member 'FFoliageQuadTreeElement::FoliageBox' has a wrong offset!");
static_assert(offsetof(FFoliageQuadTreeElement, ActorName) == 0x000048, "Member 'FFoliageQuadTreeElement::ActorName' has a wrong offset!");

// ScriptStruct Foliage.FoliageProxyStateData
// 0x0028 (0x0028 - 0x0000)
struct FFoliageProxyStateData final
{
public:
	struct FSoftObjectPath                        FoliageInstanceStaticMeshObjectPath;               // 0x0000(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFoliageCollision                      CollisionDefinition;                               // 0x0020(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bInteractable;                                     // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFoliageProxyStateData) == 0x000008, "Wrong alignment on FFoliageProxyStateData");
static_assert(sizeof(FFoliageProxyStateData) == 0x000028, "Wrong size on FFoliageProxyStateData");
static_assert(offsetof(FFoliageProxyStateData, FoliageInstanceStaticMeshObjectPath) == 0x000000, "Member 'FFoliageProxyStateData::FoliageInstanceStaticMeshObjectPath' has a wrong offset!");
static_assert(offsetof(FFoliageProxyStateData, CollisionDefinition) == 0x000020, "Member 'FFoliageProxyStateData::CollisionDefinition' has a wrong offset!");
static_assert(offsetof(FFoliageProxyStateData, bInteractable) == 0x000022, "Member 'FFoliageProxyStateData::bInteractable' has a wrong offset!");

// ScriptStruct Foliage.FoliageInstanceProxyData
// 0x0004 (0x0004 - 0x0000)
struct FFoliageInstanceProxyData final
{
public:
	uint16                                        Index;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFoliageState                                 FoliageState;                                      // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFoliageInstanceProxyData) == 0x000002, "Wrong alignment on FFoliageInstanceProxyData");
static_assert(sizeof(FFoliageInstanceProxyData) == 0x000004, "Wrong size on FFoliageInstanceProxyData");
static_assert(offsetof(FFoliageInstanceProxyData, Index) == 0x000000, "Member 'FFoliageInstanceProxyData::Index' has a wrong offset!");
static_assert(offsetof(FFoliageInstanceProxyData, FoliageState) == 0x000002, "Member 'FFoliageInstanceProxyData::FoliageState' has a wrong offset!");

// ScriptStruct Foliage.InstancedFoliageState
// 0x0001 (0x0001 - 0x0000)
struct FInstancedFoliageState final
{
public:
	uint8                                         States;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInstancedFoliageState) == 0x000001, "Wrong alignment on FInstancedFoliageState");
static_assert(sizeof(FInstancedFoliageState) == 0x000001, "Wrong size on FInstancedFoliageState");
static_assert(offsetof(FInstancedFoliageState, States) == 0x000000, "Member 'FInstancedFoliageState::States' has a wrong offset!");

// ScriptStruct Foliage.uint16FInstancedFoliageStateMapElement
// 0x0004 (0x0010 - 0x000C)
struct Fuint16FInstancedFoliageStateMapElement final : public FFastArraySerializerItem
{
public:
	struct FInstancedFoliageState                 Value;                                             // 0x000C(0x0001)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x1];                                        // 0x000D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        Key;                                               // 0x000E(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Fuint16FInstancedFoliageStateMapElement) == 0x000004, "Wrong alignment on Fuint16FInstancedFoliageStateMapElement");
static_assert(sizeof(Fuint16FInstancedFoliageStateMapElement) == 0x000010, "Wrong size on Fuint16FInstancedFoliageStateMapElement");
static_assert(offsetof(Fuint16FInstancedFoliageStateMapElement, Value) == 0x00000C, "Member 'Fuint16FInstancedFoliageStateMapElement::Value' has a wrong offset!");
static_assert(offsetof(Fuint16FInstancedFoliageStateMapElement, Key) == 0x00000E, "Member 'Fuint16FInstancedFoliageStateMapElement::Key' has a wrong offset!");

// ScriptStruct Foliage.FMapuint16FInstancedFoliageState
// 0x00E0 (0x01F0 - 0x0110)
struct FFMapuint16FInstancedFoliageState final : public FFastMapHelper
{
public:
	TArray<struct Fuint16FInstancedFoliageStateMapElement> Items;                                    // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<uint16, struct FInstancedFoliageState>   LookUp;                                            // 0x0120(0x0050)(Transient, RepSkip, NativeAccessSpecifierPublic)
	TMap<uint16, struct FInstancedFoliageState>   OldLookup;                                         // 0x0170(0x0050)(Transient, RepSkip, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C0[0x30];                                     // 0x01C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFMapuint16FInstancedFoliageState) == 0x000008, "Wrong alignment on FFMapuint16FInstancedFoliageState");
static_assert(sizeof(FFMapuint16FInstancedFoliageState) == 0x0001F0, "Wrong size on FFMapuint16FInstancedFoliageState");
static_assert(offsetof(FFMapuint16FInstancedFoliageState, Items) == 0x000110, "Member 'FFMapuint16FInstancedFoliageState::Items' has a wrong offset!");
static_assert(offsetof(FFMapuint16FInstancedFoliageState, LookUp) == 0x000120, "Member 'FFMapuint16FInstancedFoliageState::LookUp' has a wrong offset!");
static_assert(offsetof(FFMapuint16FInstancedFoliageState, OldLookup) == 0x000170, "Member 'FFMapuint16FInstancedFoliageState::OldLookup' has a wrong offset!");

// ScriptStruct Foliage.FoliageTypeObject
// 0x0020 (0x0020 - 0x0000)
struct FFoliageTypeObject final
{
public:
	class UObject*                                FoliageTypeObject;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFoliageType*                           TypeInstance;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAsset;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFoliageType_InstancedStaticMesh> Type;                                        // 0x0018(0x0008)(ZeroConstructor, Deprecated, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFoliageTypeObject) == 0x000008, "Wrong alignment on FFoliageTypeObject");
static_assert(sizeof(FFoliageTypeObject) == 0x000020, "Wrong size on FFoliageTypeObject");
static_assert(offsetof(FFoliageTypeObject, FoliageTypeObject) == 0x000000, "Member 'FFoliageTypeObject::FoliageTypeObject' has a wrong offset!");
static_assert(offsetof(FFoliageTypeObject, TypeInstance) == 0x000008, "Member 'FFoliageTypeObject::TypeInstance' has a wrong offset!");
static_assert(offsetof(FFoliageTypeObject, bIsAsset) == 0x000010, "Member 'FFoliageTypeObject::bIsAsset' has a wrong offset!");
static_assert(offsetof(FFoliageTypeObject, Type) == 0x000018, "Member 'FFoliageTypeObject::Type' has a wrong offset!");

// ScriptStruct Foliage.ProceduralFoliageInstance
// 0x0080 (0x0080 - 0x0000)
struct FProceduralFoliageInstance final
{
public:
	struct FQuat                                  Rotation;                                          // 0x0000(0x0020)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Age;                                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Normal;                                            // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFoliageType*                           Type;                                              // 0x0060(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralFoliageInstance) == 0x000010, "Wrong alignment on FProceduralFoliageInstance");
static_assert(sizeof(FProceduralFoliageInstance) == 0x000080, "Wrong size on FProceduralFoliageInstance");
static_assert(offsetof(FProceduralFoliageInstance, Rotation) == 0x000000, "Member 'FProceduralFoliageInstance::Rotation' has a wrong offset!");
static_assert(offsetof(FProceduralFoliageInstance, Location) == 0x000020, "Member 'FProceduralFoliageInstance::Location' has a wrong offset!");
static_assert(offsetof(FProceduralFoliageInstance, Age) == 0x000038, "Member 'FProceduralFoliageInstance::Age' has a wrong offset!");
static_assert(offsetof(FProceduralFoliageInstance, Normal) == 0x000040, "Member 'FProceduralFoliageInstance::Normal' has a wrong offset!");
static_assert(offsetof(FProceduralFoliageInstance, Scale) == 0x000058, "Member 'FProceduralFoliageInstance::Scale' has a wrong offset!");
static_assert(offsetof(FProceduralFoliageInstance, Type) == 0x000060, "Member 'FProceduralFoliageInstance::Type' has a wrong offset!");

}

