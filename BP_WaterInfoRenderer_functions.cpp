#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_WaterInfoRenderer

#include "Basic.hpp"

#include "BP_WaterInfoRenderer_classes.hpp"
#include "BP_WaterInfoRenderer_parameters.hpp"


namespace SDK
{

// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Check if Rendering
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   IsRendering_0                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterInfoRenderer_C::Check_if_Rendering(bool* IsRendering_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Check if Rendering");

	Params::BP_WaterInfoRenderer_C_Check_if_Rendering Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsRendering_0 != nullptr)
		*IsRendering_0 = Parms.IsRendering_0;
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Check Player Loc
// (BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::Check_Player_Loc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Check Player Loc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Check Refresh
// (BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::Check_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Check Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Editor Water Tick
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::Editor_Water_Tick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Editor Water Tick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Editor Water Update
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::Editor_Water_Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Editor Water Update");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.ExecuteUbergraph_BP_WaterInfoRenderer
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterInfoRenderer_C::ExecuteUbergraph_BP_WaterInfoRenderer(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "ExecuteUbergraph_BP_WaterInfoRenderer");

	Params::BP_WaterInfoRenderer_C_ExecuteUbergraph_BP_WaterInfoRenderer Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Fix up all Loaded Water Actors
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::Fix_up_all_Loaded_Water_Actors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Fix up all Loaded Water Actors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Get Current at Location
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   World_Location                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D*                       Current_Velocity                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterInfoRenderer_C::Get_Current_at_Location(const struct FVector& World_Location, struct FVector2D* Current_Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Get Current at Location");

	Params::BP_WaterInfoRenderer_C_Get_Current_at_Location Parms{};

	Parms.World_Location = std::move(World_Location);

	UObject::ProcessEvent(Func, &Parms);

	if (Current_Velocity != nullptr)
		*Current_Velocity = std::move(Parms.Current_Velocity);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Init Processing MID
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::Init_Processing_MID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Init Processing MID");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Initialize GUID
// (BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::Initialize_GUID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Initialize GUID");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.IsOverlapping2D
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector2D&                 Max                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector2D&                 Max_0                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector2D&                 Max_1                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector2D&                 Max_2                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector2D&                 Max_3                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector2D&                 Max_4                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsOverlapping                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterInfoRenderer_C::IsOverlapping2D(const struct FVector2D& Max, const struct FVector2D& Max_0, const struct FVector2D& Max_1, const struct FVector2D& Max_2, const struct FVector2D& Max_3, const struct FVector2D& Max_4, bool* IsOverlapping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "IsOverlapping2D");

	Params::BP_WaterInfoRenderer_C_IsOverlapping2D Parms{};

	Parms.Max = std::move(Max);
	Parms.Max_0 = std::move(Max_0);
	Parms.Max_1 = std::move(Max_1);
	Parms.Max_2 = std::move(Max_2);
	Parms.Max_3 = std::move(Max_3);
	Parms.Max_4 = std::move(Max_4);

	UObject::ProcessEvent(Func, &Parms);

	if (IsOverlapping != nullptr)
		*IsOverlapping = Parms.IsOverlapping;
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.IsOverlappingGrid2D
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsOverlapping                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterInfoRenderer_C::IsOverlappingGrid2D(class AActor* Actor, bool* IsOverlapping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "IsOverlappingGrid2D");

	Params::BP_WaterInfoRenderer_C_IsOverlappingGrid2D Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

	if (IsOverlapping != nullptr)
		*IsOverlapping = Parms.IsOverlapping;
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Pad Spline Ends
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineComponent*                 Spline                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_WaterInfoRenderer_C::Pad_Spline_Ends(class USplineComponent* Spline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Pad Spline Ends");

	Params::BP_WaterInfoRenderer_C_Pad_Spline_Ends Parms{};

	Parms.Spline = Spline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_WaterInfoRenderer_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterInfoRenderer_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "ReceiveTick");

	Params::BP_WaterInfoRenderer_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Register Lake
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_WaterLake_C*                  LakeRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_WaterInfoRenderer_C::Register_Lake(class ABP_WaterLake_C* LakeRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Register Lake");

	Params::BP_WaterInfoRenderer_C_Register_Lake Parms{};

	Parms.LakeRef = LakeRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Register Spline
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_WaterSpline_C*                SplineRef                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_WaterInfoRenderer_C::Register_Spline(class ABP_WaterSpline_C* SplineRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Register Spline");

	Params::BP_WaterInfoRenderer_C_Register_Spline Parms{};

	Parms.SplineRef = SplineRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Render Water Actors
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::Render_Water_Actors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Render Water Actors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.RenderDelayed
// (BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::RenderDelayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "RenderDelayed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.RenderInstant
// (BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::RenderInstant()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "RenderInstant");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.RenderNextWaterActor
// (BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::RenderNextWaterActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "RenderNextWaterActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Set Water Params
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::Set_Water_Params()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Set Water Params");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Unpad Spline Ends
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineComponent*                 Spline                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_WaterInfoRenderer_C::Unpad_Spline_Ends(class USplineComponent* Spline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Unpad Spline Ends");

	Params::BP_WaterInfoRenderer_C_Unpad_Spline_Ends Parms{};

	Parms.Spline = Spline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Unregister Lake
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_WaterLake_C*                  LakeRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_WaterInfoRenderer_C::Unregister_Lake(class ABP_WaterLake_C* LakeRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Unregister Lake");

	Params::BP_WaterInfoRenderer_C_Unregister_Lake Parms{};

	Parms.LakeRef = LakeRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Unregister Spline
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_WaterSpline_C*                SplineRef                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_WaterInfoRenderer_C::Unregister_Spline(class ABP_WaterSpline_C* SplineRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Unregister Spline");

	Params::BP_WaterInfoRenderer_C_Unregister_Spline Parms{};

	Parms.SplineRef = SplineRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.Update WaterActor Registry
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::Update_WaterActor_Registry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "Update WaterActor Registry");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterInfoRenderer.BP_WaterInfoRenderer_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterInfoRenderer_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterInfoRenderer_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}

}

