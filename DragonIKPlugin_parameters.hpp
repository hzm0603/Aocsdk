#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DragonIKPlugin

#include "Basic.hpp"

#include "DragonIKPlugin_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function DragonIKPlugin.DragonIKFootStepsComponent.CallFootSteps
// 0x0160 (0x0160 - 0x0000)
struct DragonIKFootStepsComponent_CallFootSteps final
{
public:
	class FName                                   bone_name;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             foot_transform;                                    // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         height_difference;                                 // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             hit_info;                                          // 0x0078(0x00E8)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKFootStepsComponent_CallFootSteps) == 0x000010, "Wrong alignment on DragonIKFootStepsComponent_CallFootSteps");
static_assert(sizeof(DragonIKFootStepsComponent_CallFootSteps) == 0x000160, "Wrong size on DragonIKFootStepsComponent_CallFootSteps");
static_assert(offsetof(DragonIKFootStepsComponent_CallFootSteps, bone_name) == 0x000000, "Member 'DragonIKFootStepsComponent_CallFootSteps::bone_name' has a wrong offset!");
static_assert(offsetof(DragonIKFootStepsComponent_CallFootSteps, foot_transform) == 0x000010, "Member 'DragonIKFootStepsComponent_CallFootSteps::foot_transform' has a wrong offset!");
static_assert(offsetof(DragonIKFootStepsComponent_CallFootSteps, height_difference) == 0x000070, "Member 'DragonIKFootStepsComponent_CallFootSteps::height_difference' has a wrong offset!");
static_assert(offsetof(DragonIKFootStepsComponent_CallFootSteps, hit_info) == 0x000078, "Member 'DragonIKFootStepsComponent_CallFootSteps::hit_info' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Control_Bone_Handle
// 0x0080 (0x0080 - 0x0000)
struct DragonIKPhysicsComponent_Control_Bone_Handle final
{
public:
	class FName                                   bone_name;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             override_transform;                                // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKPhysicsComponent_Control_Bone_Handle) == 0x000010, "Wrong alignment on DragonIKPhysicsComponent_Control_Bone_Handle");
static_assert(sizeof(DragonIKPhysicsComponent_Control_Bone_Handle) == 0x000080, "Wrong size on DragonIKPhysicsComponent_Control_Bone_Handle");
static_assert(offsetof(DragonIKPhysicsComponent_Control_Bone_Handle, bone_name) == 0x000000, "Member 'DragonIKPhysicsComponent_Control_Bone_Handle::bone_name' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Control_Bone_Handle, override_transform) == 0x000010, "Member 'DragonIKPhysicsComponent_Control_Bone_Handle::override_transform' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Control_Bone_Handle, Enable) == 0x000070, "Member 'DragonIKPhysicsComponent_Control_Bone_Handle::Enable' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.FirstTimeInitialization
// 0x0008 (0x0008 - 0x0000)
struct DragonIKPhysicsComponent_FirstTimeInitialization final
{
public:
	class USkeletalMeshComponent*                 skeleton_input;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_FirstTimeInitialization) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_FirstTimeInitialization");
static_assert(sizeof(DragonIKPhysicsComponent_FirstTimeInitialization) == 0x000008, "Wrong size on DragonIKPhysicsComponent_FirstTimeInitialization");
static_assert(offsetof(DragonIKPhysicsComponent_FirstTimeInitialization, skeleton_input) == 0x000000, "Member 'DragonIKPhysicsComponent_FirstTimeInitialization::skeleton_input' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Modify_Reset_Bone_Info
// 0x0010 (0x0010 - 0x0000)
struct DragonIKPhysicsComponent_Modify_Reset_Bone_Info final
{
public:
	TArray<class FName>                           bone_list;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Modify_Reset_Bone_Info) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_Modify_Reset_Bone_Info");
static_assert(sizeof(DragonIKPhysicsComponent_Modify_Reset_Bone_Info) == 0x000010, "Wrong size on DragonIKPhysicsComponent_Modify_Reset_Bone_Info");
static_assert(offsetof(DragonIKPhysicsComponent_Modify_Reset_Bone_Info, bone_list) == 0x000000, "Member 'DragonIKPhysicsComponent_Modify_Reset_Bone_Info::bone_list' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_Control_Bone_Handle
// 0x0080 (0x0080 - 0x0000)
struct DragonIKPhysicsComponent_Multicast_Control_Bone_Handle final
{
public:
	class FName                                   bone_name;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             override_transform;                                // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKPhysicsComponent_Multicast_Control_Bone_Handle) == 0x000010, "Wrong alignment on DragonIKPhysicsComponent_Multicast_Control_Bone_Handle");
static_assert(sizeof(DragonIKPhysicsComponent_Multicast_Control_Bone_Handle) == 0x000080, "Wrong size on DragonIKPhysicsComponent_Multicast_Control_Bone_Handle");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_Control_Bone_Handle, bone_name) == 0x000000, "Member 'DragonIKPhysicsComponent_Multicast_Control_Bone_Handle::bone_name' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_Control_Bone_Handle, override_transform) == 0x000010, "Member 'DragonIKPhysicsComponent_Multicast_Control_Bone_Handle::override_transform' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_Control_Bone_Handle, Enable) == 0x000070, "Member 'DragonIKPhysicsComponent_Multicast_Control_Bone_Handle::Enable' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_DragonIKSimulatePhysics
// 0x0018 (0x0018 - 0x0000)
struct DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics final
{
public:
	class USkeletalMeshComponent*                 SKMesh;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeSelf;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics");
static_assert(sizeof(DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics) == 0x000018, "Wrong size on DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics, SKMesh) == 0x000000, "Member 'DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics::SKMesh' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics, BoneName) == 0x000008, "Member 'DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics::BoneName' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics, IncludeSelf) == 0x000010, "Member 'DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics::IncludeSelf' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_FirstTimeInitialization
// 0x0008 (0x0008 - 0x0000)
struct DragonIKPhysicsComponent_Multicast_FirstTimeInitialization final
{
public:
	class USkeletalMeshComponent*                 skeleton_input;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Multicast_FirstTimeInitialization) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_Multicast_FirstTimeInitialization");
static_assert(sizeof(DragonIKPhysicsComponent_Multicast_FirstTimeInitialization) == 0x000008, "Wrong size on DragonIKPhysicsComponent_Multicast_FirstTimeInitialization");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_FirstTimeInitialization, skeleton_input) == 0x000000, "Member 'DragonIKPhysicsComponent_Multicast_FirstTimeInitialization::skeleton_input' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_Modify_Reset_Bone_Info
// 0x0010 (0x0010 - 0x0000)
struct DragonIKPhysicsComponent_Multicast_Modify_Reset_Bone_Info final
{
public:
	TArray<class FName>                           bone_list;                                         // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Multicast_Modify_Reset_Bone_Info) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_Multicast_Modify_Reset_Bone_Info");
static_assert(sizeof(DragonIKPhysicsComponent_Multicast_Modify_Reset_Bone_Info) == 0x000010, "Wrong size on DragonIKPhysicsComponent_Multicast_Modify_Reset_Bone_Info");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_Modify_Reset_Bone_Info, bone_list) == 0x000000, "Member 'DragonIKPhysicsComponent_Multicast_Modify_Reset_Bone_Info::bone_list' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_OnHitCallback
// 0x0128 (0x0128 - 0x0000)
struct DragonIKPhysicsComponent_Multicast_OnHitCallback final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   Optional_Override_Hit_Bone_Name;                   // 0x00E8(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                hit_location;                                      // 0x00F0(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                hit_impulse_direction;                             // 0x0108(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   hit_bone_name;                                     // 0x0120(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Multicast_OnHitCallback) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_Multicast_OnHitCallback");
static_assert(sizeof(DragonIKPhysicsComponent_Multicast_OnHitCallback) == 0x000128, "Wrong size on DragonIKPhysicsComponent_Multicast_OnHitCallback");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_OnHitCallback, Hit) == 0x000000, "Member 'DragonIKPhysicsComponent_Multicast_OnHitCallback::Hit' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_OnHitCallback, Optional_Override_Hit_Bone_Name) == 0x0000E8, "Member 'DragonIKPhysicsComponent_Multicast_OnHitCallback::Optional_Override_Hit_Bone_Name' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_OnHitCallback, hit_location) == 0x0000F0, "Member 'DragonIKPhysicsComponent_Multicast_OnHitCallback::hit_location' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_OnHitCallback, hit_impulse_direction) == 0x000108, "Member 'DragonIKPhysicsComponent_Multicast_OnHitCallback::hit_impulse_direction' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_OnHitCallback, hit_bone_name) == 0x000120, "Member 'DragonIKPhysicsComponent_Multicast_OnHitCallback::hit_bone_name' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_PerformActiveRagdoll
// 0x0004 (0x0004 - 0x0000)
struct DragonIKPhysicsComponent_Multicast_PerformActiveRagdoll final
{
public:
	float                                         pelvis_mass_override;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Multicast_PerformActiveRagdoll) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_Multicast_PerformActiveRagdoll");
static_assert(sizeof(DragonIKPhysicsComponent_Multicast_PerformActiveRagdoll) == 0x000004, "Wrong size on DragonIKPhysicsComponent_Multicast_PerformActiveRagdoll");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_PerformActiveRagdoll, pelvis_mass_override) == 0x000000, "Member 'DragonIKPhysicsComponent_Multicast_PerformActiveRagdoll::pelvis_mass_override' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_ReGrabAllHandles
// 0x0001 (0x0001 - 0x0000)
struct DragonIKPhysicsComponent_Multicast_ReGrabAllHandles final
{
public:
	bool                                          exit_ragdoll;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Multicast_ReGrabAllHandles) == 0x000001, "Wrong alignment on DragonIKPhysicsComponent_Multicast_ReGrabAllHandles");
static_assert(sizeof(DragonIKPhysicsComponent_Multicast_ReGrabAllHandles) == 0x000001, "Wrong size on DragonIKPhysicsComponent_Multicast_ReGrabAllHandles");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_ReGrabAllHandles, exit_ragdoll) == 0x000000, "Member 'DragonIKPhysicsComponent_Multicast_ReGrabAllHandles::exit_ragdoll' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_ReleaseAllHandles
// 0x0001 (0x0001 - 0x0000)
struct DragonIKPhysicsComponent_Multicast_ReleaseAllHandles final
{
public:
	bool                                          go_ragdoll;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Multicast_ReleaseAllHandles) == 0x000001, "Wrong alignment on DragonIKPhysicsComponent_Multicast_ReleaseAllHandles");
static_assert(sizeof(DragonIKPhysicsComponent_Multicast_ReleaseAllHandles) == 0x000001, "Wrong size on DragonIKPhysicsComponent_Multicast_ReleaseAllHandles");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_ReleaseAllHandles, go_ragdoll) == 0x000000, "Member 'DragonIKPhysicsComponent_Multicast_ReleaseAllHandles::go_ragdoll' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_SetInterpolation
// 0x0004 (0x0004 - 0x0000)
struct DragonIKPhysicsComponent_Multicast_SetInterpolation final
{
public:
	int32                                         inter_value;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Multicast_SetInterpolation) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_Multicast_SetInterpolation");
static_assert(sizeof(DragonIKPhysicsComponent_Multicast_SetInterpolation) == 0x000004, "Wrong size on DragonIKPhysicsComponent_Multicast_SetInterpolation");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_SetInterpolation, inter_value) == 0x000000, "Member 'DragonIKPhysicsComponent_Multicast_SetInterpolation::inter_value' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_UpdatePhysanimData
// 0x0010 (0x0010 - 0x0000)
struct DragonIKPhysicsComponent_Multicast_UpdatePhysanimData final
{
public:
	int32                                         LinearStrength;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularStrength;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LinearDamp;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularDamp;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Multicast_UpdatePhysanimData) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_Multicast_UpdatePhysanimData");
static_assert(sizeof(DragonIKPhysicsComponent_Multicast_UpdatePhysanimData) == 0x000010, "Wrong size on DragonIKPhysicsComponent_Multicast_UpdatePhysanimData");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_UpdatePhysanimData, LinearStrength) == 0x000000, "Member 'DragonIKPhysicsComponent_Multicast_UpdatePhysanimData::LinearStrength' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_UpdatePhysanimData, AngularStrength) == 0x000004, "Member 'DragonIKPhysicsComponent_Multicast_UpdatePhysanimData::AngularStrength' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_UpdatePhysanimData, LinearDamp) == 0x000008, "Member 'DragonIKPhysicsComponent_Multicast_UpdatePhysanimData::LinearDamp' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Multicast_UpdatePhysanimData, AngularDamp) == 0x00000C, "Member 'DragonIKPhysicsComponent_Multicast_UpdatePhysanimData::AngularDamp' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.OnHitCallback
// 0x0128 (0x0128 - 0x0000)
struct DragonIKPhysicsComponent_OnHitCallback final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   Optional_Override_Hit_Bone_Name;                   // 0x00E8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                hit_location;                                      // 0x00F0(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                hit_impulse_direction;                             // 0x0108(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   hit_bone_name;                                     // 0x0120(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_OnHitCallback) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_OnHitCallback");
static_assert(sizeof(DragonIKPhysicsComponent_OnHitCallback) == 0x000128, "Wrong size on DragonIKPhysicsComponent_OnHitCallback");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, Hit) == 0x000000, "Member 'DragonIKPhysicsComponent_OnHitCallback::Hit' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, Optional_Override_Hit_Bone_Name) == 0x0000E8, "Member 'DragonIKPhysicsComponent_OnHitCallback::Optional_Override_Hit_Bone_Name' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, hit_location) == 0x0000F0, "Member 'DragonIKPhysicsComponent_OnHitCallback::hit_location' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, hit_impulse_direction) == 0x000108, "Member 'DragonIKPhysicsComponent_OnHitCallback::hit_impulse_direction' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, hit_bone_name) == 0x000120, "Member 'DragonIKPhysicsComponent_OnHitCallback::hit_bone_name' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.PerformActiveRagdoll
// 0x0004 (0x0004 - 0x0000)
struct DragonIKPhysicsComponent_PerformActiveRagdoll final
{
public:
	float                                         pelvis_mass_override;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_PerformActiveRagdoll) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_PerformActiveRagdoll");
static_assert(sizeof(DragonIKPhysicsComponent_PerformActiveRagdoll) == 0x000004, "Wrong size on DragonIKPhysicsComponent_PerformActiveRagdoll");
static_assert(offsetof(DragonIKPhysicsComponent_PerformActiveRagdoll, pelvis_mass_override) == 0x000000, "Member 'DragonIKPhysicsComponent_PerformActiveRagdoll::pelvis_mass_override' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.ReGrabAllHandles
// 0x0001 (0x0001 - 0x0000)
struct DragonIKPhysicsComponent_ReGrabAllHandles final
{
public:
	bool                                          exit_ragdoll;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_ReGrabAllHandles) == 0x000001, "Wrong alignment on DragonIKPhysicsComponent_ReGrabAllHandles");
static_assert(sizeof(DragonIKPhysicsComponent_ReGrabAllHandles) == 0x000001, "Wrong size on DragonIKPhysicsComponent_ReGrabAllHandles");
static_assert(offsetof(DragonIKPhysicsComponent_ReGrabAllHandles, exit_ragdoll) == 0x000000, "Member 'DragonIKPhysicsComponent_ReGrabAllHandles::exit_ragdoll' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.ReleaseAllHandles
// 0x0001 (0x0001 - 0x0000)
struct DragonIKPhysicsComponent_ReleaseAllHandles final
{
public:
	bool                                          go_ragdoll;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_ReleaseAllHandles) == 0x000001, "Wrong alignment on DragonIKPhysicsComponent_ReleaseAllHandles");
static_assert(sizeof(DragonIKPhysicsComponent_ReleaseAllHandles) == 0x000001, "Wrong size on DragonIKPhysicsComponent_ReleaseAllHandles");
static_assert(offsetof(DragonIKPhysicsComponent_ReleaseAllHandles, go_ragdoll) == 0x000000, "Member 'DragonIKPhysicsComponent_ReleaseAllHandles::go_ragdoll' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_Control_Bone_Handle
// 0x0080 (0x0080 - 0x0000)
struct DragonIKPhysicsComponent_Server_Control_Bone_Handle final
{
public:
	class FName                                   bone_name;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             override_transform;                                // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKPhysicsComponent_Server_Control_Bone_Handle) == 0x000010, "Wrong alignment on DragonIKPhysicsComponent_Server_Control_Bone_Handle");
static_assert(sizeof(DragonIKPhysicsComponent_Server_Control_Bone_Handle) == 0x000080, "Wrong size on DragonIKPhysicsComponent_Server_Control_Bone_Handle");
static_assert(offsetof(DragonIKPhysicsComponent_Server_Control_Bone_Handle, bone_name) == 0x000000, "Member 'DragonIKPhysicsComponent_Server_Control_Bone_Handle::bone_name' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Server_Control_Bone_Handle, override_transform) == 0x000010, "Member 'DragonIKPhysicsComponent_Server_Control_Bone_Handle::override_transform' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Server_Control_Bone_Handle, Enable) == 0x000070, "Member 'DragonIKPhysicsComponent_Server_Control_Bone_Handle::Enable' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_DragonIKSimulatePhysics
// 0x0018 (0x0018 - 0x0000)
struct DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics final
{
public:
	class USkeletalMeshComponent*                 SKMesh;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeSelf;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics");
static_assert(sizeof(DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics) == 0x000018, "Wrong size on DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics");
static_assert(offsetof(DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics, SKMesh) == 0x000000, "Member 'DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics::SKMesh' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics, BoneName) == 0x000008, "Member 'DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics::BoneName' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics, IncludeSelf) == 0x000010, "Member 'DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics::IncludeSelf' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_FirstTimeInitialization
// 0x0008 (0x0008 - 0x0000)
struct DragonIKPhysicsComponent_Server_FirstTimeInitialization final
{
public:
	class USkeletalMeshComponent*                 skeleton_input;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Server_FirstTimeInitialization) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_Server_FirstTimeInitialization");
static_assert(sizeof(DragonIKPhysicsComponent_Server_FirstTimeInitialization) == 0x000008, "Wrong size on DragonIKPhysicsComponent_Server_FirstTimeInitialization");
static_assert(offsetof(DragonIKPhysicsComponent_Server_FirstTimeInitialization, skeleton_input) == 0x000000, "Member 'DragonIKPhysicsComponent_Server_FirstTimeInitialization::skeleton_input' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_Modify_Reset_Bone_Info
// 0x0010 (0x0010 - 0x0000)
struct DragonIKPhysicsComponent_Server_Modify_Reset_Bone_Info final
{
public:
	TArray<class FName>                           bone_list;                                         // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Server_Modify_Reset_Bone_Info) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_Server_Modify_Reset_Bone_Info");
static_assert(sizeof(DragonIKPhysicsComponent_Server_Modify_Reset_Bone_Info) == 0x000010, "Wrong size on DragonIKPhysicsComponent_Server_Modify_Reset_Bone_Info");
static_assert(offsetof(DragonIKPhysicsComponent_Server_Modify_Reset_Bone_Info, bone_list) == 0x000000, "Member 'DragonIKPhysicsComponent_Server_Modify_Reset_Bone_Info::bone_list' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_OnHitCallback
// 0x0128 (0x0128 - 0x0000)
struct DragonIKPhysicsComponent_Server_OnHitCallback final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   Optional_Override_Hit_Bone_Name;                   // 0x00E8(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                hit_location;                                      // 0x00F0(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                hit_impulse_direction;                             // 0x0108(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   hit_bone_name;                                     // 0x0120(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Server_OnHitCallback) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_Server_OnHitCallback");
static_assert(sizeof(DragonIKPhysicsComponent_Server_OnHitCallback) == 0x000128, "Wrong size on DragonIKPhysicsComponent_Server_OnHitCallback");
static_assert(offsetof(DragonIKPhysicsComponent_Server_OnHitCallback, Hit) == 0x000000, "Member 'DragonIKPhysicsComponent_Server_OnHitCallback::Hit' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Server_OnHitCallback, Optional_Override_Hit_Bone_Name) == 0x0000E8, "Member 'DragonIKPhysicsComponent_Server_OnHitCallback::Optional_Override_Hit_Bone_Name' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Server_OnHitCallback, hit_location) == 0x0000F0, "Member 'DragonIKPhysicsComponent_Server_OnHitCallback::hit_location' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Server_OnHitCallback, hit_impulse_direction) == 0x000108, "Member 'DragonIKPhysicsComponent_Server_OnHitCallback::hit_impulse_direction' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Server_OnHitCallback, hit_bone_name) == 0x000120, "Member 'DragonIKPhysicsComponent_Server_OnHitCallback::hit_bone_name' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_PerformActiveRagdoll
// 0x0004 (0x0004 - 0x0000)
struct DragonIKPhysicsComponent_Server_PerformActiveRagdoll final
{
public:
	float                                         pelvis_mass_override;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Server_PerformActiveRagdoll) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_Server_PerformActiveRagdoll");
static_assert(sizeof(DragonIKPhysicsComponent_Server_PerformActiveRagdoll) == 0x000004, "Wrong size on DragonIKPhysicsComponent_Server_PerformActiveRagdoll");
static_assert(offsetof(DragonIKPhysicsComponent_Server_PerformActiveRagdoll, pelvis_mass_override) == 0x000000, "Member 'DragonIKPhysicsComponent_Server_PerformActiveRagdoll::pelvis_mass_override' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_ReGrabAllHandles
// 0x0001 (0x0001 - 0x0000)
struct DragonIKPhysicsComponent_Server_ReGrabAllHandles final
{
public:
	bool                                          exit_ragdoll;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Server_ReGrabAllHandles) == 0x000001, "Wrong alignment on DragonIKPhysicsComponent_Server_ReGrabAllHandles");
static_assert(sizeof(DragonIKPhysicsComponent_Server_ReGrabAllHandles) == 0x000001, "Wrong size on DragonIKPhysicsComponent_Server_ReGrabAllHandles");
static_assert(offsetof(DragonIKPhysicsComponent_Server_ReGrabAllHandles, exit_ragdoll) == 0x000000, "Member 'DragonIKPhysicsComponent_Server_ReGrabAllHandles::exit_ragdoll' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_ReleaseAllHandles
// 0x0001 (0x0001 - 0x0000)
struct DragonIKPhysicsComponent_Server_ReleaseAllHandles final
{
public:
	bool                                          go_ragdoll;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Server_ReleaseAllHandles) == 0x000001, "Wrong alignment on DragonIKPhysicsComponent_Server_ReleaseAllHandles");
static_assert(sizeof(DragonIKPhysicsComponent_Server_ReleaseAllHandles) == 0x000001, "Wrong size on DragonIKPhysicsComponent_Server_ReleaseAllHandles");
static_assert(offsetof(DragonIKPhysicsComponent_Server_ReleaseAllHandles, go_ragdoll) == 0x000000, "Member 'DragonIKPhysicsComponent_Server_ReleaseAllHandles::go_ragdoll' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_SetInterpolation
// 0x0004 (0x0004 - 0x0000)
struct DragonIKPhysicsComponent_Server_SetInterpolation final
{
public:
	int32                                         inter_value;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Server_SetInterpolation) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_Server_SetInterpolation");
static_assert(sizeof(DragonIKPhysicsComponent_Server_SetInterpolation) == 0x000004, "Wrong size on DragonIKPhysicsComponent_Server_SetInterpolation");
static_assert(offsetof(DragonIKPhysicsComponent_Server_SetInterpolation, inter_value) == 0x000000, "Member 'DragonIKPhysicsComponent_Server_SetInterpolation::inter_value' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_UpdatePhysanimData
// 0x0010 (0x0010 - 0x0000)
struct DragonIKPhysicsComponent_Server_UpdatePhysanimData final
{
public:
	int32                                         LinearStrength;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularStrength;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LinearDamp;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularDamp;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Server_UpdatePhysanimData) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_Server_UpdatePhysanimData");
static_assert(sizeof(DragonIKPhysicsComponent_Server_UpdatePhysanimData) == 0x000010, "Wrong size on DragonIKPhysicsComponent_Server_UpdatePhysanimData");
static_assert(offsetof(DragonIKPhysicsComponent_Server_UpdatePhysanimData, LinearStrength) == 0x000000, "Member 'DragonIKPhysicsComponent_Server_UpdatePhysanimData::LinearStrength' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Server_UpdatePhysanimData, AngularStrength) == 0x000004, "Member 'DragonIKPhysicsComponent_Server_UpdatePhysanimData::AngularStrength' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Server_UpdatePhysanimData, LinearDamp) == 0x000008, "Member 'DragonIKPhysicsComponent_Server_UpdatePhysanimData::LinearDamp' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Server_UpdatePhysanimData, AngularDamp) == 0x00000C, "Member 'DragonIKPhysicsComponent_Server_UpdatePhysanimData::AngularDamp' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.SetInterpolation
// 0x0004 (0x0004 - 0x0000)
struct DragonIKPhysicsComponent_SetInterpolation final
{
public:
	int32                                         inter_value;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_SetInterpolation) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_SetInterpolation");
static_assert(sizeof(DragonIKPhysicsComponent_SetInterpolation) == 0x000004, "Wrong size on DragonIKPhysicsComponent_SetInterpolation");
static_assert(offsetof(DragonIKPhysicsComponent_SetInterpolation, inter_value) == 0x000000, "Member 'DragonIKPhysicsComponent_SetInterpolation::inter_value' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.UpdatePhysanimData
// 0x0010 (0x0010 - 0x0000)
struct DragonIKPhysicsComponent_UpdatePhysanimData final
{
public:
	int32                                         LinearStrength;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularStrength;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LinearDamp;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularDamp;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_UpdatePhysanimData) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_UpdatePhysanimData");
static_assert(sizeof(DragonIKPhysicsComponent_UpdatePhysanimData) == 0x000010, "Wrong size on DragonIKPhysicsComponent_UpdatePhysanimData");
static_assert(offsetof(DragonIKPhysicsComponent_UpdatePhysanimData, LinearStrength) == 0x000000, "Member 'DragonIKPhysicsComponent_UpdatePhysanimData::LinearStrength' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_UpdatePhysanimData, AngularStrength) == 0x000004, "Member 'DragonIKPhysicsComponent_UpdatePhysanimData::AngularStrength' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_UpdatePhysanimData, LinearDamp) == 0x000008, "Member 'DragonIKPhysicsComponent_UpdatePhysanimData::LinearDamp' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_UpdatePhysanimData, AngularDamp) == 0x00000C, "Member 'DragonIKPhysicsComponent_UpdatePhysanimData::AngularDamp' has a wrong offset!");

// Function DragonIKPlugin.DragonIKTraceManagerComponent.SpineSolverTraceData
// 0x0010 (0x0010 - 0x0000)
struct DragonIKTraceManagerComponent_SpineSolverTraceData final
{
public:
	TArray<struct FDragonIKTraceKeyValuePair>     hit_data_pair;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKTraceManagerComponent_SpineSolverTraceData) == 0x000008, "Wrong alignment on DragonIKTraceManagerComponent_SpineSolverTraceData");
static_assert(sizeof(DragonIKTraceManagerComponent_SpineSolverTraceData) == 0x000010, "Wrong size on DragonIKTraceManagerComponent_SpineSolverTraceData");
static_assert(offsetof(DragonIKTraceManagerComponent_SpineSolverTraceData, hit_data_pair) == 0x000000, "Member 'DragonIKTraceManagerComponent_SpineSolverTraceData::hit_data_pair' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Attach_Hand_Only
// 0x000C (0x000C - 0x0000)
struct DragonIKWeaponPhysicsComponent_Attach_Hand_Only final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          arm_position_recalibrate;                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Attach_Hand_Only) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Attach_Hand_Only");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Attach_Hand_Only) == 0x00000C, "Wrong size on DragonIKWeaponPhysicsComponent_Attach_Hand_Only");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Attach_Hand_Only, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Attach_Hand_Only::hand_bone' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Attach_Hand_Only, arm_position_recalibrate) == 0x000008, "Member 'DragonIKWeaponPhysicsComponent_Attach_Hand_Only::arm_position_recalibrate' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Destroy_Weapon
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Destroy_Weapon final
{
public:
	class AActor*                                 Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Destroy_Weapon) == 0x000008, "Wrong alignment on DragonIKWeaponPhysicsComponent_Destroy_Weapon");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Destroy_Weapon) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Destroy_Weapon");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Destroy_Weapon, Weapon) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Destroy_Weapon::Weapon' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.DisableWeaponsArms
// 0x0001 (0x0001 - 0x0000)
struct DragonIKWeaponPhysicsComponent_DisableWeaponsArms final
{
public:
	bool                                          reset_weapon_transform;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_DisableWeaponsArms) == 0x000001, "Wrong alignment on DragonIKWeaponPhysicsComponent_DisableWeaponsArms");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_DisableWeaponsArms) == 0x000001, "Wrong size on DragonIKWeaponPhysicsComponent_DisableWeaponsArms");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_DisableWeaponsArms, reset_weapon_transform) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_DisableWeaponsArms::reset_weapon_transform' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.FirstTimeInitialization
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_FirstTimeInitialization final
{
public:
	class USkeletalMeshComponent*                 skeleton_input;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_FirstTimeInitialization) == 0x000008, "Wrong alignment on DragonIKWeaponPhysicsComponent_FirstTimeInitialization");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_FirstTimeInitialization) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_FirstTimeInitialization");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_FirstTimeInitialization, skeleton_input) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_FirstTimeInitialization::skeleton_input' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Freeze_Elbows_Function
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function::hand_bone' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Grab_Weapon
// 0x000C (0x000C - 0x0000)
struct DragonIKWeaponPhysicsComponent_Grab_Weapon final
{
public:
	class FName                                   grabbed_bone;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          simulate_physics;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          use_gravity;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Grab_Weapon) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Grab_Weapon");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Grab_Weapon) == 0x00000C, "Wrong size on DragonIKWeaponPhysicsComponent_Grab_Weapon");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Grab_Weapon, grabbed_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Grab_Weapon::grabbed_bone' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Grab_Weapon, simulate_physics) == 0x000008, "Member 'DragonIKWeaponPhysicsComponent_Grab_Weapon::simulate_physics' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Grab_Weapon, use_gravity) == 0x000009, "Member 'DragonIKWeaponPhysicsComponent_Grab_Weapon::use_gravity' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Attach_Hand_Only
// 0x000C (0x000C - 0x0000)
struct DragonIKWeaponPhysicsComponent_Multicast_Attach_Hand_Only final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          arm_position_recalibrate;                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Multicast_Attach_Hand_Only) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Multicast_Attach_Hand_Only");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Multicast_Attach_Hand_Only) == 0x00000C, "Wrong size on DragonIKWeaponPhysicsComponent_Multicast_Attach_Hand_Only");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Attach_Hand_Only, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Attach_Hand_Only::hand_bone' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Attach_Hand_Only, arm_position_recalibrate) == 0x000008, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Attach_Hand_Only::arm_position_recalibrate' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Destroy_Weapon
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Multicast_Destroy_Weapon final
{
public:
	class AActor*                                 Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Multicast_Destroy_Weapon) == 0x000008, "Wrong alignment on DragonIKWeaponPhysicsComponent_Multicast_Destroy_Weapon");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Multicast_Destroy_Weapon) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Multicast_Destroy_Weapon");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Destroy_Weapon, Weapon) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Destroy_Weapon::Weapon' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_DisableWeaponsArms
// 0x0001 (0x0001 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Multicast_DisableWeaponsArms final
{
public:
	bool                                          reset_weapon_transform;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Multicast_DisableWeaponsArms) == 0x000001, "Wrong alignment on DragonIKWeaponPhysicsComponent_Multicast_DisableWeaponsArms");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Multicast_DisableWeaponsArms) == 0x000001, "Wrong size on DragonIKWeaponPhysicsComponent_Multicast_DisableWeaponsArms");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_DisableWeaponsArms, reset_weapon_transform) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Multicast_DisableWeaponsArms::reset_weapon_transform' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_FirstTimeInitialization
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Multicast_FirstTimeInitialization final
{
public:
	class USkeletalMeshComponent*                 skeleton_input;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Multicast_FirstTimeInitialization) == 0x000008, "Wrong alignment on DragonIKWeaponPhysicsComponent_Multicast_FirstTimeInitialization");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Multicast_FirstTimeInitialization) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Multicast_FirstTimeInitialization");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_FirstTimeInitialization, skeleton_input) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Multicast_FirstTimeInitialization::skeleton_input' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Freeze_Elbows_Function
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Multicast_Freeze_Elbows_Function final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Multicast_Freeze_Elbows_Function) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Multicast_Freeze_Elbows_Function");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Multicast_Freeze_Elbows_Function) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Multicast_Freeze_Elbows_Function");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Freeze_Elbows_Function, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Freeze_Elbows_Function::hand_bone' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Grab_Weapon
// 0x000C (0x000C - 0x0000)
struct DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon final
{
public:
	class FName                                   grabbed_bone;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          simulate_physics;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          use_gravity;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon) == 0x00000C, "Wrong size on DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon, grabbed_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon::grabbed_bone' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon, simulate_physics) == 0x000008, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon::simulate_physics' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon, use_gravity) == 0x000009, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon::use_gravity' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Release_Hand_Only
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Only final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Only) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Only");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Only) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Only");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Only, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Only::hand_bone' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Release_Hand_Plus_Override
// 0x0080 (0x0080 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             hand_transform;                                    // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          override_hand_location;                            // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Override_Hand_Rotation;                            // 0x0071(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0xE];                                       // 0x0072(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override) == 0x000010, "Wrong alignment on DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override) == 0x000080, "Wrong size on DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override::hand_bone' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override, hand_transform) == 0x000010, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override::hand_transform' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override, override_hand_location) == 0x000070, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override::override_hand_location' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override, Override_Hand_Rotation) == 0x000071, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override::Override_Hand_Rotation' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Release_Weapon
// 0x0003 (0x0003 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon final
{
public:
	bool                                          should_simulatephysics;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          use_gravity;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeep_Attachment;                                  // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon) == 0x000001, "Wrong alignment on DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon) == 0x000003, "Wrong size on DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon, should_simulatephysics) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon::should_simulatephysics' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon, use_gravity) == 0x000001, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon::use_gravity' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon, bKeep_Attachment) == 0x000002, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon::bKeep_Attachment' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Unfreeze_Elbows_Function
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Multicast_Unfreeze_Elbows_Function final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Multicast_Unfreeze_Elbows_Function) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Multicast_Unfreeze_Elbows_Function");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Multicast_Unfreeze_Elbows_Function) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Multicast_Unfreeze_Elbows_Function");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Unfreeze_Elbows_Function, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Unfreeze_Elbows_Function::hand_bone' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Weapon_Transform_Override
// 0x0070 (0x0070 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Multicast_Weapon_Transform_Override final
{
public:
	struct FTransform                             Weapon_Transform;                                  // 0x0000(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShould_Override_Weapon_Transform;                 // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0xF];                                       // 0x0061(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Multicast_Weapon_Transform_Override) == 0x000010, "Wrong alignment on DragonIKWeaponPhysicsComponent_Multicast_Weapon_Transform_Override");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Multicast_Weapon_Transform_Override) == 0x000070, "Wrong size on DragonIKWeaponPhysicsComponent_Multicast_Weapon_Transform_Override");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Weapon_Transform_Override, Weapon_Transform) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Weapon_Transform_Override::Weapon_Transform' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Multicast_Weapon_Transform_Override, bShould_Override_Weapon_Transform) == 0x000060, "Member 'DragonIKWeaponPhysicsComponent_Multicast_Weapon_Transform_Override::bShould_Override_Weapon_Transform' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Hand_Only
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Release_Hand_Only final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Release_Hand_Only) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Release_Hand_Only");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Release_Hand_Only) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Release_Hand_Only");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Hand_Only, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Release_Hand_Only::hand_bone' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Hand_Plus_Override
// 0x0080 (0x0080 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             hand_transform;                                    // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          override_hand_location;                            // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Override_Hand_Rotation;                            // 0x0071(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0xE];                                       // 0x0072(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override) == 0x000010, "Wrong alignment on DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override) == 0x000080, "Wrong size on DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override::hand_bone' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override, hand_transform) == 0x000010, "Member 'DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override::hand_transform' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override, override_hand_location) == 0x000070, "Member 'DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override::override_hand_location' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override, Override_Hand_Rotation) == 0x000071, "Member 'DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override::Override_Hand_Rotation' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Weapon
// 0x0003 (0x0003 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Release_Weapon final
{
public:
	bool                                          should_simulatephysics;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          use_gravity;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeep_Attachment;                                  // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Release_Weapon) == 0x000001, "Wrong alignment on DragonIKWeaponPhysicsComponent_Release_Weapon");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Release_Weapon) == 0x000003, "Wrong size on DragonIKWeaponPhysicsComponent_Release_Weapon");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Weapon, should_simulatephysics) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Release_Weapon::should_simulatephysics' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Weapon, use_gravity) == 0x000001, "Member 'DragonIKWeaponPhysicsComponent_Release_Weapon::use_gravity' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Weapon, bKeep_Attachment) == 0x000002, "Member 'DragonIKWeaponPhysicsComponent_Release_Weapon::bKeep_Attachment' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Attach_Hand_Only
// 0x000C (0x000C - 0x0000)
struct DragonIKWeaponPhysicsComponent_Server_Attach_Hand_Only final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          arm_position_recalibrate;                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Server_Attach_Hand_Only) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Server_Attach_Hand_Only");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Server_Attach_Hand_Only) == 0x00000C, "Wrong size on DragonIKWeaponPhysicsComponent_Server_Attach_Hand_Only");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Attach_Hand_Only, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Server_Attach_Hand_Only::hand_bone' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Attach_Hand_Only, arm_position_recalibrate) == 0x000008, "Member 'DragonIKWeaponPhysicsComponent_Server_Attach_Hand_Only::arm_position_recalibrate' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Destroy_Weapon
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Server_Destroy_Weapon final
{
public:
	class AActor*                                 Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Server_Destroy_Weapon) == 0x000008, "Wrong alignment on DragonIKWeaponPhysicsComponent_Server_Destroy_Weapon");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Server_Destroy_Weapon) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Server_Destroy_Weapon");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Destroy_Weapon, Weapon) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Server_Destroy_Weapon::Weapon' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_DisableWeaponsArms
// 0x0001 (0x0001 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Server_DisableWeaponsArms final
{
public:
	bool                                          reset_weapon_transform;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Server_DisableWeaponsArms) == 0x000001, "Wrong alignment on DragonIKWeaponPhysicsComponent_Server_DisableWeaponsArms");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Server_DisableWeaponsArms) == 0x000001, "Wrong size on DragonIKWeaponPhysicsComponent_Server_DisableWeaponsArms");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_DisableWeaponsArms, reset_weapon_transform) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Server_DisableWeaponsArms::reset_weapon_transform' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_FirstTimeInitialization
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Server_FirstTimeInitialization final
{
public:
	class USkeletalMeshComponent*                 skeleton_input;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Server_FirstTimeInitialization) == 0x000008, "Wrong alignment on DragonIKWeaponPhysicsComponent_Server_FirstTimeInitialization");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Server_FirstTimeInitialization) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Server_FirstTimeInitialization");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_FirstTimeInitialization, skeleton_input) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Server_FirstTimeInitialization::skeleton_input' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Freeze_Elbows_Function
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Server_Freeze_Elbows_Function final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Server_Freeze_Elbows_Function) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Server_Freeze_Elbows_Function");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Server_Freeze_Elbows_Function) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Server_Freeze_Elbows_Function");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Freeze_Elbows_Function, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Server_Freeze_Elbows_Function::hand_bone' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Grab_Weapon
// 0x000C (0x000C - 0x0000)
struct DragonIKWeaponPhysicsComponent_Server_Grab_Weapon final
{
public:
	class FName                                   grabbed_bone;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          simulate_physics;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          use_gravity;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Server_Grab_Weapon) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Server_Grab_Weapon");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Server_Grab_Weapon) == 0x00000C, "Wrong size on DragonIKWeaponPhysicsComponent_Server_Grab_Weapon");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Grab_Weapon, grabbed_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Server_Grab_Weapon::grabbed_bone' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Grab_Weapon, simulate_physics) == 0x000008, "Member 'DragonIKWeaponPhysicsComponent_Server_Grab_Weapon::simulate_physics' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Grab_Weapon, use_gravity) == 0x000009, "Member 'DragonIKWeaponPhysicsComponent_Server_Grab_Weapon::use_gravity' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Release_Hand_Only
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Server_Release_Hand_Only final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Server_Release_Hand_Only) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Server_Release_Hand_Only");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Server_Release_Hand_Only) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Server_Release_Hand_Only");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Release_Hand_Only, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Server_Release_Hand_Only::hand_bone' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Release_Hand_Plus_Override
// 0x0080 (0x0080 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             hand_transform;                                    // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          override_hand_location;                            // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Override_Hand_Rotation;                            // 0x0071(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0xE];                                       // 0x0072(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override) == 0x000010, "Wrong alignment on DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override) == 0x000080, "Wrong size on DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override::hand_bone' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override, hand_transform) == 0x000010, "Member 'DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override::hand_transform' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override, override_hand_location) == 0x000070, "Member 'DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override::override_hand_location' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override, Override_Hand_Rotation) == 0x000071, "Member 'DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override::Override_Hand_Rotation' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Release_Weapon
// 0x0003 (0x0003 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Server_Release_Weapon final
{
public:
	bool                                          should_simulatephysics;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          use_gravity;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeep_Attachment;                                  // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Server_Release_Weapon) == 0x000001, "Wrong alignment on DragonIKWeaponPhysicsComponent_Server_Release_Weapon");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Server_Release_Weapon) == 0x000003, "Wrong size on DragonIKWeaponPhysicsComponent_Server_Release_Weapon");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Release_Weapon, should_simulatephysics) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Server_Release_Weapon::should_simulatephysics' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Release_Weapon, use_gravity) == 0x000001, "Member 'DragonIKWeaponPhysicsComponent_Server_Release_Weapon::use_gravity' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Release_Weapon, bKeep_Attachment) == 0x000002, "Member 'DragonIKWeaponPhysicsComponent_Server_Release_Weapon::bKeep_Attachment' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Unfreeze_Elbows_Function
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Server_Unfreeze_Elbows_Function final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Server_Unfreeze_Elbows_Function) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Server_Unfreeze_Elbows_Function");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Server_Unfreeze_Elbows_Function) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Server_Unfreeze_Elbows_Function");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Unfreeze_Elbows_Function, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Server_Unfreeze_Elbows_Function::hand_bone' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Weapon_Transform_Override
// 0x0070 (0x0070 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Server_Weapon_Transform_Override final
{
public:
	struct FTransform                             Weapon_Transform;                                  // 0x0000(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShould_Override_Weapon_Transform;                 // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0xF];                                       // 0x0061(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Server_Weapon_Transform_Override) == 0x000010, "Wrong alignment on DragonIKWeaponPhysicsComponent_Server_Weapon_Transform_Override");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Server_Weapon_Transform_Override) == 0x000070, "Wrong size on DragonIKWeaponPhysicsComponent_Server_Weapon_Transform_Override");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Weapon_Transform_Override, Weapon_Transform) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Server_Weapon_Transform_Override::Weapon_Transform' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Server_Weapon_Transform_Override, bShould_Override_Weapon_Transform) == 0x000060, "Member 'DragonIKWeaponPhysicsComponent_Server_Weapon_Transform_Override::bShould_Override_Weapon_Transform' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Unfreeze_Elbows_Function
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function final
{
public:
	class FName                                   hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function, hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function::hand_bone' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Weapon_Transform_Override
// 0x0070 (0x0070 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Weapon_Transform_Override final
{
public:
	struct FTransform                             Weapon_Transform;                                  // 0x0000(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShould_Override_Weapon_Transform;                 // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0xF];                                       // 0x0061(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Weapon_Transform_Override) == 0x000010, "Wrong alignment on DragonIKWeaponPhysicsComponent_Weapon_Transform_Override");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Weapon_Transform_Override) == 0x000070, "Wrong size on DragonIKWeaponPhysicsComponent_Weapon_Transform_Override");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Weapon_Transform_Override, Weapon_Transform) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Weapon_Transform_Override::Weapon_Transform' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Weapon_Transform_Override, bShould_Override_Weapon_Transform) == 0x000060, "Member 'DragonIKWeaponPhysicsComponent_Weapon_Transform_Override::bShould_Override_Weapon_Transform' has a wrong offset!");

// Function DragonIKPlugin.DragonIK_Library.CustomLookRotation
// 0x0048 (0x0048 - 0x0000)
struct DragonIK_Library_CustomLookRotation final
{
public:
	struct FVector                                lookAt;                                            // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                upDirection;                                       // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIK_Library_CustomLookRotation) == 0x000008, "Wrong alignment on DragonIK_Library_CustomLookRotation");
static_assert(sizeof(DragonIK_Library_CustomLookRotation) == 0x000048, "Wrong size on DragonIK_Library_CustomLookRotation");
static_assert(offsetof(DragonIK_Library_CustomLookRotation, lookAt) == 0x000000, "Member 'DragonIK_Library_CustomLookRotation::lookAt' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_CustomLookRotation, upDirection) == 0x000018, "Member 'DragonIK_Library_CustomLookRotation::upDirection' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_CustomLookRotation, ReturnValue) == 0x000030, "Member 'DragonIK_Library_CustomLookRotation::ReturnValue' has a wrong offset!");

// Function DragonIKPlugin.DragonIK_Library.LookAtRotation_V3
// 0x0060 (0x0060 - 0x0000)
struct DragonIK_Library_LookAtRotation_V3 final
{
public:
	struct FVector                                Source;                                            // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpVector;                                          // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0048(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIK_Library_LookAtRotation_V3) == 0x000008, "Wrong alignment on DragonIK_Library_LookAtRotation_V3");
static_assert(sizeof(DragonIK_Library_LookAtRotation_V3) == 0x000060, "Wrong size on DragonIK_Library_LookAtRotation_V3");
static_assert(offsetof(DragonIK_Library_LookAtRotation_V3, Source) == 0x000000, "Member 'DragonIK_Library_LookAtRotation_V3::Source' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtRotation_V3, Target) == 0x000018, "Member 'DragonIK_Library_LookAtRotation_V3::Target' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtRotation_V3, UpVector) == 0x000030, "Member 'DragonIK_Library_LookAtRotation_V3::UpVector' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtRotation_V3, ReturnValue) == 0x000048, "Member 'DragonIK_Library_LookAtRotation_V3::ReturnValue' has a wrong offset!");

// Function DragonIKPlugin.DragonIK_Library.LookAtVector_V2
// 0x0060 (0x0060 - 0x0000)
struct DragonIK_Library_LookAtVector_V2 final
{
public:
	struct FVector                                Source_Location;                                   // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                lookAt;                                            // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                upDirection;                                       // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0048(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIK_Library_LookAtVector_V2) == 0x000008, "Wrong alignment on DragonIK_Library_LookAtVector_V2");
static_assert(sizeof(DragonIK_Library_LookAtVector_V2) == 0x000060, "Wrong size on DragonIK_Library_LookAtVector_V2");
static_assert(offsetof(DragonIK_Library_LookAtVector_V2, Source_Location) == 0x000000, "Member 'DragonIK_Library_LookAtVector_V2::Source_Location' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtVector_V2, lookAt) == 0x000018, "Member 'DragonIK_Library_LookAtVector_V2::lookAt' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtVector_V2, upDirection) == 0x000030, "Member 'DragonIK_Library_LookAtVector_V2::upDirection' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtVector_V2, ReturnValue) == 0x000048, "Member 'DragonIK_Library_LookAtVector_V2::ReturnValue' has a wrong offset!");

// Function DragonIKPlugin.DragonIK_Library.QuatLookXatLocation
// 0x00E0 (0x00E0 - 0x0000)
struct DragonIK_Library_QuatLookXatLocation final
{
public:
	struct FTransform                             LookAtFromTransform;                               // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtTarget;                                      // 0x0060(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0080(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIK_Library_QuatLookXatLocation) == 0x000010, "Wrong alignment on DragonIK_Library_QuatLookXatLocation");
static_assert(sizeof(DragonIK_Library_QuatLookXatLocation) == 0x0000E0, "Wrong size on DragonIK_Library_QuatLookXatLocation");
static_assert(offsetof(DragonIK_Library_QuatLookXatLocation, LookAtFromTransform) == 0x000000, "Member 'DragonIK_Library_QuatLookXatLocation::LookAtFromTransform' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_QuatLookXatLocation, LookAtTarget) == 0x000060, "Member 'DragonIK_Library_QuatLookXatLocation::LookAtTarget' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_QuatLookXatLocation, ReturnValue) == 0x000080, "Member 'DragonIK_Library_QuatLookXatLocation::ReturnValue' has a wrong offset!");

}

