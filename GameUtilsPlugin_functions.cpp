#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameUtilsPlugin

#include "Basic.hpp"

#include "GameUtilsPlugin_classes.hpp"
#include "GameUtilsPlugin_parameters.hpp"


namespace SDK
{

// Function GameUtilsPlugin.GameAuthorityLibrary.IsAuthorityOf
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameAuthorityLibrary::IsAuthorityOf(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameAuthorityLibrary", "IsAuthorityOf");

	Params::GameAuthorityLibrary_IsAuthorityOf Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameAuthorityLibrary.IsClientAuthorityOf
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOrStandalone                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameAuthorityLibrary::IsClientAuthorityOf(class AActor* Actor, bool bOrStandalone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameAuthorityLibrary", "IsClientAuthorityOf");

	Params::GameAuthorityLibrary_IsClientAuthorityOf Parms{};

	Parms.Actor = Actor;
	Parms.bOrStandalone = bOrStandalone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameAuthorityLibrary.IsNoAuthority
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameAuthorityLibrary::IsNoAuthority(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameAuthorityLibrary", "IsNoAuthority");

	Params::GameAuthorityLibrary_IsNoAuthority Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameAuthorityLibrary.IsProxying
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameAuthorityLibrary::IsProxying(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameAuthorityLibrary", "IsProxying");

	Params::GameAuthorityLibrary_IsProxying Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameAuthorityLibrary.IsRunningOnClient
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOrStandalone                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameAuthorityLibrary::IsRunningOnClient(class AActor* Actor, bool bOrStandalone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameAuthorityLibrary", "IsRunningOnClient");

	Params::GameAuthorityLibrary_IsRunningOnClient Parms{};

	Parms.Actor = Actor;
	Parms.bOrStandalone = bOrStandalone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameAuthorityLibrary.IsRunningOnServer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOrStandalone                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameAuthorityLibrary::IsRunningOnServer(class AActor* Actor, bool bOrStandalone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameAuthorityLibrary", "IsRunningOnServer");

	Params::GameAuthorityLibrary_IsRunningOnServer Parms{};

	Parms.Actor = Actor;
	Parms.bOrStandalone = bOrStandalone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameAuthorityLibrary.IsRunningOnStandalone
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameAuthorityLibrary::IsRunningOnStandalone(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameAuthorityLibrary", "IsRunningOnStandalone");

	Params::GameAuthorityLibrary_IsRunningOnStandalone Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameAuthorityLibrary.IsServerAuthorityOf
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameAuthorityLibrary::IsServerAuthorityOf(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameAuthorityLibrary", "IsServerAuthorityOf");

	Params::GameAuthorityLibrary_IsServerAuthorityOf Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameAuthorityLibrary.IsSharedAuthorityOf
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameAuthorityLibrary::IsSharedAuthorityOf(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameAuthorityLibrary", "IsSharedAuthorityOf");

	Params::GameAuthorityLibrary_IsSharedAuthorityOf Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameAuthorityLibrary.IsSharingAuthorityOf
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameAuthorityLibrary::IsSharingAuthorityOf(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameAuthorityLibrary", "IsSharingAuthorityOf");

	Params::GameAuthorityLibrary_IsSharingAuthorityOf Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameAuthorityLibrary.IsSimulating
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameAuthorityLibrary::IsSimulating(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameAuthorityLibrary", "IsSimulating");

	Params::GameAuthorityLibrary_IsSimulating Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameBuildVersionInfo.GetBuildVersionString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameBuildVersionInfo::GetBuildVersionString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBuildVersionInfo", "GetBuildVersionString");

	Params::GameBuildVersionInfo_GetBuildVersionString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameBuildVersionInfo.IsDevVersion
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameBuildVersionInfo::IsDevVersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBuildVersionInfo", "IsDevVersion");

	Params::GameBuildVersionInfo_IsDevVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameBuildVersionInterface.GetVersion
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString IGameBuildVersionInterface::GetVersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBuildVersionInterface", "GetVersion");

	Params::GameBuildVersionInterface_GetVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.AddFlag
// (Final, Native, Static, Public)
// Parameters:
// uint32                                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint32 UGameUtils::AddFlag(uint32 Value, uint32 Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "AddFlag");

	Params::GameUtils_AddFlag Parms{};

	Parms.Value = Value;
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.AddPCGComp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPCGComponent*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPCGComponent* UGameUtils::AddPCGComp(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "AddPCGComp");

	Params::GameUtils_AddPCGComp Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.ComponentTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<EObjectTypeQuery>&         AddIgnoredObjectChannels                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUtils::ComponentTraceSingle(class UPrimitiveComponent* Component, const struct FVector& Start, const struct FVector& End, bool bTraceComplex, const TArray<EObjectTypeQuery>& AddIgnoredObjectChannels, const TArray<class AActor*>& ActorsToIgnore, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "ComponentTraceSingle");

	Params::GameUtils_ComponentTraceSingle Parms{};

	Parms.Component = Component;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.bTraceComplex = bTraceComplex;
	Parms.AddIgnoredObjectChannels = std::move(AddIgnoredObjectChannels);
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bIgnoreSelf = bIgnoreSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.ConeAABBIntersection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   ConeOrigin                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ConeNormal                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHalfAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHeightMin                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHeightMax                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      AxisAlignedBox                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EConeAABBIntersectionResult             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConeAABBIntersectionResult UGameUtils::ConeAABBIntersection(const struct FVector& ConeOrigin, const struct FVector& ConeNormal, float ConeHalfAngle, float ConeHeightMin, float ConeHeightMax, const struct FBox& AxisAlignedBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "ConeAABBIntersection");

	Params::GameUtils_ConeAABBIntersection Parms{};

	Parms.ConeOrigin = std::move(ConeOrigin);
	Parms.ConeNormal = std::move(ConeNormal);
	Parms.ConeHalfAngle = ConeHalfAngle;
	Parms.ConeHeightMin = ConeHeightMin;
	Parms.ConeHeightMax = ConeHeightMax;
	Parms.AxisAlignedBox = std::move(AxisAlignedBox);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.ConeOrientedAABBIntersection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   ConeOrigin                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ConeNormal                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHalfAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHeightMin                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHeightMax                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FQuat&                     BoxOrientation                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConeAABBIntersectionResult             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConeAABBIntersectionResult UGameUtils::ConeOrientedAABBIntersection(const struct FVector& ConeOrigin, const struct FVector& ConeNormal, float ConeHalfAngle, float ConeHeightMin, float ConeHeightMax, const struct FBox& Box, const struct FQuat& BoxOrientation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "ConeOrientedAABBIntersection");

	Params::GameUtils_ConeOrientedAABBIntersection Parms{};

	Parms.ConeOrigin = std::move(ConeOrigin);
	Parms.ConeNormal = std::move(ConeNormal);
	Parms.ConeHalfAngle = ConeHalfAngle;
	Parms.ConeHeightMin = ConeHeightMin;
	Parms.ConeHeightMax = ConeHeightMax;
	Parms.Box = std::move(Box);
	Parms.BoxOrientation = std::move(BoxOrientation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.ConvertStringToGameplayTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    TagString                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UGameUtils::ConvertStringToGameplayTag(const class FString& TagString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "ConvertStringToGameplayTag");

	Params::GameUtils_ConvertStringToGameplayTag Parms{};

	Parms.TagString = std::move(TagString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.DrawDebugRoundedCone
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ConeOrigin                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ConeNormal                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHalfAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHeightMax                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUtils::DrawDebugRoundedCone(const class UObject* WorldContextObject, const struct FVector& ConeOrigin, const struct FVector& ConeNormal, float ConeHalfAngle, float ConeHeightMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "DrawDebugRoundedCone");

	Params::GameUtils_DrawDebugRoundedCone Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ConeOrigin = std::move(ConeOrigin);
	Parms.ConeNormal = std::move(ConeNormal);
	Parms.ConeHalfAngle = ConeHalfAngle;
	Parms.ConeHeightMax = ConeHeightMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameUtilsPlugin.GameUtils.EditorClearPCGLinksKeepActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUtils::EditorClearPCGLinksKeepActor(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "EditorClearPCGLinksKeepActor");

	Params::GameUtils_EditorClearPCGLinksKeepActor Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameUtilsPlugin.GameUtils.EditorGetBoundsFromUObject
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         Origin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         Extents                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUtils::EditorGetBoundsFromUObject(class UObject* Object, struct FVector* Origin, struct FVector* Extents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "EditorGetBoundsFromUObject");

	Params::GameUtils_EditorGetBoundsFromUObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (Extents != nullptr)
		*Extents = std::move(Parms.Extents);
}


// Function GameUtilsPlugin.GameUtils.EditorRegenPCG
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPCGComponent*                    InPCGComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCleanupOnly                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUtils::EditorRegenPCG(class UPCGComponent* InPCGComp, bool bCleanupOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "EditorRegenPCG");

	Params::GameUtils_EditorRegenPCG Parms{};

	Parms.InPCGComp = InPCGComp;
	Parms.bCleanupOnly = bCleanupOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameUtilsPlugin.GameUtils.FindClosestPointOnFiniteLine
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LineStart                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LineEnd                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameUtils::FindClosestPointOnFiniteLine(const struct FVector& Point, const struct FVector& LineStart, const struct FVector& LineEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "FindClosestPointOnFiniteLine");

	Params::GameUtils_FindClosestPointOnFiniteLine Parms{};

	Parms.Point = std::move(Point);
	Parms.LineStart = std::move(LineStart);
	Parms.LineEnd = std::move(LineEnd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.FindComponentSnapLocationNearestToSurface
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SweepCenter                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinSweepDist                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSweepDist                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SweepIncrement                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnorePawn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutComponentSnapLocation                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUtils::FindComponentSnapLocationNearestToSurface(class UWorld* World, class UPrimitiveComponent* Component, const struct FVector& SweepCenter, float MinSweepDist, float MaxSweepDist, float SweepIncrement, bool bIgnorePawn, struct FVector* OutComponentSnapLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "FindComponentSnapLocationNearestToSurface");

	Params::GameUtils_FindComponentSnapLocationNearestToSurface Parms{};

	Parms.World = World;
	Parms.Component = Component;
	Parms.SweepCenter = std::move(SweepCenter);
	Parms.MinSweepDist = MinSweepDist;
	Parms.MaxSweepDist = MaxSweepDist;
	Parms.SweepIncrement = SweepIncrement;
	Parms.bIgnorePawn = bIgnorePawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponentSnapLocation != nullptr)
		*OutComponentSnapLocation = std::move(Parms.OutComponentSnapLocation);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.GetEditorCameraPosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector*                         CameraLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator*                        CameraRotation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGameUtils::GetEditorCameraPosition(struct FVector* CameraLocation, struct FRotator* CameraRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "GetEditorCameraPosition");

	Params::GameUtils_GetEditorCameraPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CameraLocation != nullptr)
		*CameraLocation = std::move(Parms.CameraLocation);

	if (CameraRotation != nullptr)
		*CameraRotation = std::move(Parms.CameraRotation);
}


// Function GameUtilsPlugin.GameUtils.GetIndecesForSortedArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            StringList                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UGameUtils::GetIndecesForSortedArray(const TArray<class FString>& StringList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "GetIndecesForSortedArray");

	Params::GameUtils_GetIndecesForSortedArray Parms{};

	Parms.StringList = std::move(StringList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.GetLookAtTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAoCTargetInfo                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAoCTargetInfo UGameUtils::GetLookAtTarget(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "GetLookAtTarget");

	Params::GameUtils_GetLookAtTarget Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.GetLowestLineTracedGroundImpact
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector*                         Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           TraceStartLocations                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   RayDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUtils::GetLowestLineTracedGroundImpact(struct FVector* Result, class UObject* WorldContextObject, const TArray<struct FVector>& TraceStartLocations, float RayDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "GetLowestLineTracedGroundImpact");

	Params::GameUtils_GetLowestLineTracedGroundImpact Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TraceStartLocations = std::move(TraceStartLocations);
	Parms.RayDistance = RayDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.GetNameHashIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUtils::GetNameHashIndex(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "GetNameHashIndex");

	Params::GameUtils_GetNameHashIndex Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.GetOnlyAlphanumeric
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Dirty                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameUtils::GetOnlyAlphanumeric(const class FString& Dirty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "GetOnlyAlphanumeric");

	Params::GameUtils_GetOnlyAlphanumeric Parms{};

	Parms.Dirty = std::move(Dirty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.GetOrientedBoundingBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        PrimitiveComponent                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox*                            OutBox                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat*                           OutOrientation                                         (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUtils::GetOrientedBoundingBox(const class UPrimitiveComponent* PrimitiveComponent, struct FBox* OutBox, struct FQuat* OutOrientation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "GetOrientedBoundingBox");

	Params::GameUtils_GetOrientedBoundingBox Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBox != nullptr)
		*OutBox = std::move(Parms.OutBox);

	if (OutOrientation != nullptr)
		*OutOrientation = std::move(Parms.OutOrientation);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.GetSystemEnvironmentValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    EnvironmentVariable                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameUtils::GetSystemEnvironmentValue(const class FString& EnvironmentVariable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "GetSystemEnvironmentValue");

	Params::GameUtils_GetSystemEnvironmentValue Parms{};

	Parms.EnvironmentVariable = std::move(EnvironmentVariable);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.GetTargetUnderCursor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsiderPlayer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreHUD                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnorePawns                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowOverlapHits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAoCTargetInfo                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAoCTargetInfo UGameUtils::GetTargetUnderCursor(class APlayerController* PlayerController, bool bConsiderPlayer, bool bIgnoreHUD, bool bIgnorePawns, bool bAllowOverlapHits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "GetTargetUnderCursor");

	Params::GameUtils_GetTargetUnderCursor Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bConsiderPlayer = bConsiderPlayer;
	Parms.bIgnoreHUD = bIgnoreHUD;
	Parms.bIgnorePawns = bIgnorePawns;
	Parms.bAllowOverlapHits = bAllowOverlapHits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.GetTargetUnderReticle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsiderPlayer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnorePawns                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowOverlapHits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAoCTargetInfo                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAoCTargetInfo UGameUtils::GetTargetUnderReticle(class APlayerController* PlayerController, bool bConsiderPlayer, bool bIgnorePawns, bool bAllowOverlapHits, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "GetTargetUnderReticle");

	Params::GameUtils_GetTargetUnderReticle Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bConsiderPlayer = bConsiderPlayer;
	Parms.bIgnorePawns = bIgnorePawns;
	Parms.bAllowOverlapHits = bAllowOverlapHits;
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.HasFlag
// (Final, Native, Static, Public)
// Parameters:
// uint32                                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUtils::HasFlag(uint32 Value, uint32 Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "HasFlag");

	Params::GameUtils_HasFlag Parms{};

	Parms.Value = Value;
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.IsWithEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUtils::IsWithEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "IsWithEditor");

	Params::GameUtils_IsWithEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.LineTraceSingleByObjectType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectTypeQuery                        ObjectChannel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<EObjectTypeQuery>&         IgnoredObjectChannels                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUtils::LineTraceSingleByObjectType(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, EObjectTypeQuery ObjectChannel, bool bTraceComplex, const TArray<EObjectTypeQuery>& IgnoredObjectChannels, const TArray<class AActor*>& ActorsToIgnore, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "LineTraceSingleByObjectType");

	Params::GameUtils_LineTraceSingleByObjectType Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.ObjectChannel = ObjectChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.IgnoredObjectChannels = std::move(IgnoredObjectChannels);
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.LineTraceSingleByTraceType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<EObjectTypeQuery>&         IgnoredObjectChannels                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUtils::LineTraceSingleByTraceType(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<EObjectTypeQuery>& IgnoredObjectChannels, const TArray<class AActor*>& ActorsToIgnore, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "LineTraceSingleByTraceType");

	Params::GameUtils_LineTraceSingleByTraceType Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.IgnoredObjectChannels = std::move(IgnoredObjectChannels);
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.MoveFloor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUtils::MoveFloor(class UPrimitiveComponent* Component, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "MoveFloor");

	Params::GameUtils_MoveFloor Parms{};

	Parms.Component = Component;
	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameUtilsPlugin.GameUtils.PreDestroyFloor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUtils::PreDestroyFloor(class UPrimitiveComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "PreDestroyFloor");

	Params::GameUtils_PreDestroyFloor Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameUtilsPlugin.GameUtils.PrepLevelInstanceForPCG
// (Final, Native, Static, Public, BlueprintCallable)

void UGameUtils::PrepLevelInstanceForPCG()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "PrepLevelInstanceForPCG");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameUtilsPlugin.GameUtils.RemoveFlag
// (Final, Native, Static, Public)
// Parameters:
// uint32                                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint32 UGameUtils::RemoveFlag(uint32 Value, uint32 Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "RemoveFlag");

	Params::GameUtils_RemoveFlag Parms{};

	Parms.Value = Value;
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.ResetGeometryCollectionPhysics
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGeometryCollectionComponent*     GeometryCollection                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUtils::ResetGeometryCollectionPhysics(class UGeometryCollectionComponent* GeometryCollection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "ResetGeometryCollectionPhysics");

	Params::GameUtils_ResetGeometryCollectionPhysics Parms{};

	Parms.GeometryCollection = GeometryCollection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameUtilsPlugin.GameUtils.RoundedConeOrientedAABBIntersection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   ConeOrigin                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ConeNormal                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHalfAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHeightMin                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHeightMax                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FQuat&                     BoxOrientation                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDebugDraw                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConeAABBIntersectionResult             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConeAABBIntersectionResult UGameUtils::RoundedConeOrientedAABBIntersection(const struct FVector& ConeOrigin, const struct FVector& ConeNormal, float ConeHalfAngle, float ConeHeightMin, float ConeHeightMax, const struct FBox& Box, const struct FQuat& BoxOrientation, bool bDebugDraw, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "RoundedConeOrientedAABBIntersection");

	Params::GameUtils_RoundedConeOrientedAABBIntersection Parms{};

	Parms.ConeOrigin = std::move(ConeOrigin);
	Parms.ConeNormal = std::move(ConeNormal);
	Parms.ConeHalfAngle = ConeHalfAngle;
	Parms.ConeHeightMin = ConeHeightMin;
	Parms.ConeHeightMax = ConeHeightMax;
	Parms.Box = std::move(Box);
	Parms.BoxOrientation = std::move(BoxOrientation);
	Parms.bDebugDraw = bDebugDraw;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.SaveTextToFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FileContent                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUtils::SaveTextToFile(const class FString& FilePath, const class FString& Filename, const class FString& FileContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "SaveTextToFile");

	Params::GameUtils_SaveTextToFile Parms{};

	Parms.FilePath = std::move(FilePath);
	Parms.Filename = std::move(Filename);
	Parms.FileContent = std::move(FileContent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.SetActorOutline
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUtils::SetActorOutline(class AActor* InActor, bool bOn, int32 InColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "SetActorOutline");

	Params::GameUtils_SetActorOutline Parms{};

	Parms.InActor = InActor;
	Parms.bOn = bOn;
	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameUtilsPlugin.GameUtils.ShiftArrayIndexCircular
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   iRaw                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Shift                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ArrayLength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUtils::ShiftArrayIndexCircular(int32 iRaw, int32 Shift, int32 ArrayLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "ShiftArrayIndexCircular");

	Params::GameUtils_ShiftArrayIndexCircular Parms{};

	Parms.iRaw = iRaw;
	Parms.Shift = Shift;
	Parms.ArrayLength = ArrayLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.SnapComponentToNearestSurface
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinSweepDist                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSweepDist                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SweepIncrement                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnorePawn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUtils::SnapComponentToNearestSurface(class UPrimitiveComponent* Component, float MinSweepDist, float MaxSweepDist, float SweepIncrement, bool bIgnorePawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "SnapComponentToNearestSurface");

	Params::GameUtils_SnapComponentToNearestSurface Parms{};

	Parms.Component = Component;
	Parms.MinSweepDist = MinSweepDist;
	Parms.MaxSweepDist = MaxSweepDist;
	Parms.SweepIncrement = SweepIncrement;
	Parms.bIgnorePawn = bIgnorePawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.SphereOrientedAABBIntersection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   SphereCenter                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             RadiusSquared                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FQuat&                     BoxOrientation                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUtils::SphereOrientedAABBIntersection(const struct FVector& SphereCenter, const float RadiusSquared, const struct FBox& Box, const struct FQuat& BoxOrientation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "SphereOrientedAABBIntersection");

	Params::GameUtils_SphereOrientedAABBIntersection Parms{};

	Parms.SphereCenter = std::move(SphereCenter);
	Parms.RadiusSquared = RadiusSquared;
	Parms.Box = std::move(Box);
	Parms.BoxOrientation = std::move(BoxOrientation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.GameUtils.TryGetFloatCurveValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UAnimMontage*               Montage                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       CurveName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUtils::TryGetFloatCurveValue(const class UAnimMontage* Montage, const class FName CurveName, float Time, float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameUtils", "TryGetFloatCurveValue");

	Params::GameUtils_TryGetFloatCurveValue Parms{};

	Parms.Montage = Montage;
	Parms.CurveName = CurveName;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.InfiniteLoopMonitorLibrary.CreateInfiniteLoopFileMonitor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    CrashFilePath                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CheckFrequencyMs                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInfiniteLoopMonitor*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInfiniteLoopMonitor* UInfiniteLoopMonitorLibrary::CreateInfiniteLoopFileMonitor(class FName Name_0, const class FString& CrashFilePath, int32 CheckFrequencyMs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InfiniteLoopMonitorLibrary", "CreateInfiniteLoopFileMonitor");

	Params::InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor Parms{};

	Parms.Name_0 = Name_0;
	Parms.CrashFilePath = std::move(CrashFilePath);
	Parms.CheckFrequencyMs = CheckFrequencyMs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.InfiniteLoopMonitorLibrary.CreateInfiniteLoopHeartbeatMonitor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HeartbeatTimeoutMs                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CheckFrequencyMs                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInfiniteLoopMonitor*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInfiniteLoopMonitor* UInfiniteLoopMonitorLibrary::CreateInfiniteLoopHeartbeatMonitor(class FName Name_0, int32 HeartbeatTimeoutMs, int32 CheckFrequencyMs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InfiniteLoopMonitorLibrary", "CreateInfiniteLoopHeartbeatMonitor");

	Params::InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor Parms{};

	Parms.Name_0 = Name_0;
	Parms.HeartbeatTimeoutMs = HeartbeatTimeoutMs;
	Parms.CheckFrequencyMs = CheckFrequencyMs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.InfiniteLoopMonitorLibrary.RemoveInfiniteLoopMonitorByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInfiniteLoopMonitorLibrary::RemoveInfiniteLoopMonitorByName(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InfiniteLoopMonitorLibrary", "RemoveInfiniteLoopMonitorByName");

	Params::InfiniteLoopMonitorLibrary_RemoveInfiniteLoopMonitorByName Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameUtilsPlugin.InfiniteLoopMonitor.Start
// (Final, Native, Public, BlueprintCallable)

void UInfiniteLoopMonitor::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfiniteLoopMonitor", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameUtilsPlugin.InfiniteLoopMonitor.Stop
// (Final, Native, Public, BlueprintCallable)

void UInfiniteLoopMonitor::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfiniteLoopMonitor", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameUtilsPlugin.InfiniteLoopMonitor.Pulse
// (Final, Native, Public, BlueprintCallable, Const)

void UInfiniteLoopMonitor::Pulse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfiniteLoopMonitor", "Pulse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameUtilsPlugin.MathUtils.InverseLerp2DClamped
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FBox2D&                    Range                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector2D&                 Input                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UMathUtils::InverseLerp2DClamped(const struct FBox2D& Range, const struct FVector2D& Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MathUtils", "InverseLerp2DClamped");

	Params::MathUtils_InverseLerp2DClamped Parms{};

	Parms.Range = std::move(Range);
	Parms.Input = std::move(Input);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.MathUtils.InverseLerp2DUnclamped
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FBox2D&                    Range                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector2D&                 Input                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UMathUtils::InverseLerp2DUnclamped(const struct FBox2D& Range, const struct FVector2D& Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MathUtils", "InverseLerp2DUnclamped");

	Params::MathUtils_InverseLerp2DUnclamped Parms{};

	Parms.Range = std::move(Range);
	Parms.Input = std::move(Input);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.MeshUtils.GetSkeletalMeshVerts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>*                 OutVertices                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EVertexRenderType                       OutpuType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stride                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SpecificLodIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshUtils::GetSkeletalMeshVerts(TArray<struct FVector>* OutVertices, EVertexRenderType OutpuType, class USkeletalMeshComponent* InComponent, int32 Stride, int32 SpecificLodIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshUtils", "GetSkeletalMeshVerts");

	Params::MeshUtils_GetSkeletalMeshVerts Parms{};

	Parms.OutpuType = OutpuType;
	Parms.InComponent = InComponent;
	Parms.Stride = Stride;
	Parms.SpecificLodIndex = SpecificLodIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVertices != nullptr)
		*OutVertices = std::move(Parms.OutVertices);
}


// Function GameUtilsPlugin.MeshUtils.GetStaticMeshVerts
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVector>*                 OutVertices                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EVertexRenderType                       OutpuType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InWorldLoc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                InLocalTransform                                       (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stride                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SpecificLodIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshUtils::GetStaticMeshVerts(TArray<struct FVector>* OutVertices, EVertexRenderType OutpuType, class UStaticMeshComponent* InMesh, const struct FVector& InWorldLoc, const struct FTransform& InLocalTransform, int32 Stride, int32 SpecificLodIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshUtils", "GetStaticMeshVerts");

	Params::MeshUtils_GetStaticMeshVerts Parms{};

	Parms.OutpuType = OutpuType;
	Parms.InMesh = InMesh;
	Parms.InWorldLoc = std::move(InWorldLoc);
	Parms.InLocalTransform = std::move(InLocalTransform);
	Parms.Stride = Stride;
	Parms.SpecificLodIndex = SpecificLodIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVertices != nullptr)
		*OutVertices = std::move(Parms.OutVertices);
}


// Function GameUtilsPlugin.OctreeUtil.FindFirstInBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Extents                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UOctreeUtil::FindFirstInBox(struct FOctree& Octree, const struct FTransform& Transform, const struct FVector& Extents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "FindFirstInBox");

	Params::OctreeUtil_FindFirstInBox Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Transform = std::move(Transform);
	Parms.Extents = std::move(Extents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.OctreeUtil.FindFirstInCapsule
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UOctreeUtil::FindFirstInCapsule(struct FOctree& Octree, const struct FTransform& Transform, float Radius, float HalfHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "FindFirstInCapsule");

	Params::OctreeUtil_FindFirstInCapsule Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Transform = std::move(Transform);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.OctreeUtil.FindFirstInSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UOctreeUtil::FindFirstInSphere(struct FOctree& Octree, const struct FTransform& Transform, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "FindFirstInSphere");

	Params::OctreeUtil_FindFirstInSphere Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Transform = std::move(Transform);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.OctreeUtil.FollowMovements
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOctreeUtil::FollowMovements(struct FOctree& Octree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "FollowMovements");

	Params::OctreeUtil_FollowMovements Parms{};

	Parms.Octree = std::move(Octree);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);
}


// Function GameUtilsPlugin.OctreeUtil.GetAllInBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Extents                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>*                 Results                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOctreeUtil::GetAllInBox(struct FOctree& Octree, const struct FTransform& Transform, const struct FVector& Extents, TArray<class UObject*>* Results)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "GetAllInBox");

	Params::OctreeUtil_GetAllInBox Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Transform = std::move(Transform);
	Parms.Extents = std::move(Extents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function GameUtilsPlugin.OctreeUtil.GetAllInCapsule
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>*                 Results                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOctreeUtil::GetAllInCapsule(struct FOctree& Octree, const struct FTransform& Transform, float Radius, float HalfHeight, TArray<class UObject*>* Results)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "GetAllInCapsule");

	Params::OctreeUtil_GetAllInCapsule Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Transform = std::move(Transform);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function GameUtilsPlugin.OctreeUtil.GetAllInSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>*                 Results                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOctreeUtil::GetAllInSphere(struct FOctree& Octree, const struct FTransform& Transform, float Radius, TArray<class UObject*>* Results)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "GetAllInSphere");

	Params::OctreeUtil_GetAllInSphere Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Transform = std::move(Transform);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function GameUtilsPlugin.OctreeUtil.InsertActorWithBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Extents                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    followMovement                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOctreeUtil::InsertActorWithBox(struct FOctree& Octree, class AActor* Actor, const struct FVector& Extents, bool followMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "InsertActorWithBox");

	Params::OctreeUtil_InsertActorWithBox Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Actor = Actor;
	Parms.Extents = std::move(Extents);
	Parms.followMovement = followMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.OctreeUtil.InsertActorWithCapsule
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    followMovement                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOctreeUtil::InsertActorWithCapsule(struct FOctree& Octree, class AActor* Actor, float Radius, float HalfHeight, bool followMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "InsertActorWithCapsule");

	Params::OctreeUtil_InsertActorWithCapsule Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Actor = Actor;
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.followMovement = followMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.OctreeUtil.InsertActorWithSphere
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    followMovement                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOctreeUtil::InsertActorWithSphere(struct FOctree& Octree, class AActor* Actor, float Radius, bool followMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "InsertActorWithSphere");

	Params::OctreeUtil_InsertActorWithSphere Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Actor = Actor;
	Parms.Radius = Radius;
	Parms.followMovement = followMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.OctreeUtil.InsertBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Extents                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOctreeUtil::InsertBox(struct FOctree& Octree, const struct FTransform& Transform, const struct FVector& Extents, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "InsertBox");

	Params::OctreeUtil_InsertBox Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Transform = std::move(Transform);
	Parms.Extents = std::move(Extents);
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.OctreeUtil.InsertCapsule
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOctreeUtil::InsertCapsule(struct FOctree& Octree, const struct FTransform& Transform, float Radius, float HalfHeight, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "InsertCapsule");

	Params::OctreeUtil_InsertCapsule Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Transform = std::move(Transform);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.OctreeUtil.InsertCharacter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    followMovement                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOctreeUtil::InsertCharacter(struct FOctree& Octree, class ACharacter* Character, bool followMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "InsertCharacter");

	Params::OctreeUtil_InsertCharacter Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Character = Character;
	Parms.followMovement = followMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.OctreeUtil.InsertPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOctreeUtil::InsertPoint(struct FOctree& Octree, const struct FVector& Point, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "InsertPoint");

	Params::OctreeUtil_InsertPoint Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Point = std::move(Point);
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.OctreeUtil.InsertSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOctreeUtil::InsertSphere(struct FOctree& Octree, const struct FTransform& Transform, float Radius, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "InsertSphere");

	Params::OctreeUtil_InsertSphere Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Transform = std::move(Transform);
	Parms.Radius = Radius;
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);

	return Parms.ReturnValue;
}


// Function GameUtilsPlugin.OctreeUtil.Move
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOctreeUtil::Move(struct FOctree& Octree, const struct FTransform& Transform, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "Move");

	Params::OctreeUtil_Move Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Transform = std::move(Transform);
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);
}


// Function GameUtilsPlugin.OctreeUtil.Remove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOctreeUtil::Remove(struct FOctree& Octree, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "Remove");

	Params::OctreeUtil_Remove Parms{};

	Parms.Octree = std::move(Octree);
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);
}


// Function GameUtilsPlugin.OctreeUtil.RemoveAll
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOctree&                         Octree                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOctreeUtil::RemoveAll(struct FOctree& Octree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OctreeUtil", "RemoveAll");

	Params::OctreeUtil_RemoveAll Parms{};

	Parms.Octree = std::move(Octree);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Octree = std::move(Parms.Octree);
}

}

