#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AkAudio

#include "Basic.hpp"

#include "AkAudio_structs.hpp"
#include "Engine_structs.hpp"
#include "WwiseObjectUtils_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK::Params
{

// Function AkAudio.AkGameObject.PostAkEvent
// 0x0020 (0x0020 - 0x0000)
struct AkGameObject_PostAkEvent final
{
public:
	class UAkAudioEvent*                          AkEvent;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallbackMask;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> PostEventCallback;                                 // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameObject_PostAkEvent) == 0x000008, "Wrong alignment on AkGameObject_PostAkEvent");
static_assert(sizeof(AkGameObject_PostAkEvent) == 0x000020, "Wrong size on AkGameObject_PostAkEvent");
static_assert(offsetof(AkGameObject_PostAkEvent, AkEvent) == 0x000000, "Member 'AkGameObject_PostAkEvent::AkEvent' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAkEvent, CallbackMask) == 0x000008, "Member 'AkGameObject_PostAkEvent::CallbackMask' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAkEvent, PostEventCallback) == 0x00000C, "Member 'AkGameObject_PostAkEvent::PostEventCallback' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAkEvent, ReturnValue) == 0x00001C, "Member 'AkGameObject_PostAkEvent::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameObject.PostAkEventAsync
// 0x0040 (0x0040 - 0x0000)
struct AkGameObject_PostAkEventAsync final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayingID;                                         // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallbackMask;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> PostEventCallback;                                 // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0028(0x0018)(Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameObject_PostAkEventAsync) == 0x000008, "Wrong alignment on AkGameObject_PostAkEventAsync");
static_assert(sizeof(AkGameObject_PostAkEventAsync) == 0x000040, "Wrong size on AkGameObject_PostAkEventAsync");
static_assert(offsetof(AkGameObject_PostAkEventAsync, WorldContextObject) == 0x000000, "Member 'AkGameObject_PostAkEventAsync::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAkEventAsync, AkEvent) == 0x000008, "Member 'AkGameObject_PostAkEventAsync::AkEvent' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAkEventAsync, PlayingID) == 0x000010, "Member 'AkGameObject_PostAkEventAsync::PlayingID' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAkEventAsync, CallbackMask) == 0x000014, "Member 'AkGameObject_PostAkEventAsync::CallbackMask' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAkEventAsync, PostEventCallback) == 0x000018, "Member 'AkGameObject_PostAkEventAsync::PostEventCallback' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAkEventAsync, LatentInfo) == 0x000028, "Member 'AkGameObject_PostAkEventAsync::LatentInfo' has a wrong offset!");

// Function AkAudio.AkGameObject.PostAssociatedAkEvent
// 0x0018 (0x0018 - 0x0000)
struct AkGameObject_PostAssociatedAkEvent final
{
public:
	int32                                         CallbackMask;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> PostEventCallback;                                 // 0x0004(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameObject_PostAssociatedAkEvent) == 0x000004, "Wrong alignment on AkGameObject_PostAssociatedAkEvent");
static_assert(sizeof(AkGameObject_PostAssociatedAkEvent) == 0x000018, "Wrong size on AkGameObject_PostAssociatedAkEvent");
static_assert(offsetof(AkGameObject_PostAssociatedAkEvent, CallbackMask) == 0x000000, "Member 'AkGameObject_PostAssociatedAkEvent::CallbackMask' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAssociatedAkEvent, PostEventCallback) == 0x000004, "Member 'AkGameObject_PostAssociatedAkEvent::PostEventCallback' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAssociatedAkEvent, ReturnValue) == 0x000014, "Member 'AkGameObject_PostAssociatedAkEvent::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameObject.PostAssociatedAkEventAsync
// 0x0040 (0x0040 - 0x0000)
struct AkGameObject_PostAssociatedAkEventAsync final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallbackMask;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> PostEventCallback;                                 // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0020(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         PlayingID;                                         // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameObject_PostAssociatedAkEventAsync) == 0x000008, "Wrong alignment on AkGameObject_PostAssociatedAkEventAsync");
static_assert(sizeof(AkGameObject_PostAssociatedAkEventAsync) == 0x000040, "Wrong size on AkGameObject_PostAssociatedAkEventAsync");
static_assert(offsetof(AkGameObject_PostAssociatedAkEventAsync, WorldContextObject) == 0x000000, "Member 'AkGameObject_PostAssociatedAkEventAsync::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAssociatedAkEventAsync, CallbackMask) == 0x000008, "Member 'AkGameObject_PostAssociatedAkEventAsync::CallbackMask' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAssociatedAkEventAsync, PostEventCallback) == 0x00000C, "Member 'AkGameObject_PostAssociatedAkEventAsync::PostEventCallback' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAssociatedAkEventAsync, LatentInfo) == 0x000020, "Member 'AkGameObject_PostAssociatedAkEventAsync::LatentInfo' has a wrong offset!");
static_assert(offsetof(AkGameObject_PostAssociatedAkEventAsync, PlayingID) == 0x000038, "Member 'AkGameObject_PostAssociatedAkEventAsync::PlayingID' has a wrong offset!");

// Function AkAudio.AkGameObject.SetAttenuationScalingFactor
// 0x0004 (0x0004 - 0x0000)
struct AkGameObject_SetAttenuationScalingFactor final
{
public:
	float                                         InAttenuationScalingFactor;                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameObject_SetAttenuationScalingFactor) == 0x000004, "Wrong alignment on AkGameObject_SetAttenuationScalingFactor");
static_assert(sizeof(AkGameObject_SetAttenuationScalingFactor) == 0x000004, "Wrong size on AkGameObject_SetAttenuationScalingFactor");
static_assert(offsetof(AkGameObject_SetAttenuationScalingFactor, InAttenuationScalingFactor) == 0x000000, "Member 'AkGameObject_SetAttenuationScalingFactor::InAttenuationScalingFactor' has a wrong offset!");

// Function AkAudio.AkGameObject.GetAttenuationScalingFactor
// 0x0004 (0x0004 - 0x0000)
struct AkGameObject_GetAttenuationScalingFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameObject_GetAttenuationScalingFactor) == 0x000004, "Wrong alignment on AkGameObject_GetAttenuationScalingFactor");
static_assert(sizeof(AkGameObject_GetAttenuationScalingFactor) == 0x000004, "Wrong size on AkGameObject_GetAttenuationScalingFactor");
static_assert(offsetof(AkGameObject_GetAttenuationScalingFactor, ReturnValue) == 0x000000, "Member 'AkGameObject_GetAttenuationScalingFactor::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameObject.GetRTPCValue
// 0x0030 (0x0030 - 0x0000)
struct AkGameObject_GetRTPCValue final
{
public:
	class UAkRtpc*                                RTPCValue;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERTPCValueType                                InputValueType;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERTPCValueType                                OutputValueType;                                   // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RTPC;                                              // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayingID;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameObject_GetRTPCValue) == 0x000008, "Wrong alignment on AkGameObject_GetRTPCValue");
static_assert(sizeof(AkGameObject_GetRTPCValue) == 0x000030, "Wrong size on AkGameObject_GetRTPCValue");
static_assert(offsetof(AkGameObject_GetRTPCValue, RTPCValue) == 0x000000, "Member 'AkGameObject_GetRTPCValue::RTPCValue' has a wrong offset!");
static_assert(offsetof(AkGameObject_GetRTPCValue, InputValueType) == 0x000008, "Member 'AkGameObject_GetRTPCValue::InputValueType' has a wrong offset!");
static_assert(offsetof(AkGameObject_GetRTPCValue, Value) == 0x00000C, "Member 'AkGameObject_GetRTPCValue::Value' has a wrong offset!");
static_assert(offsetof(AkGameObject_GetRTPCValue, OutputValueType) == 0x000010, "Member 'AkGameObject_GetRTPCValue::OutputValueType' has a wrong offset!");
static_assert(offsetof(AkGameObject_GetRTPCValue, RTPC) == 0x000018, "Member 'AkGameObject_GetRTPCValue::RTPC' has a wrong offset!");
static_assert(offsetof(AkGameObject_GetRTPCValue, PlayingID) == 0x000028, "Member 'AkGameObject_GetRTPCValue::PlayingID' has a wrong offset!");

// Function AkAudio.AkGameObject.SetRTPCValue
// 0x0020 (0x0020 - 0x0000)
struct AkGameObject_SetRTPCValue final
{
public:
	class UAkRtpc*                                RTPCValue;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterpolationTimeMs;                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RTPC;                                              // 0x0010(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameObject_SetRTPCValue) == 0x000008, "Wrong alignment on AkGameObject_SetRTPCValue");
static_assert(sizeof(AkGameObject_SetRTPCValue) == 0x000020, "Wrong size on AkGameObject_SetRTPCValue");
static_assert(offsetof(AkGameObject_SetRTPCValue, RTPCValue) == 0x000000, "Member 'AkGameObject_SetRTPCValue::RTPCValue' has a wrong offset!");
static_assert(offsetof(AkGameObject_SetRTPCValue, Value) == 0x000008, "Member 'AkGameObject_SetRTPCValue::Value' has a wrong offset!");
static_assert(offsetof(AkGameObject_SetRTPCValue, InterpolationTimeMs) == 0x00000C, "Member 'AkGameObject_SetRTPCValue::InterpolationTimeMs' has a wrong offset!");
static_assert(offsetof(AkGameObject_SetRTPCValue, RTPC) == 0x000010, "Member 'AkGameObject_SetRTPCValue::RTPC' has a wrong offset!");

// Function AkAudio.AkRoomComponent.SetAuxSendLevel
// 0x0004 (0x0004 - 0x0000)
struct AkRoomComponent_SetAuxSendLevel final
{
public:
	float                                         InAuxSendLevel;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkRoomComponent_SetAuxSendLevel) == 0x000004, "Wrong alignment on AkRoomComponent_SetAuxSendLevel");
static_assert(sizeof(AkRoomComponent_SetAuxSendLevel) == 0x000004, "Wrong size on AkRoomComponent_SetAuxSendLevel");
static_assert(offsetof(AkRoomComponent_SetAuxSendLevel, InAuxSendLevel) == 0x000000, "Member 'AkRoomComponent_SetAuxSendLevel::InAuxSendLevel' has a wrong offset!");

// Function AkAudio.AkRoomComponent.SetDynamic
// 0x0001 (0x0001 - 0x0000)
struct AkRoomComponent_SetDynamic final
{
public:
	bool                                          bInDynamic;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkRoomComponent_SetDynamic) == 0x000001, "Wrong alignment on AkRoomComponent_SetDynamic");
static_assert(sizeof(AkRoomComponent_SetDynamic) == 0x000001, "Wrong size on AkRoomComponent_SetDynamic");
static_assert(offsetof(AkRoomComponent_SetDynamic, bInDynamic) == 0x000000, "Member 'AkRoomComponent_SetDynamic::bInDynamic' has a wrong offset!");

// Function AkAudio.AkRoomComponent.SetEnable
// 0x0001 (0x0001 - 0x0000)
struct AkRoomComponent_SetEnable final
{
public:
	bool                                          bInEnable;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkRoomComponent_SetEnable) == 0x000001, "Wrong alignment on AkRoomComponent_SetEnable");
static_assert(sizeof(AkRoomComponent_SetEnable) == 0x000001, "Wrong size on AkRoomComponent_SetEnable");
static_assert(offsetof(AkRoomComponent_SetEnable, bInEnable) == 0x000000, "Member 'AkRoomComponent_SetEnable::bInEnable' has a wrong offset!");

// Function AkAudio.AkRoomComponent.SetEnableReverbZone
// 0x0001 (0x0001 - 0x0000)
struct AkRoomComponent_SetEnableReverbZone final
{
public:
	bool                                          bInEnableReverbZone;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkRoomComponent_SetEnableReverbZone) == 0x000001, "Wrong alignment on AkRoomComponent_SetEnableReverbZone");
static_assert(sizeof(AkRoomComponent_SetEnableReverbZone) == 0x000001, "Wrong size on AkRoomComponent_SetEnableReverbZone");
static_assert(offsetof(AkRoomComponent_SetEnableReverbZone, bInEnableReverbZone) == 0x000000, "Member 'AkRoomComponent_SetEnableReverbZone::bInEnableReverbZone' has a wrong offset!");

// Function AkAudio.AkRoomComponent.SetGeometryComponent
// 0x0008 (0x0008 - 0x0000)
struct AkRoomComponent_SetGeometryComponent final
{
public:
	class UAkAcousticTextureSetComponent*         textureSetComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkRoomComponent_SetGeometryComponent) == 0x000008, "Wrong alignment on AkRoomComponent_SetGeometryComponent");
static_assert(sizeof(AkRoomComponent_SetGeometryComponent) == 0x000008, "Wrong size on AkRoomComponent_SetGeometryComponent");
static_assert(offsetof(AkRoomComponent_SetGeometryComponent, textureSetComponent) == 0x000000, "Member 'AkRoomComponent_SetGeometryComponent::textureSetComponent' has a wrong offset!");

// Function AkAudio.AkRoomComponent.SetReverbZone
// 0x0010 (0x0010 - 0x0000)
struct AkRoomComponent_SetReverbZone final
{
public:
	const class UAkRoomComponent*                 InParentRoom;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTransitionRegionWidth;                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkRoomComponent_SetReverbZone) == 0x000008, "Wrong alignment on AkRoomComponent_SetReverbZone");
static_assert(sizeof(AkRoomComponent_SetReverbZone) == 0x000010, "Wrong size on AkRoomComponent_SetReverbZone");
static_assert(offsetof(AkRoomComponent_SetReverbZone, InParentRoom) == 0x000000, "Member 'AkRoomComponent_SetReverbZone::InParentRoom' has a wrong offset!");
static_assert(offsetof(AkRoomComponent_SetReverbZone, InTransitionRegionWidth) == 0x000008, "Member 'AkRoomComponent_SetReverbZone::InTransitionRegionWidth' has a wrong offset!");

// Function AkAudio.AkRoomComponent.SetTransmissionLoss
// 0x0004 (0x0004 - 0x0000)
struct AkRoomComponent_SetTransmissionLoss final
{
public:
	float                                         InTransmissionLoss;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkRoomComponent_SetTransmissionLoss) == 0x000004, "Wrong alignment on AkRoomComponent_SetTransmissionLoss");
static_assert(sizeof(AkRoomComponent_SetTransmissionLoss) == 0x000004, "Wrong size on AkRoomComponent_SetTransmissionLoss");
static_assert(offsetof(AkRoomComponent_SetTransmissionLoss, InTransmissionLoss) == 0x000000, "Member 'AkRoomComponent_SetTransmissionLoss::InTransmissionLoss' has a wrong offset!");

// Function AkAudio.AkRoomComponent.UpdateParentRoomActor
// 0x0008 (0x0008 - 0x0000)
struct AkRoomComponent_UpdateParentRoomActor final
{
public:
	class AActor*                                 InParentRoomActor;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkRoomComponent_UpdateParentRoomActor) == 0x000008, "Wrong alignment on AkRoomComponent_UpdateParentRoomActor");
static_assert(sizeof(AkRoomComponent_UpdateParentRoomActor) == 0x000008, "Wrong size on AkRoomComponent_UpdateParentRoomActor");
static_assert(offsetof(AkRoomComponent_UpdateParentRoomActor, InParentRoomActor) == 0x000000, "Member 'AkRoomComponent_UpdateParentRoomActor::InParentRoomActor' has a wrong offset!");

// Function AkAudio.AkRoomComponent.UpdateTransitionRegionWidth
// 0x0004 (0x0004 - 0x0000)
struct AkRoomComponent_UpdateTransitionRegionWidth final
{
public:
	float                                         InTransitionRegionWidth;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkRoomComponent_UpdateTransitionRegionWidth) == 0x000004, "Wrong alignment on AkRoomComponent_UpdateTransitionRegionWidth");
static_assert(sizeof(AkRoomComponent_UpdateTransitionRegionWidth) == 0x000004, "Wrong size on AkRoomComponent_UpdateTransitionRegionWidth");
static_assert(offsetof(AkRoomComponent_UpdateTransitionRegionWidth, InTransitionRegionWidth) == 0x000000, "Member 'AkRoomComponent_UpdateTransitionRegionWidth::InTransitionRegionWidth' has a wrong offset!");

// Function AkAudio.AkRoomComponent.GetPrimitiveParent
// 0x0008 (0x0008 - 0x0000)
struct AkRoomComponent_GetPrimitiveParent final
{
public:
	class UPrimitiveComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkRoomComponent_GetPrimitiveParent) == 0x000008, "Wrong alignment on AkRoomComponent_GetPrimitiveParent");
static_assert(sizeof(AkRoomComponent_GetPrimitiveParent) == 0x000008, "Wrong size on AkRoomComponent_GetPrimitiveParent");
static_assert(offsetof(AkRoomComponent_GetPrimitiveParent, ReturnValue) == 0x000000, "Member 'AkRoomComponent_GetPrimitiveParent::ReturnValue' has a wrong offset!");

// Function AkAudio.AkPortalComponent.SetDynamic
// 0x0001 (0x0001 - 0x0000)
struct AkPortalComponent_SetDynamic final
{
public:
	bool                                          bInDynamic;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkPortalComponent_SetDynamic) == 0x000001, "Wrong alignment on AkPortalComponent_SetDynamic");
static_assert(sizeof(AkPortalComponent_SetDynamic) == 0x000001, "Wrong size on AkPortalComponent_SetDynamic");
static_assert(offsetof(AkPortalComponent_SetDynamic, bInDynamic) == 0x000000, "Member 'AkPortalComponent_SetDynamic::bInDynamic' has a wrong offset!");

// Function AkAudio.AkPortalComponent.SetPortalOcclusion
// 0x0004 (0x0004 - 0x0000)
struct AkPortalComponent_SetPortalOcclusion final
{
public:
	float                                         InPortalOcclusion;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkPortalComponent_SetPortalOcclusion) == 0x000004, "Wrong alignment on AkPortalComponent_SetPortalOcclusion");
static_assert(sizeof(AkPortalComponent_SetPortalOcclusion) == 0x000004, "Wrong size on AkPortalComponent_SetPortalOcclusion");
static_assert(offsetof(AkPortalComponent_SetPortalOcclusion, InPortalOcclusion) == 0x000000, "Member 'AkPortalComponent_SetPortalOcclusion::InPortalOcclusion' has a wrong offset!");

// Function AkAudio.AkPortalComponent.GetCurrentState
// 0x0001 (0x0001 - 0x0000)
struct AkPortalComponent_GetCurrentState final
{
public:
	EAkAcousticPortalState                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkPortalComponent_GetCurrentState) == 0x000001, "Wrong alignment on AkPortalComponent_GetCurrentState");
static_assert(sizeof(AkPortalComponent_GetCurrentState) == 0x000001, "Wrong size on AkPortalComponent_GetCurrentState");
static_assert(offsetof(AkPortalComponent_GetCurrentState, ReturnValue) == 0x000000, "Member 'AkPortalComponent_GetCurrentState::ReturnValue' has a wrong offset!");

// Function AkAudio.AkPortalComponent.GetPortalOcclusion
// 0x0004 (0x0004 - 0x0000)
struct AkPortalComponent_GetPortalOcclusion final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkPortalComponent_GetPortalOcclusion) == 0x000004, "Wrong alignment on AkPortalComponent_GetPortalOcclusion");
static_assert(sizeof(AkPortalComponent_GetPortalOcclusion) == 0x000004, "Wrong size on AkPortalComponent_GetPortalOcclusion");
static_assert(offsetof(AkPortalComponent_GetPortalOcclusion, ReturnValue) == 0x000000, "Member 'AkPortalComponent_GetPortalOcclusion::ReturnValue' has a wrong offset!");

// Function AkAudio.AkPortalComponent.GetPrimitiveParent
// 0x0008 (0x0008 - 0x0000)
struct AkPortalComponent_GetPrimitiveParent final
{
public:
	class UPrimitiveComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkPortalComponent_GetPrimitiveParent) == 0x000008, "Wrong alignment on AkPortalComponent_GetPrimitiveParent");
static_assert(sizeof(AkPortalComponent_GetPrimitiveParent) == 0x000008, "Wrong size on AkPortalComponent_GetPrimitiveParent");
static_assert(offsetof(AkPortalComponent_GetPrimitiveParent, ReturnValue) == 0x000000, "Member 'AkPortalComponent_GetPrimitiveParent::ReturnValue' has a wrong offset!");

// Function AkAudio.AkPortalComponent.PortalPlacementValid
// 0x0001 (0x0001 - 0x0000)
struct AkPortalComponent_PortalPlacementValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkPortalComponent_PortalPlacementValid) == 0x000001, "Wrong alignment on AkPortalComponent_PortalPlacementValid");
static_assert(sizeof(AkPortalComponent_PortalPlacementValid) == 0x000001, "Wrong size on AkPortalComponent_PortalPlacementValid");
static_assert(offsetof(AkPortalComponent_PortalPlacementValid, ReturnValue) == 0x000000, "Member 'AkPortalComponent_PortalPlacementValid::ReturnValue' has a wrong offset!");

// Function AkAudio.AkAcousticPortal.GetCurrentState
// 0x0001 (0x0001 - 0x0000)
struct AkAcousticPortal_GetCurrentState final
{
public:
	EAkAcousticPortalState                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkAcousticPortal_GetCurrentState) == 0x000001, "Wrong alignment on AkAcousticPortal_GetCurrentState");
static_assert(sizeof(AkAcousticPortal_GetCurrentState) == 0x000001, "Wrong size on AkAcousticPortal_GetCurrentState");
static_assert(offsetof(AkAcousticPortal_GetCurrentState, ReturnValue) == 0x000000, "Member 'AkAcousticPortal_GetCurrentState::ReturnValue' has a wrong offset!");

// Function AkAudio.AkAudioType.UnloadData
// 0x0001 (0x0001 - 0x0000)
struct AkAudioType_UnloadData final
{
public:
	bool                                          bAsync;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkAudioType_UnloadData) == 0x000001, "Wrong alignment on AkAudioType_UnloadData");
static_assert(sizeof(AkAudioType_UnloadData) == 0x000001, "Wrong size on AkAudioType_UnloadData");
static_assert(offsetof(AkAudioType_UnloadData, bAsync) == 0x000000, "Member 'AkAudioType_UnloadData::bAsync' has a wrong offset!");

// Function AkAudio.AkAudioType.GetWwiseShortId
// 0x0004 (0x0004 - 0x0000)
struct AkAudioType_GetWwiseShortId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkAudioType_GetWwiseShortId) == 0x000004, "Wrong alignment on AkAudioType_GetWwiseShortId");
static_assert(sizeof(AkAudioType_GetWwiseShortId) == 0x000004, "Wrong size on AkAudioType_GetWwiseShortId");
static_assert(offsetof(AkAudioType_GetWwiseShortId, ReturnValue) == 0x000000, "Member 'AkAudioType_GetWwiseShortId::ReturnValue' has a wrong offset!");

// Function AkAudio.AkAndroidInitializationSettings.MigrateMultiCoreRendering
// 0x0001 (0x0001 - 0x0000)
struct AkAndroidInitializationSettings_MigrateMultiCoreRendering final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkAndroidInitializationSettings_MigrateMultiCoreRendering) == 0x000001, "Wrong alignment on AkAndroidInitializationSettings_MigrateMultiCoreRendering");
static_assert(sizeof(AkAndroidInitializationSettings_MigrateMultiCoreRendering) == 0x000001, "Wrong size on AkAndroidInitializationSettings_MigrateMultiCoreRendering");
static_assert(offsetof(AkAndroidInitializationSettings_MigrateMultiCoreRendering, NewValue) == 0x000000, "Member 'AkAndroidInitializationSettings_MigrateMultiCoreRendering::NewValue' has a wrong offset!");

// Function AkAudio.AkAudioEvent.ExecuteAction
// 0x0020 (0x0020 - 0x0000)
struct AkAudioEvent_ExecuteAction final
{
public:
	EAkActionOnEventType                          ActionType;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class AActor*                           Actor;                                             // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayingID;                                         // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransitionDuration;                                // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkCurveInterpolation                         FadeCurve;                                         // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkAudioEvent_ExecuteAction) == 0x000008, "Wrong alignment on AkAudioEvent_ExecuteAction");
static_assert(sizeof(AkAudioEvent_ExecuteAction) == 0x000020, "Wrong size on AkAudioEvent_ExecuteAction");
static_assert(offsetof(AkAudioEvent_ExecuteAction, ActionType) == 0x000000, "Member 'AkAudioEvent_ExecuteAction::ActionType' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_ExecuteAction, Actor) == 0x000008, "Member 'AkAudioEvent_ExecuteAction::Actor' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_ExecuteAction, PlayingID) == 0x000010, "Member 'AkAudioEvent_ExecuteAction::PlayingID' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_ExecuteAction, TransitionDuration) == 0x000014, "Member 'AkAudioEvent_ExecuteAction::TransitionDuration' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_ExecuteAction, FadeCurve) == 0x000018, "Member 'AkAudioEvent_ExecuteAction::FadeCurve' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_ExecuteAction, ReturnValue) == 0x00001C, "Member 'AkAudioEvent_ExecuteAction::ReturnValue' has a wrong offset!");

// Function AkAudio.AkAudioEvent.PostAtLocation
// 0x0058 (0x0058 - 0x0000)
struct AkAudioEvent_PostAtLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> Callback;                                          // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallbackMask;                                      // 0x0040(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UObject*                          WorldContextObject;                                // 0x0048(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0050(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkAudioEvent_PostAtLocation) == 0x000008, "Wrong alignment on AkAudioEvent_PostAtLocation");
static_assert(sizeof(AkAudioEvent_PostAtLocation) == 0x000058, "Wrong size on AkAudioEvent_PostAtLocation");
static_assert(offsetof(AkAudioEvent_PostAtLocation, Location) == 0x000000, "Member 'AkAudioEvent_PostAtLocation::Location' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostAtLocation, Orientation) == 0x000018, "Member 'AkAudioEvent_PostAtLocation::Orientation' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostAtLocation, Callback) == 0x000030, "Member 'AkAudioEvent_PostAtLocation::Callback' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostAtLocation, CallbackMask) == 0x000040, "Member 'AkAudioEvent_PostAtLocation::CallbackMask' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostAtLocation, WorldContextObject) == 0x000048, "Member 'AkAudioEvent_PostAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostAtLocation, ReturnValue) == 0x000050, "Member 'AkAudioEvent_PostAtLocation::ReturnValue' has a wrong offset!");

// Function AkAudio.AkAudioEvent.PostOnActor
// 0x0028 (0x0028 - 0x0000)
struct AkAudioEvent_PostOnActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> Delegate;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallbackMask;                                      // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedObjectDestroyed;                  // 0x001C(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkAudioEvent_PostOnActor) == 0x000008, "Wrong alignment on AkAudioEvent_PostOnActor");
static_assert(sizeof(AkAudioEvent_PostOnActor) == 0x000028, "Wrong size on AkAudioEvent_PostOnActor");
static_assert(offsetof(AkAudioEvent_PostOnActor, Actor) == 0x000000, "Member 'AkAudioEvent_PostOnActor::Actor' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnActor, Delegate) == 0x000008, "Member 'AkAudioEvent_PostOnActor::Delegate' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnActor, CallbackMask) == 0x000018, "Member 'AkAudioEvent_PostOnActor::CallbackMask' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnActor, bStopWhenAttachedObjectDestroyed) == 0x00001C, "Member 'AkAudioEvent_PostOnActor::bStopWhenAttachedObjectDestroyed' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnActor, ReturnValue) == 0x000020, "Member 'AkAudioEvent_PostOnActor::ReturnValue' has a wrong offset!");

// Function AkAudio.AkAudioEvent.PostOnActorAndWait
// 0x0030 (0x0030 - 0x0000)
struct AkAudioEvent_PostOnActorAndWait final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedObjectDestroyed;                  // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLatentActionInfo                      LatentActionInfo;                                  // 0x0010(0x0018)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkAudioEvent_PostOnActorAndWait) == 0x000008, "Wrong alignment on AkAudioEvent_PostOnActorAndWait");
static_assert(sizeof(AkAudioEvent_PostOnActorAndWait) == 0x000030, "Wrong size on AkAudioEvent_PostOnActorAndWait");
static_assert(offsetof(AkAudioEvent_PostOnActorAndWait, Actor) == 0x000000, "Member 'AkAudioEvent_PostOnActorAndWait::Actor' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnActorAndWait, bStopWhenAttachedObjectDestroyed) == 0x000008, "Member 'AkAudioEvent_PostOnActorAndWait::bStopWhenAttachedObjectDestroyed' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnActorAndWait, LatentActionInfo) == 0x000010, "Member 'AkAudioEvent_PostOnActorAndWait::LatentActionInfo' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnActorAndWait, ReturnValue) == 0x000028, "Member 'AkAudioEvent_PostOnActorAndWait::ReturnValue' has a wrong offset!");

// Function AkAudio.AkAudioEvent.PostOnComponent
// 0x0028 (0x0028 - 0x0000)
struct AkAudioEvent_PostOnComponent final
{
public:
	class UAkComponent*                           Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> Delegate;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallbackMask;                                      // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedObjectDestroyed;                  // 0x001C(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkAudioEvent_PostOnComponent) == 0x000008, "Wrong alignment on AkAudioEvent_PostOnComponent");
static_assert(sizeof(AkAudioEvent_PostOnComponent) == 0x000028, "Wrong size on AkAudioEvent_PostOnComponent");
static_assert(offsetof(AkAudioEvent_PostOnComponent, Component) == 0x000000, "Member 'AkAudioEvent_PostOnComponent::Component' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnComponent, Delegate) == 0x000008, "Member 'AkAudioEvent_PostOnComponent::Delegate' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnComponent, CallbackMask) == 0x000018, "Member 'AkAudioEvent_PostOnComponent::CallbackMask' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnComponent, bStopWhenAttachedObjectDestroyed) == 0x00001C, "Member 'AkAudioEvent_PostOnComponent::bStopWhenAttachedObjectDestroyed' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnComponent, ReturnValue) == 0x000020, "Member 'AkAudioEvent_PostOnComponent::ReturnValue' has a wrong offset!");

// Function AkAudio.AkAudioEvent.PostOnComponentAndWait
// 0x0030 (0x0030 - 0x0000)
struct AkAudioEvent_PostOnComponentAndWait final
{
public:
	class UAkComponent*                           Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedObjectDestroyed;                  // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLatentActionInfo                      LatentActionInfo;                                  // 0x0010(0x0018)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkAudioEvent_PostOnComponentAndWait) == 0x000008, "Wrong alignment on AkAudioEvent_PostOnComponentAndWait");
static_assert(sizeof(AkAudioEvent_PostOnComponentAndWait) == 0x000030, "Wrong size on AkAudioEvent_PostOnComponentAndWait");
static_assert(offsetof(AkAudioEvent_PostOnComponentAndWait, Component) == 0x000000, "Member 'AkAudioEvent_PostOnComponentAndWait::Component' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnComponentAndWait, bStopWhenAttachedObjectDestroyed) == 0x000008, "Member 'AkAudioEvent_PostOnComponentAndWait::bStopWhenAttachedObjectDestroyed' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnComponentAndWait, LatentActionInfo) == 0x000010, "Member 'AkAudioEvent_PostOnComponentAndWait::LatentActionInfo' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnComponentAndWait, ReturnValue) == 0x000028, "Member 'AkAudioEvent_PostOnComponentAndWait::ReturnValue' has a wrong offset!");

// Function AkAudio.AkAudioEvent.PostOnGameObject
// 0x0020 (0x0020 - 0x0000)
struct AkAudioEvent_PostOnGameObject final
{
public:
	class UAkGameObject*                          GameObject;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> Delegate;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallbackMask;                                      // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkAudioEvent_PostOnGameObject) == 0x000008, "Wrong alignment on AkAudioEvent_PostOnGameObject");
static_assert(sizeof(AkAudioEvent_PostOnGameObject) == 0x000020, "Wrong size on AkAudioEvent_PostOnGameObject");
static_assert(offsetof(AkAudioEvent_PostOnGameObject, GameObject) == 0x000000, "Member 'AkAudioEvent_PostOnGameObject::GameObject' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnGameObject, Delegate) == 0x000008, "Member 'AkAudioEvent_PostOnGameObject::Delegate' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnGameObject, CallbackMask) == 0x000018, "Member 'AkAudioEvent_PostOnGameObject::CallbackMask' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnGameObject, ReturnValue) == 0x00001C, "Member 'AkAudioEvent_PostOnGameObject::ReturnValue' has a wrong offset!");

// Function AkAudio.AkAudioEvent.PostOnGameObjectAndWait
// 0x0028 (0x0028 - 0x0000)
struct AkAudioEvent_PostOnGameObjectAndWait final
{
public:
	class UAkGameObject*                          GameObject;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentActionInfo;                                  // 0x0008(0x0018)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkAudioEvent_PostOnGameObjectAndWait) == 0x000008, "Wrong alignment on AkAudioEvent_PostOnGameObjectAndWait");
static_assert(sizeof(AkAudioEvent_PostOnGameObjectAndWait) == 0x000028, "Wrong size on AkAudioEvent_PostOnGameObjectAndWait");
static_assert(offsetof(AkAudioEvent_PostOnGameObjectAndWait, GameObject) == 0x000000, "Member 'AkAudioEvent_PostOnGameObjectAndWait::GameObject' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnGameObjectAndWait, LatentActionInfo) == 0x000008, "Member 'AkAudioEvent_PostOnGameObjectAndWait::LatentActionInfo' has a wrong offset!");
static_assert(offsetof(AkAudioEvent_PostOnGameObjectAndWait, ReturnValue) == 0x000020, "Member 'AkAudioEvent_PostOnGameObjectAndWait::ReturnValue' has a wrong offset!");

// Function AkAudio.AkComponent.GetOcclusionCollisionChannel
// 0x0001 (0x0001 - 0x0000)
struct AkComponent_GetOcclusionCollisionChannel final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkComponent_GetOcclusionCollisionChannel) == 0x000001, "Wrong alignment on AkComponent_GetOcclusionCollisionChannel");
static_assert(sizeof(AkComponent_GetOcclusionCollisionChannel) == 0x000001, "Wrong size on AkComponent_GetOcclusionCollisionChannel");
static_assert(offsetof(AkComponent_GetOcclusionCollisionChannel, ReturnValue) == 0x000000, "Member 'AkComponent_GetOcclusionCollisionChannel::ReturnValue' has a wrong offset!");

// Function AkAudio.AkComponent.PostAkEventAndWaitForEnd
// 0x0028 (0x0028 - 0x0000)
struct AkComponent_PostAkEventAndWaitForEnd final
{
public:
	class UAkAudioEvent*                          AkEvent;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0008(0x0018)(Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkComponent_PostAkEventAndWaitForEnd) == 0x000008, "Wrong alignment on AkComponent_PostAkEventAndWaitForEnd");
static_assert(sizeof(AkComponent_PostAkEventAndWaitForEnd) == 0x000028, "Wrong size on AkComponent_PostAkEventAndWaitForEnd");
static_assert(offsetof(AkComponent_PostAkEventAndWaitForEnd, AkEvent) == 0x000000, "Member 'AkComponent_PostAkEventAndWaitForEnd::AkEvent' has a wrong offset!");
static_assert(offsetof(AkComponent_PostAkEventAndWaitForEnd, LatentInfo) == 0x000008, "Member 'AkComponent_PostAkEventAndWaitForEnd::LatentInfo' has a wrong offset!");
static_assert(offsetof(AkComponent_PostAkEventAndWaitForEnd, ReturnValue) == 0x000020, "Member 'AkComponent_PostAkEventAndWaitForEnd::ReturnValue' has a wrong offset!");

// Function AkAudio.AkComponent.PostAssociatedAkEventAndWaitForEnd
// 0x0020 (0x0020 - 0x0000)
struct AkComponent_PostAssociatedAkEventAndWaitForEnd final
{
public:
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkComponent_PostAssociatedAkEventAndWaitForEnd) == 0x000008, "Wrong alignment on AkComponent_PostAssociatedAkEventAndWaitForEnd");
static_assert(sizeof(AkComponent_PostAssociatedAkEventAndWaitForEnd) == 0x000020, "Wrong size on AkComponent_PostAssociatedAkEventAndWaitForEnd");
static_assert(offsetof(AkComponent_PostAssociatedAkEventAndWaitForEnd, LatentInfo) == 0x000000, "Member 'AkComponent_PostAssociatedAkEventAndWaitForEnd::LatentInfo' has a wrong offset!");
static_assert(offsetof(AkComponent_PostAssociatedAkEventAndWaitForEnd, ReturnValue) == 0x000018, "Member 'AkComponent_PostAssociatedAkEventAndWaitForEnd::ReturnValue' has a wrong offset!");

// Function AkAudio.AkComponent.PostTrigger
// 0x0008 (0x0008 - 0x0000)
struct AkComponent_PostTrigger final
{
public:
	class UAkTrigger*                             TriggerValue;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkComponent_PostTrigger) == 0x000008, "Wrong alignment on AkComponent_PostTrigger");
static_assert(sizeof(AkComponent_PostTrigger) == 0x000008, "Wrong size on AkComponent_PostTrigger");
static_assert(offsetof(AkComponent_PostTrigger, TriggerValue) == 0x000000, "Member 'AkComponent_PostTrigger::TriggerValue' has a wrong offset!");

// Function AkAudio.AkComponent.SetEarlyReflectionsAuxBus
// 0x0010 (0x0010 - 0x0000)
struct AkComponent_SetEarlyReflectionsAuxBus final
{
public:
	class FString                                 AuxBusName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkComponent_SetEarlyReflectionsAuxBus) == 0x000008, "Wrong alignment on AkComponent_SetEarlyReflectionsAuxBus");
static_assert(sizeof(AkComponent_SetEarlyReflectionsAuxBus) == 0x000010, "Wrong size on AkComponent_SetEarlyReflectionsAuxBus");
static_assert(offsetof(AkComponent_SetEarlyReflectionsAuxBus, AuxBusName) == 0x000000, "Member 'AkComponent_SetEarlyReflectionsAuxBus::AuxBusName' has a wrong offset!");

// Function AkAudio.AkComponent.SetEarlyReflectionsVolume
// 0x0004 (0x0004 - 0x0000)
struct AkComponent_SetEarlyReflectionsVolume final
{
public:
	float                                         SendVolume;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkComponent_SetEarlyReflectionsVolume) == 0x000004, "Wrong alignment on AkComponent_SetEarlyReflectionsVolume");
static_assert(sizeof(AkComponent_SetEarlyReflectionsVolume) == 0x000004, "Wrong size on AkComponent_SetEarlyReflectionsVolume");
static_assert(offsetof(AkComponent_SetEarlyReflectionsVolume, SendVolume) == 0x000000, "Member 'AkComponent_SetEarlyReflectionsVolume::SendVolume' has a wrong offset!");

// Function AkAudio.AkComponent.SetEnableSpotReflectors
// 0x0001 (0x0001 - 0x0000)
struct AkComponent_SetEnableSpotReflectors final
{
public:
	bool                                          in_enable;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkComponent_SetEnableSpotReflectors) == 0x000001, "Wrong alignment on AkComponent_SetEnableSpotReflectors");
static_assert(sizeof(AkComponent_SetEnableSpotReflectors) == 0x000001, "Wrong size on AkComponent_SetEnableSpotReflectors");
static_assert(offsetof(AkComponent_SetEnableSpotReflectors, in_enable) == 0x000000, "Member 'AkComponent_SetEnableSpotReflectors::in_enable' has a wrong offset!");

// Function AkAudio.AkComponent.SetGameObjectRadius
// 0x0008 (0x0008 - 0x0000)
struct AkComponent_SetGameObjectRadius final
{
public:
	float                                         in_outerRadius;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         in_innerRadius;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkComponent_SetGameObjectRadius) == 0x000004, "Wrong alignment on AkComponent_SetGameObjectRadius");
static_assert(sizeof(AkComponent_SetGameObjectRadius) == 0x000008, "Wrong size on AkComponent_SetGameObjectRadius");
static_assert(offsetof(AkComponent_SetGameObjectRadius, in_outerRadius) == 0x000000, "Member 'AkComponent_SetGameObjectRadius::in_outerRadius' has a wrong offset!");
static_assert(offsetof(AkComponent_SetGameObjectRadius, in_innerRadius) == 0x000004, "Member 'AkComponent_SetGameObjectRadius::in_innerRadius' has a wrong offset!");

// Function AkAudio.AkComponent.SetListeners
// 0x0010 (0x0010 - 0x0000)
struct AkComponent_SetListeners final
{
public:
	TArray<class UAkComponent*>                   Listeners;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkComponent_SetListeners) == 0x000008, "Wrong alignment on AkComponent_SetListeners");
static_assert(sizeof(AkComponent_SetListeners) == 0x000010, "Wrong size on AkComponent_SetListeners");
static_assert(offsetof(AkComponent_SetListeners, Listeners) == 0x000000, "Member 'AkComponent_SetListeners::Listeners' has a wrong offset!");

// Function AkAudio.AkComponent.SetOutputBusVolume
// 0x0004 (0x0004 - 0x0000)
struct AkComponent_SetOutputBusVolume final
{
public:
	float                                         BusVolume;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkComponent_SetOutputBusVolume) == 0x000004, "Wrong alignment on AkComponent_SetOutputBusVolume");
static_assert(sizeof(AkComponent_SetOutputBusVolume) == 0x000004, "Wrong size on AkComponent_SetOutputBusVolume");
static_assert(offsetof(AkComponent_SetOutputBusVolume, BusVolume) == 0x000000, "Member 'AkComponent_SetOutputBusVolume::BusVolume' has a wrong offset!");

// Function AkAudio.AkComponent.SetStopWhenOwnerDestroyed
// 0x0001 (0x0001 - 0x0000)
struct AkComponent_SetStopWhenOwnerDestroyed final
{
public:
	bool                                          bStopWhenOwnerDestroyed;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkComponent_SetStopWhenOwnerDestroyed) == 0x000001, "Wrong alignment on AkComponent_SetStopWhenOwnerDestroyed");
static_assert(sizeof(AkComponent_SetStopWhenOwnerDestroyed) == 0x000001, "Wrong size on AkComponent_SetStopWhenOwnerDestroyed");
static_assert(offsetof(AkComponent_SetStopWhenOwnerDestroyed, bStopWhenOwnerDestroyed) == 0x000000, "Member 'AkComponent_SetStopWhenOwnerDestroyed::bStopWhenOwnerDestroyed' has a wrong offset!");

// Function AkAudio.AkComponent.SetSwitch
// 0x0008 (0x0008 - 0x0000)
struct AkComponent_SetSwitch final
{
public:
	class UAkSwitchValue*                         SwitchValue;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkComponent_SetSwitch) == 0x000008, "Wrong alignment on AkComponent_SetSwitch");
static_assert(sizeof(AkComponent_SetSwitch) == 0x000008, "Wrong size on AkComponent_SetSwitch");
static_assert(offsetof(AkComponent_SetSwitch, SwitchValue) == 0x000000, "Member 'AkComponent_SetSwitch::SwitchValue' has a wrong offset!");

// Function AkAudio.AkComponent.GetAttenuationRadius
// 0x0004 (0x0004 - 0x0000)
struct AkComponent_GetAttenuationRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkComponent_GetAttenuationRadius) == 0x000004, "Wrong alignment on AkComponent_GetAttenuationRadius");
static_assert(sizeof(AkComponent_GetAttenuationRadius) == 0x000004, "Wrong size on AkComponent_GetAttenuationRadius");
static_assert(offsetof(AkComponent_GetAttenuationRadius, ReturnValue) == 0x000000, "Member 'AkComponent_GetAttenuationRadius::ReturnValue' has a wrong offset!");

// Function AkAudio.AkAudioInputComponent.PostAssociatedAudioInputEvent
// 0x0004 (0x0004 - 0x0000)
struct AkAudioInputComponent_PostAssociatedAudioInputEvent final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkAudioInputComponent_PostAssociatedAudioInputEvent) == 0x000004, "Wrong alignment on AkAudioInputComponent_PostAssociatedAudioInputEvent");
static_assert(sizeof(AkAudioInputComponent_PostAssociatedAudioInputEvent) == 0x000004, "Wrong size on AkAudioInputComponent_PostAssociatedAudioInputEvent");
static_assert(offsetof(AkAudioInputComponent_PostAssociatedAudioInputEvent, ReturnValue) == 0x000000, "Member 'AkAudioInputComponent_PostAssociatedAudioInputEvent::ReturnValue' has a wrong offset!");

// Function AkAudio.AkWinGDKInitializationSettings.MigrateMultiCoreRendering
// 0x0001 (0x0001 - 0x0000)
struct AkWinGDKInitializationSettings_MigrateMultiCoreRendering final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkWinGDKInitializationSettings_MigrateMultiCoreRendering) == 0x000001, "Wrong alignment on AkWinGDKInitializationSettings_MigrateMultiCoreRendering");
static_assert(sizeof(AkWinGDKInitializationSettings_MigrateMultiCoreRendering) == 0x000001, "Wrong size on AkWinGDKInitializationSettings_MigrateMultiCoreRendering");
static_assert(offsetof(AkWinGDKInitializationSettings_MigrateMultiCoreRendering, NewValue) == 0x000000, "Member 'AkWinGDKInitializationSettings_MigrateMultiCoreRendering::NewValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.AddOutput
// 0x0028 (0x0028 - 0x0000)
struct AkGameplayStatics_AddOutput final
{
public:
	struct FAkOutputSettings                      in_Settings;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FAkOutputDeviceID                      out_DeviceID;                                      // 0x0010(0x0008)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UAkComponent*>                   in_ListenerIDs;                                    // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_AddOutput) == 0x000008, "Wrong alignment on AkGameplayStatics_AddOutput");
static_assert(sizeof(AkGameplayStatics_AddOutput) == 0x000028, "Wrong size on AkGameplayStatics_AddOutput");
static_assert(offsetof(AkGameplayStatics_AddOutput, in_Settings) == 0x000000, "Member 'AkGameplayStatics_AddOutput::in_Settings' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_AddOutput, out_DeviceID) == 0x000010, "Member 'AkGameplayStatics_AddOutput::out_DeviceID' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_AddOutput, in_ListenerIDs) == 0x000018, "Member 'AkGameplayStatics_AddOutput::in_ListenerIDs' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.AddOutputCaptureMarker
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_AddOutputCaptureMarker final
{
public:
	class FString                                 MarkerText;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_AddOutputCaptureMarker) == 0x000008, "Wrong alignment on AkGameplayStatics_AddOutputCaptureMarker");
static_assert(sizeof(AkGameplayStatics_AddOutputCaptureMarker) == 0x000010, "Wrong size on AkGameplayStatics_AddOutputCaptureMarker");
static_assert(offsetof(AkGameplayStatics_AddOutputCaptureMarker, MarkerText) == 0x000000, "Member 'AkGameplayStatics_AddOutputCaptureMarker::MarkerText' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.CancelEventCallback
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_CancelEventCallback final
{
public:
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> PostEventCallback;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_CancelEventCallback) == 0x000004, "Wrong alignment on AkGameplayStatics_CancelEventCallback");
static_assert(sizeof(AkGameplayStatics_CancelEventCallback) == 0x000010, "Wrong size on AkGameplayStatics_CancelEventCallback");
static_assert(offsetof(AkGameplayStatics_CancelEventCallback, PostEventCallback) == 0x000000, "Member 'AkGameplayStatics_CancelEventCallback::PostEventCallback' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.GetAkAudioTypeUserData
// 0x0018 (0x0018 - 0x0000)
struct AkGameplayStatics_GetAkAudioTypeUserData final
{
public:
	const class UAkAudioType*                     Instance;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UClass*                           Type;                                              // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_GetAkAudioTypeUserData) == 0x000008, "Wrong alignment on AkGameplayStatics_GetAkAudioTypeUserData");
static_assert(sizeof(AkGameplayStatics_GetAkAudioTypeUserData) == 0x000018, "Wrong size on AkGameplayStatics_GetAkAudioTypeUserData");
static_assert(offsetof(AkGameplayStatics_GetAkAudioTypeUserData, Instance) == 0x000000, "Member 'AkGameplayStatics_GetAkAudioTypeUserData::Instance' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetAkAudioTypeUserData, Type) == 0x000008, "Member 'AkGameplayStatics_GetAkAudioTypeUserData::Type' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetAkAudioTypeUserData, ReturnValue) == 0x000010, "Member 'AkGameplayStatics_GetAkAudioTypeUserData::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.GetAkComponent
// 0x0040 (0x0040 - 0x0000)
struct AkGameplayStatics_GetAkComponent final
{
public:
	class USceneComponent*                        AttachToComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ComponentCreated;                                  // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachPointName;                                   // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           ReturnValue;                                       // 0x0038(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_GetAkComponent) == 0x000008, "Wrong alignment on AkGameplayStatics_GetAkComponent");
static_assert(sizeof(AkGameplayStatics_GetAkComponent) == 0x000040, "Wrong size on AkGameplayStatics_GetAkComponent");
static_assert(offsetof(AkGameplayStatics_GetAkComponent, AttachToComponent) == 0x000000, "Member 'AkGameplayStatics_GetAkComponent::AttachToComponent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetAkComponent, ComponentCreated) == 0x000008, "Member 'AkGameplayStatics_GetAkComponent::ComponentCreated' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetAkComponent, AttachPointName) == 0x00000C, "Member 'AkGameplayStatics_GetAkComponent::AttachPointName' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetAkComponent, Location) == 0x000018, "Member 'AkGameplayStatics_GetAkComponent::Location' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetAkComponent, LocationType) == 0x000030, "Member 'AkGameplayStatics_GetAkComponent::LocationType' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetAkComponent, ReturnValue) == 0x000038, "Member 'AkGameplayStatics_GetAkComponent::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.GetAvailableAudioCultures
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_GetAvailableAudioCultures final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_GetAvailableAudioCultures) == 0x000008, "Wrong alignment on AkGameplayStatics_GetAvailableAudioCultures");
static_assert(sizeof(AkGameplayStatics_GetAvailableAudioCultures) == 0x000010, "Wrong size on AkGameplayStatics_GetAvailableAudioCultures");
static_assert(offsetof(AkGameplayStatics_GetAvailableAudioCultures, ReturnValue) == 0x000000, "Member 'AkGameplayStatics_GetAvailableAudioCultures::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.GetCurrentAudioCulture
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_GetCurrentAudioCulture final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_GetCurrentAudioCulture) == 0x000008, "Wrong alignment on AkGameplayStatics_GetCurrentAudioCulture");
static_assert(sizeof(AkGameplayStatics_GetCurrentAudioCulture) == 0x000010, "Wrong size on AkGameplayStatics_GetCurrentAudioCulture");
static_assert(offsetof(AkGameplayStatics_GetCurrentAudioCulture, ReturnValue) == 0x000000, "Member 'AkGameplayStatics_GetCurrentAudioCulture::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.GetCurrentOutdoorsRoomParameters
// 0x0018 (0x0018 - 0x0000)
struct AkGameplayStatics_GetCurrentOutdoorsRoomParameters final
{
public:
	struct FAkOutdoorsRoomParameters              ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_GetCurrentOutdoorsRoomParameters) == 0x000008, "Wrong alignment on AkGameplayStatics_GetCurrentOutdoorsRoomParameters");
static_assert(sizeof(AkGameplayStatics_GetCurrentOutdoorsRoomParameters) == 0x000018, "Wrong size on AkGameplayStatics_GetCurrentOutdoorsRoomParameters");
static_assert(offsetof(AkGameplayStatics_GetCurrentOutdoorsRoomParameters, ReturnValue) == 0x000000, "Member 'AkGameplayStatics_GetCurrentOutdoorsRoomParameters::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.GetOrCreateAkComponent
// 0x0020 (0x0020 - 0x0000)
struct AkGameplayStatics_GetOrCreateAkComponent final
{
public:
	class USceneComponent*                        AttachToComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ComponentCreated;                                  // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachPointName;                                   // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_GetOrCreateAkComponent) == 0x000008, "Wrong alignment on AkGameplayStatics_GetOrCreateAkComponent");
static_assert(sizeof(AkGameplayStatics_GetOrCreateAkComponent) == 0x000020, "Wrong size on AkGameplayStatics_GetOrCreateAkComponent");
static_assert(offsetof(AkGameplayStatics_GetOrCreateAkComponent, AttachToComponent) == 0x000000, "Member 'AkGameplayStatics_GetOrCreateAkComponent::AttachToComponent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetOrCreateAkComponent, ComponentCreated) == 0x000008, "Member 'AkGameplayStatics_GetOrCreateAkComponent::ComponentCreated' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetOrCreateAkComponent, AttachPointName) == 0x00000C, "Member 'AkGameplayStatics_GetOrCreateAkComponent::AttachPointName' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetOrCreateAkComponent, ReturnValue) == 0x000018, "Member 'AkGameplayStatics_GetOrCreateAkComponent::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.GetRTPCValue
// 0x0020 (0x0020 - 0x0000)
struct AkGameplayStatics_GetRTPCValue final
{
public:
	class UAkRtpc*                                RTPCValue;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayingID;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERTPCValueType                                InputValueType;                                    // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERTPCValueType                                OutputValueType;                                   // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_GetRTPCValue) == 0x000008, "Wrong alignment on AkGameplayStatics_GetRTPCValue");
static_assert(sizeof(AkGameplayStatics_GetRTPCValue) == 0x000020, "Wrong size on AkGameplayStatics_GetRTPCValue");
static_assert(offsetof(AkGameplayStatics_GetRTPCValue, RTPCValue) == 0x000000, "Member 'AkGameplayStatics_GetRTPCValue::RTPCValue' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetRTPCValue, PlayingID) == 0x000008, "Member 'AkGameplayStatics_GetRTPCValue::PlayingID' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetRTPCValue, InputValueType) == 0x00000C, "Member 'AkGameplayStatics_GetRTPCValue::InputValueType' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetRTPCValue, Value) == 0x000010, "Member 'AkGameplayStatics_GetRTPCValue::Value' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetRTPCValue, OutputValueType) == 0x000014, "Member 'AkGameplayStatics_GetRTPCValue::OutputValueType' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetRTPCValue, Actor) == 0x000018, "Member 'AkGameplayStatics_GetRTPCValue::Actor' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.GetSpeakerAngles
// 0x0028 (0x0028 - 0x0000)
struct AkGameplayStatics_GetSpeakerAngles final
{
public:
	TArray<float>                                 SpeakerAngles;                                     // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HeightAngle;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DeviceShareSet;                                    // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_GetSpeakerAngles) == 0x000008, "Wrong alignment on AkGameplayStatics_GetSpeakerAngles");
static_assert(sizeof(AkGameplayStatics_GetSpeakerAngles) == 0x000028, "Wrong size on AkGameplayStatics_GetSpeakerAngles");
static_assert(offsetof(AkGameplayStatics_GetSpeakerAngles, SpeakerAngles) == 0x000000, "Member 'AkGameplayStatics_GetSpeakerAngles::SpeakerAngles' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetSpeakerAngles, HeightAngle) == 0x000010, "Member 'AkGameplayStatics_GetSpeakerAngles::HeightAngle' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_GetSpeakerAngles, DeviceShareSet) == 0x000018, "Member 'AkGameplayStatics_GetSpeakerAngles::DeviceShareSet' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.IsEditor
// 0x0001 (0x0001 - 0x0000)
struct AkGameplayStatics_IsEditor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_IsEditor) == 0x000001, "Wrong alignment on AkGameplayStatics_IsEditor");
static_assert(sizeof(AkGameplayStatics_IsEditor) == 0x000001, "Wrong size on AkGameplayStatics_IsEditor");
static_assert(offsetof(AkGameplayStatics_IsEditor, ReturnValue) == 0x000000, "Member 'AkGameplayStatics_IsEditor::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.IsGame
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_IsGame final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_IsGame) == 0x000008, "Wrong alignment on AkGameplayStatics_IsGame");
static_assert(sizeof(AkGameplayStatics_IsGame) == 0x000010, "Wrong size on AkGameplayStatics_IsGame");
static_assert(offsetof(AkGameplayStatics_IsGame, WorldContextObject) == 0x000000, "Member 'AkGameplayStatics_IsGame::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_IsGame, ReturnValue) == 0x000008, "Member 'AkGameplayStatics_IsGame::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.PostAndWaitForEndOfEvent
// 0x0030 (0x0030 - 0x0000)
struct AkGameplayStatics_PostAndWaitForEndOfEvent final
{
public:
	class UAkAudioEvent*                          AkEvent;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0010(0x0018)(Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x002C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_PostAndWaitForEndOfEvent) == 0x000008, "Wrong alignment on AkGameplayStatics_PostAndWaitForEndOfEvent");
static_assert(sizeof(AkGameplayStatics_PostAndWaitForEndOfEvent) == 0x000030, "Wrong size on AkGameplayStatics_PostAndWaitForEndOfEvent");
static_assert(offsetof(AkGameplayStatics_PostAndWaitForEndOfEvent, AkEvent) == 0x000000, "Member 'AkGameplayStatics_PostAndWaitForEndOfEvent::AkEvent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostAndWaitForEndOfEvent, Actor) == 0x000008, "Member 'AkGameplayStatics_PostAndWaitForEndOfEvent::Actor' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostAndWaitForEndOfEvent, LatentInfo) == 0x000010, "Member 'AkGameplayStatics_PostAndWaitForEndOfEvent::LatentInfo' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostAndWaitForEndOfEvent, bStopWhenAttachedToDestroyed) == 0x000028, "Member 'AkGameplayStatics_PostAndWaitForEndOfEvent::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostAndWaitForEndOfEvent, ReturnValue) == 0x00002C, "Member 'AkGameplayStatics_PostAndWaitForEndOfEvent::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.PostEvent
// 0x0030 (0x0030 - 0x0000)
struct AkGameplayStatics_PostEvent final
{
public:
	class UAkAudioEvent*                          AkEvent;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallbackMask;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> PostEventCallback;                                 // 0x0014(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_PostEvent) == 0x000008, "Wrong alignment on AkGameplayStatics_PostEvent");
static_assert(sizeof(AkGameplayStatics_PostEvent) == 0x000030, "Wrong size on AkGameplayStatics_PostEvent");
static_assert(offsetof(AkGameplayStatics_PostEvent, AkEvent) == 0x000000, "Member 'AkGameplayStatics_PostEvent::AkEvent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostEvent, Actor) == 0x000008, "Member 'AkGameplayStatics_PostEvent::Actor' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostEvent, CallbackMask) == 0x000010, "Member 'AkGameplayStatics_PostEvent::CallbackMask' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostEvent, PostEventCallback) == 0x000014, "Member 'AkGameplayStatics_PostEvent::PostEventCallback' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostEvent, bStopWhenAttachedToDestroyed) == 0x000024, "Member 'AkGameplayStatics_PostEvent::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostEvent, ReturnValue) == 0x000028, "Member 'AkGameplayStatics_PostEvent::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.PostEventAtLocation
// 0x0048 (0x0048 - 0x0000)
struct AkGameplayStatics_PostEventAtLocation final
{
public:
	class UAkAudioEvent*                          AkEvent;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0038(0x0008)(Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_PostEventAtLocation) == 0x000008, "Wrong alignment on AkGameplayStatics_PostEventAtLocation");
static_assert(sizeof(AkGameplayStatics_PostEventAtLocation) == 0x000048, "Wrong size on AkGameplayStatics_PostEventAtLocation");
static_assert(offsetof(AkGameplayStatics_PostEventAtLocation, AkEvent) == 0x000000, "Member 'AkGameplayStatics_PostEventAtLocation::AkEvent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostEventAtLocation, Location) == 0x000008, "Member 'AkGameplayStatics_PostEventAtLocation::Location' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostEventAtLocation, Orientation) == 0x000020, "Member 'AkGameplayStatics_PostEventAtLocation::Orientation' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostEventAtLocation, WorldContextObject) == 0x000038, "Member 'AkGameplayStatics_PostEventAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostEventAtLocation, ReturnValue) == 0x000040, "Member 'AkGameplayStatics_PostEventAtLocation::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.PostEventOutdoors
// 0x0020 (0x0020 - 0x0000)
struct AkGameplayStatics_PostEventOutdoors final
{
public:
	class UAkAudioEvent*                          AkEvent;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallbackMask;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> PostEventCallback;                                 // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_PostEventOutdoors) == 0x000008, "Wrong alignment on AkGameplayStatics_PostEventOutdoors");
static_assert(sizeof(AkGameplayStatics_PostEventOutdoors) == 0x000020, "Wrong size on AkGameplayStatics_PostEventOutdoors");
static_assert(offsetof(AkGameplayStatics_PostEventOutdoors, AkEvent) == 0x000000, "Member 'AkGameplayStatics_PostEventOutdoors::AkEvent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostEventOutdoors, CallbackMask) == 0x000008, "Member 'AkGameplayStatics_PostEventOutdoors::CallbackMask' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostEventOutdoors, PostEventCallback) == 0x00000C, "Member 'AkGameplayStatics_PostEventOutdoors::PostEventCallback' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostEventOutdoors, ReturnValue) == 0x00001C, "Member 'AkGameplayStatics_PostEventOutdoors::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.PostTrigger
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_PostTrigger final
{
public:
	class UAkTrigger*                             TriggerValue;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_PostTrigger) == 0x000008, "Wrong alignment on AkGameplayStatics_PostTrigger");
static_assert(sizeof(AkGameplayStatics_PostTrigger) == 0x000010, "Wrong size on AkGameplayStatics_PostTrigger");
static_assert(offsetof(AkGameplayStatics_PostTrigger, TriggerValue) == 0x000000, "Member 'AkGameplayStatics_PostTrigger::TriggerValue' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_PostTrigger, Actor) == 0x000008, "Member 'AkGameplayStatics_PostTrigger::Actor' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.RemoveOutput
// 0x0008 (0x0008 - 0x0000)
struct AkGameplayStatics_RemoveOutput final
{
public:
	struct FAkOutputDeviceID                      in_OutputDeviceId;                                 // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_RemoveOutput) == 0x000008, "Wrong alignment on AkGameplayStatics_RemoveOutput");
static_assert(sizeof(AkGameplayStatics_RemoveOutput) == 0x000008, "Wrong size on AkGameplayStatics_RemoveOutput");
static_assert(offsetof(AkGameplayStatics_RemoveOutput, in_OutputDeviceId) == 0x000000, "Member 'AkGameplayStatics_RemoveOutput::in_OutputDeviceId' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.ReplaceMainOutput
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_ReplaceMainOutput final
{
public:
	struct FAkOutputSettings                      MainOutputSettings;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_ReplaceMainOutput) == 0x000008, "Wrong alignment on AkGameplayStatics_ReplaceMainOutput");
static_assert(sizeof(AkGameplayStatics_ReplaceMainOutput) == 0x000010, "Wrong size on AkGameplayStatics_ReplaceMainOutput");
static_assert(offsetof(AkGameplayStatics_ReplaceMainOutput, MainOutputSettings) == 0x000000, "Member 'AkGameplayStatics_ReplaceMainOutput::MainOutputSettings' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.ResetRTPCValue
// 0x0018 (0x0018 - 0x0000)
struct AkGameplayStatics_ResetRTPCValue final
{
public:
	class UAkRtpc*                                RTPCValue;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterpolationTimeMs;                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_ResetRTPCValue) == 0x000008, "Wrong alignment on AkGameplayStatics_ResetRTPCValue");
static_assert(sizeof(AkGameplayStatics_ResetRTPCValue) == 0x000018, "Wrong size on AkGameplayStatics_ResetRTPCValue");
static_assert(offsetof(AkGameplayStatics_ResetRTPCValue, RTPCValue) == 0x000000, "Member 'AkGameplayStatics_ResetRTPCValue::RTPCValue' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_ResetRTPCValue, InterpolationTimeMs) == 0x000008, "Member 'AkGameplayStatics_ResetRTPCValue::InterpolationTimeMs' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_ResetRTPCValue, Actor) == 0x000010, "Member 'AkGameplayStatics_ResetRTPCValue::Actor' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetActorMixerEffect
// 0x0018 (0x0018 - 0x0000)
struct AkGameplayStatics_SetActorMixerEffect final
{
public:
	struct FAkUniqueID                            InAudioNodeID;                                     // 0x0000(0x0004)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         InEffectIndex;                                     // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAkEffectShareSet*                InEffectShareSet;                                  // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetActorMixerEffect) == 0x000008, "Wrong alignment on AkGameplayStatics_SetActorMixerEffect");
static_assert(sizeof(AkGameplayStatics_SetActorMixerEffect) == 0x000018, "Wrong size on AkGameplayStatics_SetActorMixerEffect");
static_assert(offsetof(AkGameplayStatics_SetActorMixerEffect, InAudioNodeID) == 0x000000, "Member 'AkGameplayStatics_SetActorMixerEffect::InAudioNodeID' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetActorMixerEffect, InEffectIndex) == 0x000004, "Member 'AkGameplayStatics_SetActorMixerEffect::InEffectIndex' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetActorMixerEffect, InEffectShareSet) == 0x000008, "Member 'AkGameplayStatics_SetActorMixerEffect::InEffectShareSet' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetActorMixerEffect, ReturnValue) == 0x000010, "Member 'AkGameplayStatics_SetActorMixerEffect::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetAuxBusEffect
// 0x0020 (0x0020 - 0x0000)
struct AkGameplayStatics_SetAuxBusEffect final
{
public:
	const class UAkAuxBus*                        InAuxBus;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InEffectIndex;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UAkEffectShareSet*                InEffectShareSet;                                  // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetAuxBusEffect) == 0x000008, "Wrong alignment on AkGameplayStatics_SetAuxBusEffect");
static_assert(sizeof(AkGameplayStatics_SetAuxBusEffect) == 0x000020, "Wrong size on AkGameplayStatics_SetAuxBusEffect");
static_assert(offsetof(AkGameplayStatics_SetAuxBusEffect, InAuxBus) == 0x000000, "Member 'AkGameplayStatics_SetAuxBusEffect::InAuxBus' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetAuxBusEffect, InEffectIndex) == 0x000008, "Member 'AkGameplayStatics_SetAuxBusEffect::InEffectIndex' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetAuxBusEffect, InEffectShareSet) == 0x000010, "Member 'AkGameplayStatics_SetAuxBusEffect::InEffectShareSet' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetAuxBusEffect, ReturnValue) == 0x000018, "Member 'AkGameplayStatics_SetAuxBusEffect::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetBusConfig
// 0x0018 (0x0018 - 0x0000)
struct AkGameplayStatics_SetBusConfig final
{
public:
	class FString                                 BusName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkChannelConfiguration                       ChannelConfiguration;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetBusConfig) == 0x000008, "Wrong alignment on AkGameplayStatics_SetBusConfig");
static_assert(sizeof(AkGameplayStatics_SetBusConfig) == 0x000018, "Wrong size on AkGameplayStatics_SetBusConfig");
static_assert(offsetof(AkGameplayStatics_SetBusConfig, BusName) == 0x000000, "Member 'AkGameplayStatics_SetBusConfig::BusName' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetBusConfig, ChannelConfiguration) == 0x000010, "Member 'AkGameplayStatics_SetBusConfig::ChannelConfiguration' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetBusEffectByID
// 0x0018 (0x0018 - 0x0000)
struct AkGameplayStatics_SetBusEffectByID final
{
public:
	struct FAkUniqueID                            InBusID;                                           // 0x0000(0x0004)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         InEffectIndex;                                     // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAkEffectShareSet*                InEffectShareSet;                                  // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetBusEffectByID) == 0x000008, "Wrong alignment on AkGameplayStatics_SetBusEffectByID");
static_assert(sizeof(AkGameplayStatics_SetBusEffectByID) == 0x000018, "Wrong size on AkGameplayStatics_SetBusEffectByID");
static_assert(offsetof(AkGameplayStatics_SetBusEffectByID, InBusID) == 0x000000, "Member 'AkGameplayStatics_SetBusEffectByID::InBusID' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetBusEffectByID, InEffectIndex) == 0x000004, "Member 'AkGameplayStatics_SetBusEffectByID::InEffectIndex' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetBusEffectByID, InEffectShareSet) == 0x000008, "Member 'AkGameplayStatics_SetBusEffectByID::InEffectShareSet' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetBusEffectByID, ReturnValue) == 0x000010, "Member 'AkGameplayStatics_SetBusEffectByID::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetBusEffectByName
// 0x0028 (0x0028 - 0x0000)
struct AkGameplayStatics_SetBusEffectByName final
{
public:
	class FString                                 InBusName;                                         // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InEffectIndex;                                     // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UAkEffectShareSet*                InEffectShareSet;                                  // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetBusEffectByName) == 0x000008, "Wrong alignment on AkGameplayStatics_SetBusEffectByName");
static_assert(sizeof(AkGameplayStatics_SetBusEffectByName) == 0x000028, "Wrong size on AkGameplayStatics_SetBusEffectByName");
static_assert(offsetof(AkGameplayStatics_SetBusEffectByName, InBusName) == 0x000000, "Member 'AkGameplayStatics_SetBusEffectByName::InBusName' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetBusEffectByName, InEffectIndex) == 0x000010, "Member 'AkGameplayStatics_SetBusEffectByName::InEffectIndex' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetBusEffectByName, InEffectShareSet) == 0x000018, "Member 'AkGameplayStatics_SetBusEffectByName::InEffectShareSet' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetBusEffectByName, ReturnValue) == 0x000020, "Member 'AkGameplayStatics_SetBusEffectByName::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetCurrentAudioCulture
// 0x0030 (0x0030 - 0x0000)
struct AkGameplayStatics_SetCurrentAudioCulture final
{
public:
	class FString                                 AudioCulture;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0010(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0028(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetCurrentAudioCulture) == 0x000008, "Wrong alignment on AkGameplayStatics_SetCurrentAudioCulture");
static_assert(sizeof(AkGameplayStatics_SetCurrentAudioCulture) == 0x000030, "Wrong size on AkGameplayStatics_SetCurrentAudioCulture");
static_assert(offsetof(AkGameplayStatics_SetCurrentAudioCulture, AudioCulture) == 0x000000, "Member 'AkGameplayStatics_SetCurrentAudioCulture::AudioCulture' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetCurrentAudioCulture, LatentInfo) == 0x000010, "Member 'AkGameplayStatics_SetCurrentAudioCulture::LatentInfo' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetCurrentAudioCulture, WorldContextObject) == 0x000028, "Member 'AkGameplayStatics_SetCurrentAudioCulture::WorldContextObject' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetCurrentAudioCultureAsync
// 0x0020 (0x0020 - 0x0000)
struct AkGameplayStatics_SetCurrentAudioCultureAsync final
{
public:
	class FString                                 AudioCulture;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool Succeeded)>               Completed;                                         // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetCurrentAudioCultureAsync) == 0x000008, "Wrong alignment on AkGameplayStatics_SetCurrentAudioCultureAsync");
static_assert(sizeof(AkGameplayStatics_SetCurrentAudioCultureAsync) == 0x000020, "Wrong size on AkGameplayStatics_SetCurrentAudioCultureAsync");
static_assert(offsetof(AkGameplayStatics_SetCurrentAudioCultureAsync, AudioCulture) == 0x000000, "Member 'AkGameplayStatics_SetCurrentAudioCultureAsync::AudioCulture' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetCurrentAudioCultureAsync, Completed) == 0x000010, "Member 'AkGameplayStatics_SetCurrentAudioCultureAsync::Completed' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetDiffractionOrder
// 0x0008 (0x0008 - 0x0000)
struct AkGameplayStatics_SetDiffractionOrder final
{
public:
	int32                                         InDiffractionOrder;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInUpdatePaths;                                    // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetDiffractionOrder) == 0x000004, "Wrong alignment on AkGameplayStatics_SetDiffractionOrder");
static_assert(sizeof(AkGameplayStatics_SetDiffractionOrder) == 0x000008, "Wrong size on AkGameplayStatics_SetDiffractionOrder");
static_assert(offsetof(AkGameplayStatics_SetDiffractionOrder, InDiffractionOrder) == 0x000000, "Member 'AkGameplayStatics_SetDiffractionOrder::InDiffractionOrder' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetDiffractionOrder, bInUpdatePaths) == 0x000004, "Member 'AkGameplayStatics_SetDiffractionOrder::bInUpdatePaths' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetDistanceProbe
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_SetDistanceProbe final
{
public:
	class AActor*                                 Listener;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DistanceProbe;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetDistanceProbe) == 0x000008, "Wrong alignment on AkGameplayStatics_SetDistanceProbe");
static_assert(sizeof(AkGameplayStatics_SetDistanceProbe) == 0x000010, "Wrong size on AkGameplayStatics_SetDistanceProbe");
static_assert(offsetof(AkGameplayStatics_SetDistanceProbe, Listener) == 0x000000, "Member 'AkGameplayStatics_SetDistanceProbe::Listener' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetDistanceProbe, DistanceProbe) == 0x000008, "Member 'AkGameplayStatics_SetDistanceProbe::DistanceProbe' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetGameObjectToPortalObstruction
// 0x0018 (0x0018 - 0x0000)
struct AkGameplayStatics_SetGameObjectToPortalObstruction final
{
public:
	class UAkComponent*                           GameObjectAkComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkPortalComponent*                     PortalComponent;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObstructionValue;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetGameObjectToPortalObstruction) == 0x000008, "Wrong alignment on AkGameplayStatics_SetGameObjectToPortalObstruction");
static_assert(sizeof(AkGameplayStatics_SetGameObjectToPortalObstruction) == 0x000018, "Wrong size on AkGameplayStatics_SetGameObjectToPortalObstruction");
static_assert(offsetof(AkGameplayStatics_SetGameObjectToPortalObstruction, GameObjectAkComponent) == 0x000000, "Member 'AkGameplayStatics_SetGameObjectToPortalObstruction::GameObjectAkComponent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetGameObjectToPortalObstruction, PortalComponent) == 0x000008, "Member 'AkGameplayStatics_SetGameObjectToPortalObstruction::PortalComponent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetGameObjectToPortalObstruction, ObstructionValue) == 0x000010, "Member 'AkGameplayStatics_SetGameObjectToPortalObstruction::ObstructionValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetLoadBalancingSpread
// 0x0004 (0x0004 - 0x0000)
struct AkGameplayStatics_SetLoadBalancingSpread final
{
public:
	int32                                         InNbFrames;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetLoadBalancingSpread) == 0x000004, "Wrong alignment on AkGameplayStatics_SetLoadBalancingSpread");
static_assert(sizeof(AkGameplayStatics_SetLoadBalancingSpread) == 0x000004, "Wrong size on AkGameplayStatics_SetLoadBalancingSpread");
static_assert(offsetof(AkGameplayStatics_SetLoadBalancingSpread, InNbFrames) == 0x000000, "Member 'AkGameplayStatics_SetLoadBalancingSpread::InNbFrames' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetMaxDiffractionPaths
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_SetMaxDiffractionPaths final
{
public:
	int32                                         InMaxDiffractionPaths;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkGameObject*                          InGameObject;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetMaxDiffractionPaths) == 0x000008, "Wrong alignment on AkGameplayStatics_SetMaxDiffractionPaths");
static_assert(sizeof(AkGameplayStatics_SetMaxDiffractionPaths) == 0x000010, "Wrong size on AkGameplayStatics_SetMaxDiffractionPaths");
static_assert(offsetof(AkGameplayStatics_SetMaxDiffractionPaths, InMaxDiffractionPaths) == 0x000000, "Member 'AkGameplayStatics_SetMaxDiffractionPaths::InMaxDiffractionPaths' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetMaxDiffractionPaths, InGameObject) == 0x000008, "Member 'AkGameplayStatics_SetMaxDiffractionPaths::InGameObject' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetMaxEmitterRoomAuxSends
// 0x0004 (0x0004 - 0x0000)
struct AkGameplayStatics_SetMaxEmitterRoomAuxSends final
{
public:
	int32                                         InMaxEmitterRoomAuxSends;                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetMaxEmitterRoomAuxSends) == 0x000004, "Wrong alignment on AkGameplayStatics_SetMaxEmitterRoomAuxSends");
static_assert(sizeof(AkGameplayStatics_SetMaxEmitterRoomAuxSends) == 0x000004, "Wrong size on AkGameplayStatics_SetMaxEmitterRoomAuxSends");
static_assert(offsetof(AkGameplayStatics_SetMaxEmitterRoomAuxSends, InMaxEmitterRoomAuxSends) == 0x000000, "Member 'AkGameplayStatics_SetMaxEmitterRoomAuxSends::InMaxEmitterRoomAuxSends' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetMaxGlobalReflectionPaths
// 0x0004 (0x0004 - 0x0000)
struct AkGameplayStatics_SetMaxGlobalReflectionPaths final
{
public:
	int32                                         InMaxReflectionPaths;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetMaxGlobalReflectionPaths) == 0x000004, "Wrong alignment on AkGameplayStatics_SetMaxGlobalReflectionPaths");
static_assert(sizeof(AkGameplayStatics_SetMaxGlobalReflectionPaths) == 0x000004, "Wrong size on AkGameplayStatics_SetMaxGlobalReflectionPaths");
static_assert(offsetof(AkGameplayStatics_SetMaxGlobalReflectionPaths, InMaxReflectionPaths) == 0x000000, "Member 'AkGameplayStatics_SetMaxGlobalReflectionPaths::InMaxReflectionPaths' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetMultipleChannelEmitterPositions
// 0x0030 (0x0030 - 0x0000)
struct AkGameplayStatics_SetMultipleChannelEmitterPositions final
{
public:
	class UAkComponent*                           GameObjectAkComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EAkChannelConfiguration>               ChannelMasks;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Positions;                                         // 0x0018(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	EAkMultiPositionType                          MultiPositionType;                                 // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetMultipleChannelEmitterPositions) == 0x000008, "Wrong alignment on AkGameplayStatics_SetMultipleChannelEmitterPositions");
static_assert(sizeof(AkGameplayStatics_SetMultipleChannelEmitterPositions) == 0x000030, "Wrong size on AkGameplayStatics_SetMultipleChannelEmitterPositions");
static_assert(offsetof(AkGameplayStatics_SetMultipleChannelEmitterPositions, GameObjectAkComponent) == 0x000000, "Member 'AkGameplayStatics_SetMultipleChannelEmitterPositions::GameObjectAkComponent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetMultipleChannelEmitterPositions, ChannelMasks) == 0x000008, "Member 'AkGameplayStatics_SetMultipleChannelEmitterPositions::ChannelMasks' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetMultipleChannelEmitterPositions, Positions) == 0x000018, "Member 'AkGameplayStatics_SetMultipleChannelEmitterPositions::Positions' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetMultipleChannelEmitterPositions, MultiPositionType) == 0x000028, "Member 'AkGameplayStatics_SetMultipleChannelEmitterPositions::MultiPositionType' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetMultipleChannelMaskEmitterPositions
// 0x0030 (0x0030 - 0x0000)
struct AkGameplayStatics_SetMultipleChannelMaskEmitterPositions final
{
public:
	class UAkComponent*                           GameObjectAkComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAkChannelMask>                 ChannelMasks;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Positions;                                         // 0x0018(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	EAkMultiPositionType                          MultiPositionType;                                 // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetMultipleChannelMaskEmitterPositions) == 0x000008, "Wrong alignment on AkGameplayStatics_SetMultipleChannelMaskEmitterPositions");
static_assert(sizeof(AkGameplayStatics_SetMultipleChannelMaskEmitterPositions) == 0x000030, "Wrong size on AkGameplayStatics_SetMultipleChannelMaskEmitterPositions");
static_assert(offsetof(AkGameplayStatics_SetMultipleChannelMaskEmitterPositions, GameObjectAkComponent) == 0x000000, "Member 'AkGameplayStatics_SetMultipleChannelMaskEmitterPositions::GameObjectAkComponent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetMultipleChannelMaskEmitterPositions, ChannelMasks) == 0x000008, "Member 'AkGameplayStatics_SetMultipleChannelMaskEmitterPositions::ChannelMasks' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetMultipleChannelMaskEmitterPositions, Positions) == 0x000018, "Member 'AkGameplayStatics_SetMultipleChannelMaskEmitterPositions::Positions' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetMultipleChannelMaskEmitterPositions, MultiPositionType) == 0x000028, "Member 'AkGameplayStatics_SetMultipleChannelMaskEmitterPositions::MultiPositionType' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetMultiplePositions
// 0x0020 (0x0020 - 0x0000)
struct AkGameplayStatics_SetMultiplePositions final
{
public:
	class UAkComponent*                           GameObjectAkComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Positions;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	EAkMultiPositionType                          MultiPositionType;                                 // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetMultiplePositions) == 0x000008, "Wrong alignment on AkGameplayStatics_SetMultiplePositions");
static_assert(sizeof(AkGameplayStatics_SetMultiplePositions) == 0x000020, "Wrong size on AkGameplayStatics_SetMultiplePositions");
static_assert(offsetof(AkGameplayStatics_SetMultiplePositions, GameObjectAkComponent) == 0x000000, "Member 'AkGameplayStatics_SetMultiplePositions::GameObjectAkComponent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetMultiplePositions, Positions) == 0x000008, "Member 'AkGameplayStatics_SetMultiplePositions::Positions' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetMultiplePositions, MultiPositionType) == 0x000018, "Member 'AkGameplayStatics_SetMultiplePositions::MultiPositionType' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetNumberOfPrimaryRays
// 0x0004 (0x0004 - 0x0000)
struct AkGameplayStatics_SetNumberOfPrimaryRays final
{
public:
	int32                                         InNbPrimaryRays;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetNumberOfPrimaryRays) == 0x000004, "Wrong alignment on AkGameplayStatics_SetNumberOfPrimaryRays");
static_assert(sizeof(AkGameplayStatics_SetNumberOfPrimaryRays) == 0x000004, "Wrong size on AkGameplayStatics_SetNumberOfPrimaryRays");
static_assert(offsetof(AkGameplayStatics_SetNumberOfPrimaryRays, InNbPrimaryRays) == 0x000000, "Member 'AkGameplayStatics_SetNumberOfPrimaryRays::InNbPrimaryRays' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetOcclusionRefreshInterval
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_SetOcclusionRefreshInterval final
{
public:
	float                                         RefreshInterval;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetOcclusionRefreshInterval) == 0x000008, "Wrong alignment on AkGameplayStatics_SetOcclusionRefreshInterval");
static_assert(sizeof(AkGameplayStatics_SetOcclusionRefreshInterval) == 0x000010, "Wrong size on AkGameplayStatics_SetOcclusionRefreshInterval");
static_assert(offsetof(AkGameplayStatics_SetOcclusionRefreshInterval, RefreshInterval) == 0x000000, "Member 'AkGameplayStatics_SetOcclusionRefreshInterval::RefreshInterval' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetOcclusionRefreshInterval, Actor) == 0x000008, "Member 'AkGameplayStatics_SetOcclusionRefreshInterval::Actor' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetOutdoorsRoomParameters
// 0x0018 (0x0018 - 0x0000)
struct AkGameplayStatics_SetOutdoorsRoomParameters final
{
public:
	struct FAkOutdoorsRoomParameters              InOutdoorsRoomParameters;                          // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetOutdoorsRoomParameters) == 0x000008, "Wrong alignment on AkGameplayStatics_SetOutdoorsRoomParameters");
static_assert(sizeof(AkGameplayStatics_SetOutdoorsRoomParameters) == 0x000018, "Wrong size on AkGameplayStatics_SetOutdoorsRoomParameters");
static_assert(offsetof(AkGameplayStatics_SetOutdoorsRoomParameters, InOutdoorsRoomParameters) == 0x000000, "Member 'AkGameplayStatics_SetOutdoorsRoomParameters::InOutdoorsRoomParameters' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetOutputBusVolume
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_SetOutputBusVolume final
{
public:
	float                                         BusVolume;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetOutputBusVolume) == 0x000008, "Wrong alignment on AkGameplayStatics_SetOutputBusVolume");
static_assert(sizeof(AkGameplayStatics_SetOutputBusVolume) == 0x000010, "Wrong size on AkGameplayStatics_SetOutputBusVolume");
static_assert(offsetof(AkGameplayStatics_SetOutputBusVolume, BusVolume) == 0x000000, "Member 'AkGameplayStatics_SetOutputBusVolume::BusVolume' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetOutputBusVolume, Actor) == 0x000008, "Member 'AkGameplayStatics_SetOutputBusVolume::Actor' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetOutputDeviceEffect
// 0x0020 (0x0020 - 0x0000)
struct AkGameplayStatics_SetOutputDeviceEffect final
{
public:
	struct FAkOutputDeviceID                      InDeviceId;                                        // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         InEffectIndex;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UAkEffectShareSet*                InEffectShareSet;                                  // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetOutputDeviceEffect) == 0x000008, "Wrong alignment on AkGameplayStatics_SetOutputDeviceEffect");
static_assert(sizeof(AkGameplayStatics_SetOutputDeviceEffect) == 0x000020, "Wrong size on AkGameplayStatics_SetOutputDeviceEffect");
static_assert(offsetof(AkGameplayStatics_SetOutputDeviceEffect, InDeviceId) == 0x000000, "Member 'AkGameplayStatics_SetOutputDeviceEffect::InDeviceId' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetOutputDeviceEffect, InEffectIndex) == 0x000008, "Member 'AkGameplayStatics_SetOutputDeviceEffect::InEffectIndex' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetOutputDeviceEffect, InEffectShareSet) == 0x000010, "Member 'AkGameplayStatics_SetOutputDeviceEffect::InEffectShareSet' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetOutputDeviceEffect, ReturnValue) == 0x000018, "Member 'AkGameplayStatics_SetOutputDeviceEffect::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetPanningRule
// 0x0001 (0x0001 - 0x0000)
struct AkGameplayStatics_SetPanningRule final
{
public:
	EPanningRule                                  PanRule;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetPanningRule) == 0x000001, "Wrong alignment on AkGameplayStatics_SetPanningRule");
static_assert(sizeof(AkGameplayStatics_SetPanningRule) == 0x000001, "Wrong size on AkGameplayStatics_SetPanningRule");
static_assert(offsetof(AkGameplayStatics_SetPanningRule, PanRule) == 0x000000, "Member 'AkGameplayStatics_SetPanningRule::PanRule' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetPortalObstructionAndOcclusion
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_SetPortalObstructionAndOcclusion final
{
public:
	class UAkPortalComponent*                     PortalComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObstructionValue;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionValue;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetPortalObstructionAndOcclusion) == 0x000008, "Wrong alignment on AkGameplayStatics_SetPortalObstructionAndOcclusion");
static_assert(sizeof(AkGameplayStatics_SetPortalObstructionAndOcclusion) == 0x000010, "Wrong size on AkGameplayStatics_SetPortalObstructionAndOcclusion");
static_assert(offsetof(AkGameplayStatics_SetPortalObstructionAndOcclusion, PortalComponent) == 0x000000, "Member 'AkGameplayStatics_SetPortalObstructionAndOcclusion::PortalComponent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetPortalObstructionAndOcclusion, ObstructionValue) == 0x000008, "Member 'AkGameplayStatics_SetPortalObstructionAndOcclusion::ObstructionValue' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetPortalObstructionAndOcclusion, OcclusionValue) == 0x00000C, "Member 'AkGameplayStatics_SetPortalObstructionAndOcclusion::OcclusionValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetPortalToPortalObstruction
// 0x0018 (0x0018 - 0x0000)
struct AkGameplayStatics_SetPortalToPortalObstruction final
{
public:
	class UAkPortalComponent*                     PortalComponent0;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkPortalComponent*                     PortalComponent1;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObstructionValue;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetPortalToPortalObstruction) == 0x000008, "Wrong alignment on AkGameplayStatics_SetPortalToPortalObstruction");
static_assert(sizeof(AkGameplayStatics_SetPortalToPortalObstruction) == 0x000018, "Wrong size on AkGameplayStatics_SetPortalToPortalObstruction");
static_assert(offsetof(AkGameplayStatics_SetPortalToPortalObstruction, PortalComponent0) == 0x000000, "Member 'AkGameplayStatics_SetPortalToPortalObstruction::PortalComponent0' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetPortalToPortalObstruction, PortalComponent1) == 0x000008, "Member 'AkGameplayStatics_SetPortalToPortalObstruction::PortalComponent1' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetPortalToPortalObstruction, ObstructionValue) == 0x000010, "Member 'AkGameplayStatics_SetPortalToPortalObstruction::ObstructionValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetReflectionsOrder
// 0x0008 (0x0008 - 0x0000)
struct AkGameplayStatics_SetReflectionsOrder final
{
public:
	int32                                         Order;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RefreshPaths;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGameplayStatics_SetReflectionsOrder) == 0x000004, "Wrong alignment on AkGameplayStatics_SetReflectionsOrder");
static_assert(sizeof(AkGameplayStatics_SetReflectionsOrder) == 0x000008, "Wrong size on AkGameplayStatics_SetReflectionsOrder");
static_assert(offsetof(AkGameplayStatics_SetReflectionsOrder, Order) == 0x000000, "Member 'AkGameplayStatics_SetReflectionsOrder::Order' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetReflectionsOrder, RefreshPaths) == 0x000004, "Member 'AkGameplayStatics_SetReflectionsOrder::RefreshPaths' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetRTPCValue
// 0x0018 (0x0018 - 0x0000)
struct AkGameplayStatics_SetRTPCValue final
{
public:
	class UAkRtpc*                                RTPCValue;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterpolationTimeMs;                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetRTPCValue) == 0x000008, "Wrong alignment on AkGameplayStatics_SetRTPCValue");
static_assert(sizeof(AkGameplayStatics_SetRTPCValue) == 0x000018, "Wrong size on AkGameplayStatics_SetRTPCValue");
static_assert(offsetof(AkGameplayStatics_SetRTPCValue, RTPCValue) == 0x000000, "Member 'AkGameplayStatics_SetRTPCValue::RTPCValue' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetRTPCValue, Value) == 0x000008, "Member 'AkGameplayStatics_SetRTPCValue::Value' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetRTPCValue, InterpolationTimeMs) == 0x00000C, "Member 'AkGameplayStatics_SetRTPCValue::InterpolationTimeMs' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetRTPCValue, Actor) == 0x000010, "Member 'AkGameplayStatics_SetRTPCValue::Actor' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetSmoothingConstant
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_SetSmoothingConstant final
{
public:
	float                                         InSmoothingConstantMs;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkGameObject*                          InGameObject;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetSmoothingConstant) == 0x000008, "Wrong alignment on AkGameplayStatics_SetSmoothingConstant");
static_assert(sizeof(AkGameplayStatics_SetSmoothingConstant) == 0x000010, "Wrong size on AkGameplayStatics_SetSmoothingConstant");
static_assert(offsetof(AkGameplayStatics_SetSmoothingConstant, InSmoothingConstantMs) == 0x000000, "Member 'AkGameplayStatics_SetSmoothingConstant::InSmoothingConstantMs' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetSmoothingConstant, InGameObject) == 0x000008, "Member 'AkGameplayStatics_SetSmoothingConstant::InGameObject' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetSpeakerAngles
// 0x0028 (0x0028 - 0x0000)
struct AkGameplayStatics_SetSpeakerAngles final
{
public:
	TArray<float>                                 SpeakerAngles;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         HeightAngle;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DeviceShareSet;                                    // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetSpeakerAngles) == 0x000008, "Wrong alignment on AkGameplayStatics_SetSpeakerAngles");
static_assert(sizeof(AkGameplayStatics_SetSpeakerAngles) == 0x000028, "Wrong size on AkGameplayStatics_SetSpeakerAngles");
static_assert(offsetof(AkGameplayStatics_SetSpeakerAngles, SpeakerAngles) == 0x000000, "Member 'AkGameplayStatics_SetSpeakerAngles::SpeakerAngles' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetSpeakerAngles, HeightAngle) == 0x000010, "Member 'AkGameplayStatics_SetSpeakerAngles::HeightAngle' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetSpeakerAngles, DeviceShareSet) == 0x000018, "Member 'AkGameplayStatics_SetSpeakerAngles::DeviceShareSet' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetState
// 0x0008 (0x0008 - 0x0000)
struct AkGameplayStatics_SetState final
{
public:
	class UAkStateValue*                          StateValue;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetState) == 0x000008, "Wrong alignment on AkGameplayStatics_SetState");
static_assert(sizeof(AkGameplayStatics_SetState) == 0x000008, "Wrong size on AkGameplayStatics_SetState");
static_assert(offsetof(AkGameplayStatics_SetState, StateValue) == 0x000000, "Member 'AkGameplayStatics_SetState::StateValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SetSwitch
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_SetSwitch final
{
public:
	class UAkSwitchValue*                         SwitchValue;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SetSwitch) == 0x000008, "Wrong alignment on AkGameplayStatics_SetSwitch");
static_assert(sizeof(AkGameplayStatics_SetSwitch) == 0x000010, "Wrong size on AkGameplayStatics_SetSwitch");
static_assert(offsetof(AkGameplayStatics_SetSwitch, SwitchValue) == 0x000000, "Member 'AkGameplayStatics_SetSwitch::SwitchValue' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SetSwitch, Actor) == 0x000008, "Member 'AkGameplayStatics_SetSwitch::Actor' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.SpawnAkComponentAtLocation
// 0x0050 (0x0050 - 0x0000)
struct AkGameplayStatics_SpawnAkComponentAtLocation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          AutoPost;                                          // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoDestroy;                                       // 0x0041(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           ReturnValue;                                       // 0x0048(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_SpawnAkComponentAtLocation) == 0x000008, "Wrong alignment on AkGameplayStatics_SpawnAkComponentAtLocation");
static_assert(sizeof(AkGameplayStatics_SpawnAkComponentAtLocation) == 0x000050, "Wrong size on AkGameplayStatics_SpawnAkComponentAtLocation");
static_assert(offsetof(AkGameplayStatics_SpawnAkComponentAtLocation, WorldContextObject) == 0x000000, "Member 'AkGameplayStatics_SpawnAkComponentAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SpawnAkComponentAtLocation, AkEvent) == 0x000008, "Member 'AkGameplayStatics_SpawnAkComponentAtLocation::AkEvent' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SpawnAkComponentAtLocation, Location) == 0x000010, "Member 'AkGameplayStatics_SpawnAkComponentAtLocation::Location' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SpawnAkComponentAtLocation, Orientation) == 0x000028, "Member 'AkGameplayStatics_SpawnAkComponentAtLocation::Orientation' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SpawnAkComponentAtLocation, AutoPost) == 0x000040, "Member 'AkGameplayStatics_SpawnAkComponentAtLocation::AutoPost' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SpawnAkComponentAtLocation, AutoDestroy) == 0x000041, "Member 'AkGameplayStatics_SpawnAkComponentAtLocation::AutoDestroy' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_SpawnAkComponentAtLocation, ReturnValue) == 0x000048, "Member 'AkGameplayStatics_SpawnAkComponentAtLocation::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.StartAllAmbientSounds
// 0x0008 (0x0008 - 0x0000)
struct AkGameplayStatics_StartAllAmbientSounds final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_StartAllAmbientSounds) == 0x000008, "Wrong alignment on AkGameplayStatics_StartAllAmbientSounds");
static_assert(sizeof(AkGameplayStatics_StartAllAmbientSounds) == 0x000008, "Wrong size on AkGameplayStatics_StartAllAmbientSounds");
static_assert(offsetof(AkGameplayStatics_StartAllAmbientSounds, WorldContextObject) == 0x000000, "Member 'AkGameplayStatics_StartAllAmbientSounds::WorldContextObject' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.StartOutputCapture
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_StartOutputCapture final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_StartOutputCapture) == 0x000008, "Wrong alignment on AkGameplayStatics_StartOutputCapture");
static_assert(sizeof(AkGameplayStatics_StartOutputCapture) == 0x000010, "Wrong size on AkGameplayStatics_StartOutputCapture");
static_assert(offsetof(AkGameplayStatics_StartOutputCapture, Filename) == 0x000000, "Member 'AkGameplayStatics_StartOutputCapture::Filename' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.StartProfilerCapture
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_StartProfilerCapture final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_StartProfilerCapture) == 0x000008, "Wrong alignment on AkGameplayStatics_StartProfilerCapture");
static_assert(sizeof(AkGameplayStatics_StartProfilerCapture) == 0x000010, "Wrong size on AkGameplayStatics_StartProfilerCapture");
static_assert(offsetof(AkGameplayStatics_StartProfilerCapture, Filename) == 0x000000, "Member 'AkGameplayStatics_StartProfilerCapture::Filename' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.StopActor
// 0x0008 (0x0008 - 0x0000)
struct AkGameplayStatics_StopActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_StopActor) == 0x000008, "Wrong alignment on AkGameplayStatics_StopActor");
static_assert(sizeof(AkGameplayStatics_StopActor) == 0x000008, "Wrong size on AkGameplayStatics_StopActor");
static_assert(offsetof(AkGameplayStatics_StopActor, Actor) == 0x000000, "Member 'AkGameplayStatics_StopActor::Actor' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.StopAllAmbientSounds
// 0x0008 (0x0008 - 0x0000)
struct AkGameplayStatics_StopAllAmbientSounds final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_StopAllAmbientSounds) == 0x000008, "Wrong alignment on AkGameplayStatics_StopAllAmbientSounds");
static_assert(sizeof(AkGameplayStatics_StopAllAmbientSounds) == 0x000008, "Wrong size on AkGameplayStatics_StopAllAmbientSounds");
static_assert(offsetof(AkGameplayStatics_StopAllAmbientSounds, WorldContextObject) == 0x000000, "Member 'AkGameplayStatics_StopAllAmbientSounds::WorldContextObject' has a wrong offset!");

// Function AkAudio.AkGameplayStatics.UseReverbVolumes
// 0x0010 (0x0010 - 0x0000)
struct AkGameplayStatics_UseReverbVolumes final
{
public:
	bool                                          inUseReverbVolumes;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGameplayStatics_UseReverbVolumes) == 0x000008, "Wrong alignment on AkGameplayStatics_UseReverbVolumes");
static_assert(sizeof(AkGameplayStatics_UseReverbVolumes) == 0x000010, "Wrong size on AkGameplayStatics_UseReverbVolumes");
static_assert(offsetof(AkGameplayStatics_UseReverbVolumes, inUseReverbVolumes) == 0x000000, "Member 'AkGameplayStatics_UseReverbVolumes::inUseReverbVolumes' has a wrong offset!");
static_assert(offsetof(AkGameplayStatics_UseReverbVolumes, Actor) == 0x000008, "Member 'AkGameplayStatics_UseReverbVolumes::Actor' has a wrong offset!");

// Function AkAudio.AkMIDIEventCallbackInfo.GetCc
// 0x0005 (0x0005 - 0x0000)
struct AkMIDIEventCallbackInfo_GetCc final
{
public:
	struct FAkMidiCc                              AsCc;                                              // 0x0000(0x0004)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkMIDIEventCallbackInfo_GetCc) == 0x000001, "Wrong alignment on AkMIDIEventCallbackInfo_GetCc");
static_assert(sizeof(AkMIDIEventCallbackInfo_GetCc) == 0x000005, "Wrong size on AkMIDIEventCallbackInfo_GetCc");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetCc, AsCc) == 0x000000, "Member 'AkMIDIEventCallbackInfo_GetCc::AsCc' has a wrong offset!");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetCc, ReturnValue) == 0x000004, "Member 'AkMIDIEventCallbackInfo_GetCc::ReturnValue' has a wrong offset!");

// Function AkAudio.AkMIDIEventCallbackInfo.GetChannel
// 0x0001 (0x0001 - 0x0000)
struct AkMIDIEventCallbackInfo_GetChannel final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkMIDIEventCallbackInfo_GetChannel) == 0x000001, "Wrong alignment on AkMIDIEventCallbackInfo_GetChannel");
static_assert(sizeof(AkMIDIEventCallbackInfo_GetChannel) == 0x000001, "Wrong size on AkMIDIEventCallbackInfo_GetChannel");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetChannel, ReturnValue) == 0x000000, "Member 'AkMIDIEventCallbackInfo_GetChannel::ReturnValue' has a wrong offset!");

// Function AkAudio.AkMIDIEventCallbackInfo.GetChannelAftertouch
// 0x0004 (0x0004 - 0x0000)
struct AkMIDIEventCallbackInfo_GetChannelAftertouch final
{
public:
	struct FAkMidiChannelAftertouch               AsChannelAftertouch;                               // 0x0000(0x0003)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0003(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkMIDIEventCallbackInfo_GetChannelAftertouch) == 0x000001, "Wrong alignment on AkMIDIEventCallbackInfo_GetChannelAftertouch");
static_assert(sizeof(AkMIDIEventCallbackInfo_GetChannelAftertouch) == 0x000004, "Wrong size on AkMIDIEventCallbackInfo_GetChannelAftertouch");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetChannelAftertouch, AsChannelAftertouch) == 0x000000, "Member 'AkMIDIEventCallbackInfo_GetChannelAftertouch::AsChannelAftertouch' has a wrong offset!");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetChannelAftertouch, ReturnValue) == 0x000003, "Member 'AkMIDIEventCallbackInfo_GetChannelAftertouch::ReturnValue' has a wrong offset!");

// Function AkAudio.AkMIDIEventCallbackInfo.GetGeneric
// 0x0005 (0x0005 - 0x0000)
struct AkMIDIEventCallbackInfo_GetGeneric final
{
public:
	struct FAkMidiGeneric                         AsGeneric;                                         // 0x0000(0x0004)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkMIDIEventCallbackInfo_GetGeneric) == 0x000001, "Wrong alignment on AkMIDIEventCallbackInfo_GetGeneric");
static_assert(sizeof(AkMIDIEventCallbackInfo_GetGeneric) == 0x000005, "Wrong size on AkMIDIEventCallbackInfo_GetGeneric");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetGeneric, AsGeneric) == 0x000000, "Member 'AkMIDIEventCallbackInfo_GetGeneric::AsGeneric' has a wrong offset!");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetGeneric, ReturnValue) == 0x000004, "Member 'AkMIDIEventCallbackInfo_GetGeneric::ReturnValue' has a wrong offset!");

// Function AkAudio.AkMIDIEventCallbackInfo.GetNoteAftertouch
// 0x0005 (0x0005 - 0x0000)
struct AkMIDIEventCallbackInfo_GetNoteAftertouch final
{
public:
	struct FAkMidiNoteAftertouch                  AsNoteAftertouch;                                  // 0x0000(0x0004)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkMIDIEventCallbackInfo_GetNoteAftertouch) == 0x000001, "Wrong alignment on AkMIDIEventCallbackInfo_GetNoteAftertouch");
static_assert(sizeof(AkMIDIEventCallbackInfo_GetNoteAftertouch) == 0x000005, "Wrong size on AkMIDIEventCallbackInfo_GetNoteAftertouch");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetNoteAftertouch, AsNoteAftertouch) == 0x000000, "Member 'AkMIDIEventCallbackInfo_GetNoteAftertouch::AsNoteAftertouch' has a wrong offset!");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetNoteAftertouch, ReturnValue) == 0x000004, "Member 'AkMIDIEventCallbackInfo_GetNoteAftertouch::ReturnValue' has a wrong offset!");

// Function AkAudio.AkMIDIEventCallbackInfo.GetNoteOff
// 0x0005 (0x0005 - 0x0000)
struct AkMIDIEventCallbackInfo_GetNoteOff final
{
public:
	struct FAkMidiNoteOnOff                       AsNoteOff;                                         // 0x0000(0x0004)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkMIDIEventCallbackInfo_GetNoteOff) == 0x000001, "Wrong alignment on AkMIDIEventCallbackInfo_GetNoteOff");
static_assert(sizeof(AkMIDIEventCallbackInfo_GetNoteOff) == 0x000005, "Wrong size on AkMIDIEventCallbackInfo_GetNoteOff");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetNoteOff, AsNoteOff) == 0x000000, "Member 'AkMIDIEventCallbackInfo_GetNoteOff::AsNoteOff' has a wrong offset!");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetNoteOff, ReturnValue) == 0x000004, "Member 'AkMIDIEventCallbackInfo_GetNoteOff::ReturnValue' has a wrong offset!");

// Function AkAudio.AkMIDIEventCallbackInfo.GetNoteOn
// 0x0005 (0x0005 - 0x0000)
struct AkMIDIEventCallbackInfo_GetNoteOn final
{
public:
	struct FAkMidiNoteOnOff                       AsNoteOn;                                          // 0x0000(0x0004)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkMIDIEventCallbackInfo_GetNoteOn) == 0x000001, "Wrong alignment on AkMIDIEventCallbackInfo_GetNoteOn");
static_assert(sizeof(AkMIDIEventCallbackInfo_GetNoteOn) == 0x000005, "Wrong size on AkMIDIEventCallbackInfo_GetNoteOn");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetNoteOn, AsNoteOn) == 0x000000, "Member 'AkMIDIEventCallbackInfo_GetNoteOn::AsNoteOn' has a wrong offset!");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetNoteOn, ReturnValue) == 0x000004, "Member 'AkMIDIEventCallbackInfo_GetNoteOn::ReturnValue' has a wrong offset!");

// Function AkAudio.AkMIDIEventCallbackInfo.GetPitchBend
// 0x000C (0x000C - 0x0000)
struct AkMIDIEventCallbackInfo_GetPitchBend final
{
public:
	struct FAkMidiPitchBend                       AsPitchBend;                                       // 0x0000(0x0008)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkMIDIEventCallbackInfo_GetPitchBend) == 0x000004, "Wrong alignment on AkMIDIEventCallbackInfo_GetPitchBend");
static_assert(sizeof(AkMIDIEventCallbackInfo_GetPitchBend) == 0x00000C, "Wrong size on AkMIDIEventCallbackInfo_GetPitchBend");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetPitchBend, AsPitchBend) == 0x000000, "Member 'AkMIDIEventCallbackInfo_GetPitchBend::AsPitchBend' has a wrong offset!");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetPitchBend, ReturnValue) == 0x000008, "Member 'AkMIDIEventCallbackInfo_GetPitchBend::ReturnValue' has a wrong offset!");

// Function AkAudio.AkMIDIEventCallbackInfo.GetProgramChange
// 0x0004 (0x0004 - 0x0000)
struct AkMIDIEventCallbackInfo_GetProgramChange final
{
public:
	struct FAkMidiProgramChange                   AsProgramChange;                                   // 0x0000(0x0003)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0003(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkMIDIEventCallbackInfo_GetProgramChange) == 0x000001, "Wrong alignment on AkMIDIEventCallbackInfo_GetProgramChange");
static_assert(sizeof(AkMIDIEventCallbackInfo_GetProgramChange) == 0x000004, "Wrong size on AkMIDIEventCallbackInfo_GetProgramChange");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetProgramChange, AsProgramChange) == 0x000000, "Member 'AkMIDIEventCallbackInfo_GetProgramChange::AsProgramChange' has a wrong offset!");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetProgramChange, ReturnValue) == 0x000003, "Member 'AkMIDIEventCallbackInfo_GetProgramChange::ReturnValue' has a wrong offset!");

// Function AkAudio.AkMIDIEventCallbackInfo.GetType
// 0x0001 (0x0001 - 0x0000)
struct AkMIDIEventCallbackInfo_GetType final
{
public:
	EAkMidiEventType                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkMIDIEventCallbackInfo_GetType) == 0x000001, "Wrong alignment on AkMIDIEventCallbackInfo_GetType");
static_assert(sizeof(AkMIDIEventCallbackInfo_GetType) == 0x000001, "Wrong size on AkMIDIEventCallbackInfo_GetType");
static_assert(offsetof(AkMIDIEventCallbackInfo_GetType, ReturnValue) == 0x000000, "Member 'AkMIDIEventCallbackInfo_GetType::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGeometryComponent.GetAcousticPropertiesOverride
// 0x0028 (0x0028 - 0x0000)
struct AkGeometryComponent_GetAcousticPropertiesOverride final
{
public:
	class UMaterialInterface*                     InMaterialInterface;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkGeometrySurfaceOverride             OutAcousticPropertiesOverride;                     // 0x0008(0x0018)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGeometryComponent_GetAcousticPropertiesOverride) == 0x000008, "Wrong alignment on AkGeometryComponent_GetAcousticPropertiesOverride");
static_assert(sizeof(AkGeometryComponent_GetAcousticPropertiesOverride) == 0x000028, "Wrong size on AkGeometryComponent_GetAcousticPropertiesOverride");
static_assert(offsetof(AkGeometryComponent_GetAcousticPropertiesOverride, InMaterialInterface) == 0x000000, "Member 'AkGeometryComponent_GetAcousticPropertiesOverride::InMaterialInterface' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_GetAcousticPropertiesOverride, OutAcousticPropertiesOverride) == 0x000008, "Member 'AkGeometryComponent_GetAcousticPropertiesOverride::OutAcousticPropertiesOverride' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_GetAcousticPropertiesOverride, ReturnValue) == 0x000020, "Member 'AkGeometryComponent_GetAcousticPropertiesOverride::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGeometryComponent.SetAcousticPropertiesOverride
// 0x0040 (0x0040 - 0x0000)
struct AkGeometryComponent_SetAcousticPropertiesOverride final
{
public:
	class UMaterialInterface*                     InMaterialInterface;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkGeometrySurfaceOverride             InAcousticPropertiesOverride;                      // 0x0008(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FAkGeometrySurfaceOverride             OutAcousticPropertiesOverride;                     // 0x0020(0x0018)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGeometryComponent_SetAcousticPropertiesOverride) == 0x000008, "Wrong alignment on AkGeometryComponent_SetAcousticPropertiesOverride");
static_assert(sizeof(AkGeometryComponent_SetAcousticPropertiesOverride) == 0x000040, "Wrong size on AkGeometryComponent_SetAcousticPropertiesOverride");
static_assert(offsetof(AkGeometryComponent_SetAcousticPropertiesOverride, InMaterialInterface) == 0x000000, "Member 'AkGeometryComponent_SetAcousticPropertiesOverride::InMaterialInterface' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetAcousticPropertiesOverride, InAcousticPropertiesOverride) == 0x000008, "Member 'AkGeometryComponent_SetAcousticPropertiesOverride::InAcousticPropertiesOverride' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetAcousticPropertiesOverride, OutAcousticPropertiesOverride) == 0x000020, "Member 'AkGeometryComponent_SetAcousticPropertiesOverride::OutAcousticPropertiesOverride' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetAcousticPropertiesOverride, ReturnValue) == 0x000038, "Member 'AkGeometryComponent_SetAcousticPropertiesOverride::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGeometryComponent.SetAcousticTextureOverride
// 0x0030 (0x0030 - 0x0000)
struct AkGeometryComponent_SetAcousticTextureOverride final
{
public:
	class UMaterialInterface*                     InMaterialInterface;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAcousticTexture*                     InAcousticTexture;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkGeometrySurfaceOverride             OutAcousticPropertiesOverride;                     // 0x0010(0x0018)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGeometryComponent_SetAcousticTextureOverride) == 0x000008, "Wrong alignment on AkGeometryComponent_SetAcousticTextureOverride");
static_assert(sizeof(AkGeometryComponent_SetAcousticTextureOverride) == 0x000030, "Wrong size on AkGeometryComponent_SetAcousticTextureOverride");
static_assert(offsetof(AkGeometryComponent_SetAcousticTextureOverride, InMaterialInterface) == 0x000000, "Member 'AkGeometryComponent_SetAcousticTextureOverride::InMaterialInterface' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetAcousticTextureOverride, InAcousticTexture) == 0x000008, "Member 'AkGeometryComponent_SetAcousticTextureOverride::InAcousticTexture' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetAcousticTextureOverride, OutAcousticPropertiesOverride) == 0x000010, "Member 'AkGeometryComponent_SetAcousticTextureOverride::OutAcousticPropertiesOverride' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetAcousticTextureOverride, ReturnValue) == 0x000028, "Member 'AkGeometryComponent_SetAcousticTextureOverride::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGeometryComponent.SetEnableDiffraction
// 0x0002 (0x0002 - 0x0000)
struct AkGeometryComponent_SetEnableDiffraction final
{
public:
	bool                                          bInEnableDiffraction;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInEnableDiffractionOnBoundaryEdges;               // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkGeometryComponent_SetEnableDiffraction) == 0x000001, "Wrong alignment on AkGeometryComponent_SetEnableDiffraction");
static_assert(sizeof(AkGeometryComponent_SetEnableDiffraction) == 0x000002, "Wrong size on AkGeometryComponent_SetEnableDiffraction");
static_assert(offsetof(AkGeometryComponent_SetEnableDiffraction, bInEnableDiffraction) == 0x000000, "Member 'AkGeometryComponent_SetEnableDiffraction::bInEnableDiffraction' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetEnableDiffraction, bInEnableDiffractionOnBoundaryEdges) == 0x000001, "Member 'AkGeometryComponent_SetEnableDiffraction::bInEnableDiffractionOnBoundaryEdges' has a wrong offset!");

// Function AkAudio.AkGeometryComponent.SetEnableTransmissionLossOverride
// 0x0030 (0x0030 - 0x0000)
struct AkGeometryComponent_SetEnableTransmissionLossOverride final
{
public:
	class UMaterialInterface*                     InMaterialInterface;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInEnableTransmissionLossOverride;                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAkGeometrySurfaceOverride             OutAcousticPropertiesOverride;                     // 0x0010(0x0018)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGeometryComponent_SetEnableTransmissionLossOverride) == 0x000008, "Wrong alignment on AkGeometryComponent_SetEnableTransmissionLossOverride");
static_assert(sizeof(AkGeometryComponent_SetEnableTransmissionLossOverride) == 0x000030, "Wrong size on AkGeometryComponent_SetEnableTransmissionLossOverride");
static_assert(offsetof(AkGeometryComponent_SetEnableTransmissionLossOverride, InMaterialInterface) == 0x000000, "Member 'AkGeometryComponent_SetEnableTransmissionLossOverride::InMaterialInterface' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetEnableTransmissionLossOverride, bInEnableTransmissionLossOverride) == 0x000008, "Member 'AkGeometryComponent_SetEnableTransmissionLossOverride::bInEnableTransmissionLossOverride' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetEnableTransmissionLossOverride, OutAcousticPropertiesOverride) == 0x000010, "Member 'AkGeometryComponent_SetEnableTransmissionLossOverride::OutAcousticPropertiesOverride' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetEnableTransmissionLossOverride, ReturnValue) == 0x000028, "Member 'AkGeometryComponent_SetEnableTransmissionLossOverride::ReturnValue' has a wrong offset!");

// Function AkAudio.AkGeometryComponent.SetTransmissionLossOverride
// 0x0030 (0x0030 - 0x0000)
struct AkGeometryComponent_SetTransmissionLossOverride final
{
public:
	class UMaterialInterface*                     InMaterialInterface;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTransmissionLoss;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInEnableTransmissionLossOverride;                 // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAkGeometrySurfaceOverride             OutAcousticPropertiesOverride;                     // 0x0010(0x0018)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkGeometryComponent_SetTransmissionLossOverride) == 0x000008, "Wrong alignment on AkGeometryComponent_SetTransmissionLossOverride");
static_assert(sizeof(AkGeometryComponent_SetTransmissionLossOverride) == 0x000030, "Wrong size on AkGeometryComponent_SetTransmissionLossOverride");
static_assert(offsetof(AkGeometryComponent_SetTransmissionLossOverride, InMaterialInterface) == 0x000000, "Member 'AkGeometryComponent_SetTransmissionLossOverride::InMaterialInterface' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetTransmissionLossOverride, InTransmissionLoss) == 0x000008, "Member 'AkGeometryComponent_SetTransmissionLossOverride::InTransmissionLoss' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetTransmissionLossOverride, bInEnableTransmissionLossOverride) == 0x00000C, "Member 'AkGeometryComponent_SetTransmissionLossOverride::bInEnableTransmissionLossOverride' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetTransmissionLossOverride, OutAcousticPropertiesOverride) == 0x000010, "Member 'AkGeometryComponent_SetTransmissionLossOverride::OutAcousticPropertiesOverride' has a wrong offset!");
static_assert(offsetof(AkGeometryComponent_SetTransmissionLossOverride, ReturnValue) == 0x000028, "Member 'AkGeometryComponent_SetTransmissionLossOverride::ReturnValue' has a wrong offset!");

// Function AkAudio.AkLinuxInitializationSettings.MigrateMultiCoreRendering
// 0x0001 (0x0001 - 0x0000)
struct AkLinuxInitializationSettings_MigrateMultiCoreRendering final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkLinuxInitializationSettings_MigrateMultiCoreRendering) == 0x000001, "Wrong alignment on AkLinuxInitializationSettings_MigrateMultiCoreRendering");
static_assert(sizeof(AkLinuxInitializationSettings_MigrateMultiCoreRendering) == 0x000001, "Wrong size on AkLinuxInitializationSettings_MigrateMultiCoreRendering");
static_assert(offsetof(AkLinuxInitializationSettings_MigrateMultiCoreRendering, NewValue) == 0x000000, "Member 'AkLinuxInitializationSettings_MigrateMultiCoreRendering::NewValue' has a wrong offset!");

// Function AkAudio.AkLateReverbComponent.AssociateAkTextureSetComponent
// 0x0008 (0x0008 - 0x0000)
struct AkLateReverbComponent_AssociateAkTextureSetComponent final
{
public:
	class UAkAcousticTextureSetComponent*         textureSetComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkLateReverbComponent_AssociateAkTextureSetComponent) == 0x000008, "Wrong alignment on AkLateReverbComponent_AssociateAkTextureSetComponent");
static_assert(sizeof(AkLateReverbComponent_AssociateAkTextureSetComponent) == 0x000008, "Wrong size on AkLateReverbComponent_AssociateAkTextureSetComponent");
static_assert(offsetof(AkLateReverbComponent_AssociateAkTextureSetComponent, textureSetComponent) == 0x000000, "Member 'AkLateReverbComponent_AssociateAkTextureSetComponent::textureSetComponent' has a wrong offset!");

// Function AkAudio.AkLateReverbComponent.SetAutoAssignAuxBus
// 0x0001 (0x0001 - 0x0000)
struct AkLateReverbComponent_SetAutoAssignAuxBus final
{
public:
	bool                                          bInEnable;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkLateReverbComponent_SetAutoAssignAuxBus) == 0x000001, "Wrong alignment on AkLateReverbComponent_SetAutoAssignAuxBus");
static_assert(sizeof(AkLateReverbComponent_SetAutoAssignAuxBus) == 0x000001, "Wrong size on AkLateReverbComponent_SetAutoAssignAuxBus");
static_assert(offsetof(AkLateReverbComponent_SetAutoAssignAuxBus, bInEnable) == 0x000000, "Member 'AkLateReverbComponent_SetAutoAssignAuxBus::bInEnable' has a wrong offset!");

// Function AkAudio.AkLinuxArm64InitializationSettings.MigrateMultiCoreRendering
// 0x0001 (0x0001 - 0x0000)
struct AkLinuxArm64InitializationSettings_MigrateMultiCoreRendering final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkLinuxArm64InitializationSettings_MigrateMultiCoreRendering) == 0x000001, "Wrong alignment on AkLinuxArm64InitializationSettings_MigrateMultiCoreRendering");
static_assert(sizeof(AkLinuxArm64InitializationSettings_MigrateMultiCoreRendering) == 0x000001, "Wrong size on AkLinuxArm64InitializationSettings_MigrateMultiCoreRendering");
static_assert(offsetof(AkLinuxArm64InitializationSettings_MigrateMultiCoreRendering, NewValue) == 0x000000, "Member 'AkLinuxArm64InitializationSettings_MigrateMultiCoreRendering::NewValue' has a wrong offset!");

// Function AkAudio.AkMacInitializationSettings.MigrateMultiCoreRendering
// 0x0001 (0x0001 - 0x0000)
struct AkMacInitializationSettings_MigrateMultiCoreRendering final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkMacInitializationSettings_MigrateMultiCoreRendering) == 0x000001, "Wrong alignment on AkMacInitializationSettings_MigrateMultiCoreRendering");
static_assert(sizeof(AkMacInitializationSettings_MigrateMultiCoreRendering) == 0x000001, "Wrong size on AkMacInitializationSettings_MigrateMultiCoreRendering");
static_assert(offsetof(AkMacInitializationSettings_MigrateMultiCoreRendering, NewValue) == 0x000000, "Member 'AkMacInitializationSettings_MigrateMultiCoreRendering::NewValue' has a wrong offset!");

// Function AkAudio.AkSurfaceReflectorSetComponent.SetAcousticTexture
// 0x0020 (0x0020 - 0x0000)
struct AkSurfaceReflectorSetComponent_SetAcousticTexture final
{
public:
	TArray<int32>                                 InSurfaceIndexesToEdit;                            // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UAkAcousticTexture*                     InAcousticTexture;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInEnableSurface;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkSurfaceReflectorSetComponent_SetAcousticTexture) == 0x000008, "Wrong alignment on AkSurfaceReflectorSetComponent_SetAcousticTexture");
static_assert(sizeof(AkSurfaceReflectorSetComponent_SetAcousticTexture) == 0x000020, "Wrong size on AkSurfaceReflectorSetComponent_SetAcousticTexture");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetAcousticTexture, InSurfaceIndexesToEdit) == 0x000000, "Member 'AkSurfaceReflectorSetComponent_SetAcousticTexture::InSurfaceIndexesToEdit' has a wrong offset!");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetAcousticTexture, InAcousticTexture) == 0x000010, "Member 'AkSurfaceReflectorSetComponent_SetAcousticTexture::InAcousticTexture' has a wrong offset!");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetAcousticTexture, bInEnableSurface) == 0x000018, "Member 'AkSurfaceReflectorSetComponent_SetAcousticTexture::bInEnableSurface' has a wrong offset!");

// Function AkAudio.AkSurfaceReflectorSetComponent.SetEnable
// 0x0001 (0x0001 - 0x0000)
struct AkSurfaceReflectorSetComponent_SetEnable final
{
public:
	bool                                          bInEnable;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkSurfaceReflectorSetComponent_SetEnable) == 0x000001, "Wrong alignment on AkSurfaceReflectorSetComponent_SetEnable");
static_assert(sizeof(AkSurfaceReflectorSetComponent_SetEnable) == 0x000001, "Wrong size on AkSurfaceReflectorSetComponent_SetEnable");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetEnable, bInEnable) == 0x000000, "Member 'AkSurfaceReflectorSetComponent_SetEnable::bInEnable' has a wrong offset!");

// Function AkAudio.AkSurfaceReflectorSetComponent.SetEnableDiffraction
// 0x0002 (0x0002 - 0x0000)
struct AkSurfaceReflectorSetComponent_SetEnableDiffraction final
{
public:
	bool                                          bInEnableDiffraction;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInEnableDiffractionOnBoundaryEdges;               // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkSurfaceReflectorSetComponent_SetEnableDiffraction) == 0x000001, "Wrong alignment on AkSurfaceReflectorSetComponent_SetEnableDiffraction");
static_assert(sizeof(AkSurfaceReflectorSetComponent_SetEnableDiffraction) == 0x000002, "Wrong size on AkSurfaceReflectorSetComponent_SetEnableDiffraction");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetEnableDiffraction, bInEnableDiffraction) == 0x000000, "Member 'AkSurfaceReflectorSetComponent_SetEnableDiffraction::bInEnableDiffraction' has a wrong offset!");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetEnableDiffraction, bInEnableDiffractionOnBoundaryEdges) == 0x000001, "Member 'AkSurfaceReflectorSetComponent_SetEnableDiffraction::bInEnableDiffractionOnBoundaryEdges' has a wrong offset!");

// Function AkAudio.AkSurfaceReflectorSetComponent.SetEnableSurface
// 0x0018 (0x0018 - 0x0000)
struct AkSurfaceReflectorSetComponent_SetEnableSurface final
{
public:
	TArray<int32>                                 InSurfaceIndexesToEdit;                            // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInEnableSurface;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkSurfaceReflectorSetComponent_SetEnableSurface) == 0x000008, "Wrong alignment on AkSurfaceReflectorSetComponent_SetEnableSurface");
static_assert(sizeof(AkSurfaceReflectorSetComponent_SetEnableSurface) == 0x000018, "Wrong size on AkSurfaceReflectorSetComponent_SetEnableSurface");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetEnableSurface, InSurfaceIndexesToEdit) == 0x000000, "Member 'AkSurfaceReflectorSetComponent_SetEnableSurface::InSurfaceIndexesToEdit' has a wrong offset!");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetEnableSurface, bInEnableSurface) == 0x000010, "Member 'AkSurfaceReflectorSetComponent_SetEnableSurface::bInEnableSurface' has a wrong offset!");

// Function AkAudio.AkSurfaceReflectorSetComponent.SetSurfaceProperties
// 0x0028 (0x0028 - 0x0000)
struct AkSurfaceReflectorSetComponent_SetSurfaceProperties final
{
public:
	TArray<int32>                                 InSurfaceIndexesToEdit;                            // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAkSurfacePoly                         InSurfaceProperties;                               // 0x0010(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkSurfaceReflectorSetComponent_SetSurfaceProperties) == 0x000008, "Wrong alignment on AkSurfaceReflectorSetComponent_SetSurfaceProperties");
static_assert(sizeof(AkSurfaceReflectorSetComponent_SetSurfaceProperties) == 0x000028, "Wrong size on AkSurfaceReflectorSetComponent_SetSurfaceProperties");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetSurfaceProperties, InSurfaceIndexesToEdit) == 0x000000, "Member 'AkSurfaceReflectorSetComponent_SetSurfaceProperties::InSurfaceIndexesToEdit' has a wrong offset!");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetSurfaceProperties, InSurfaceProperties) == 0x000010, "Member 'AkSurfaceReflectorSetComponent_SetSurfaceProperties::InSurfaceProperties' has a wrong offset!");

// Function AkAudio.AkSurfaceReflectorSetComponent.SetTransmissionLoss
// 0x0018 (0x0018 - 0x0000)
struct AkSurfaceReflectorSetComponent_SetTransmissionLoss final
{
public:
	TArray<int32>                                 InSurfaceIndexesToEdit;                            // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         InTransmissionLoss;                                // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInEnableSurface;                                  // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AkSurfaceReflectorSetComponent_SetTransmissionLoss) == 0x000008, "Wrong alignment on AkSurfaceReflectorSetComponent_SetTransmissionLoss");
static_assert(sizeof(AkSurfaceReflectorSetComponent_SetTransmissionLoss) == 0x000018, "Wrong size on AkSurfaceReflectorSetComponent_SetTransmissionLoss");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetTransmissionLoss, InSurfaceIndexesToEdit) == 0x000000, "Member 'AkSurfaceReflectorSetComponent_SetTransmissionLoss::InSurfaceIndexesToEdit' has a wrong offset!");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetTransmissionLoss, InTransmissionLoss) == 0x000010, "Member 'AkSurfaceReflectorSetComponent_SetTransmissionLoss::InTransmissionLoss' has a wrong offset!");
static_assert(offsetof(AkSurfaceReflectorSetComponent_SetTransmissionLoss, bInEnableSurface) == 0x000014, "Member 'AkSurfaceReflectorSetComponent_SetTransmissionLoss::bInEnableSurface' has a wrong offset!");

// Function AkAudio.AkSurfaceReflectorSetComponent.UpdateAcousticProperties
// 0x0010 (0x0010 - 0x0000)
struct AkSurfaceReflectorSetComponent_UpdateAcousticProperties final
{
public:
	TArray<struct FAkSurfacePoly>                 in_AcousticPolys;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkSurfaceReflectorSetComponent_UpdateAcousticProperties) == 0x000008, "Wrong alignment on AkSurfaceReflectorSetComponent_UpdateAcousticProperties");
static_assert(sizeof(AkSurfaceReflectorSetComponent_UpdateAcousticProperties) == 0x000010, "Wrong size on AkSurfaceReflectorSetComponent_UpdateAcousticProperties");
static_assert(offsetof(AkSurfaceReflectorSetComponent_UpdateAcousticProperties, in_AcousticPolys) == 0x000000, "Member 'AkSurfaceReflectorSetComponent_UpdateAcousticProperties::in_AcousticPolys' has a wrong offset!");

// Function AkAudio.AkWindowsInitializationSettings.MigrateMultiCoreRendering
// 0x0001 (0x0001 - 0x0000)
struct AkWindowsInitializationSettings_MigrateMultiCoreRendering final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AkWindowsInitializationSettings_MigrateMultiCoreRendering) == 0x000001, "Wrong alignment on AkWindowsInitializationSettings_MigrateMultiCoreRendering");
static_assert(sizeof(AkWindowsInitializationSettings_MigrateMultiCoreRendering) == 0x000001, "Wrong size on AkWindowsInitializationSettings_MigrateMultiCoreRendering");
static_assert(offsetof(AkWindowsInitializationSettings_MigrateMultiCoreRendering, NewValue) == 0x000000, "Member 'AkWindowsInitializationSettings_MigrateMultiCoreRendering::NewValue' has a wrong offset!");

// Function AkAudio.PostEventAsync.PostEventAsync
// 0x0038 (0x0038 - 0x0000)
struct PostEventAsync_PostEventAsync final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallbackMask;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> PostEventCallback;                                 // 0x001C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPostEventAsync*                        ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PostEventAsync_PostEventAsync) == 0x000008, "Wrong alignment on PostEventAsync_PostEventAsync");
static_assert(sizeof(PostEventAsync_PostEventAsync) == 0x000038, "Wrong size on PostEventAsync_PostEventAsync");
static_assert(offsetof(PostEventAsync_PostEventAsync, WorldContextObject) == 0x000000, "Member 'PostEventAsync_PostEventAsync::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PostEventAsync_PostEventAsync, AkEvent) == 0x000008, "Member 'PostEventAsync_PostEventAsync::AkEvent' has a wrong offset!");
static_assert(offsetof(PostEventAsync_PostEventAsync, Actor) == 0x000010, "Member 'PostEventAsync_PostEventAsync::Actor' has a wrong offset!");
static_assert(offsetof(PostEventAsync_PostEventAsync, CallbackMask) == 0x000018, "Member 'PostEventAsync_PostEventAsync::CallbackMask' has a wrong offset!");
static_assert(offsetof(PostEventAsync_PostEventAsync, PostEventCallback) == 0x00001C, "Member 'PostEventAsync_PostEventAsync::PostEventCallback' has a wrong offset!");
static_assert(offsetof(PostEventAsync_PostEventAsync, bStopWhenAttachedToDestroyed) == 0x00002C, "Member 'PostEventAsync_PostEventAsync::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(PostEventAsync_PostEventAsync, ReturnValue) == 0x000030, "Member 'PostEventAsync_PostEventAsync::ReturnValue' has a wrong offset!");

// Function AkAudio.PostEventAtLocationAsync.PostEventAtLocationAsync
// 0x0048 (0x0048 - 0x0000)
struct PostEventAtLocationAsync_PostEventAtLocationAsync final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UPostEventAtLocationAsync*              ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PostEventAtLocationAsync_PostEventAtLocationAsync) == 0x000008, "Wrong alignment on PostEventAtLocationAsync_PostEventAtLocationAsync");
static_assert(sizeof(PostEventAtLocationAsync_PostEventAtLocationAsync) == 0x000048, "Wrong size on PostEventAtLocationAsync_PostEventAtLocationAsync");
static_assert(offsetof(PostEventAtLocationAsync_PostEventAtLocationAsync, WorldContextObject) == 0x000000, "Member 'PostEventAtLocationAsync_PostEventAtLocationAsync::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PostEventAtLocationAsync_PostEventAtLocationAsync, AkEvent) == 0x000008, "Member 'PostEventAtLocationAsync_PostEventAtLocationAsync::AkEvent' has a wrong offset!");
static_assert(offsetof(PostEventAtLocationAsync_PostEventAtLocationAsync, Location) == 0x000010, "Member 'PostEventAtLocationAsync_PostEventAtLocationAsync::Location' has a wrong offset!");
static_assert(offsetof(PostEventAtLocationAsync_PostEventAtLocationAsync, Orientation) == 0x000028, "Member 'PostEventAtLocationAsync_PostEventAtLocationAsync::Orientation' has a wrong offset!");
static_assert(offsetof(PostEventAtLocationAsync_PostEventAtLocationAsync, ReturnValue) == 0x000040, "Member 'PostEventAtLocationAsync_PostEventAtLocationAsync::ReturnValue' has a wrong offset!");

}

