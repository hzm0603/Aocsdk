#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_WaterLake

#include "Basic.hpp"

#include "BP_WaterLake_classes.hpp"
#include "BP_WaterLake_parameters.hpp"


namespace SDK
{

// Function BP_WaterLake.BP_WaterLake_C.Add Swim Volumes
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterLake_C::Add_Swim_Volumes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Add Swim Volumes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterLake.BP_WaterLake_C.Bake Mesh
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDynamicMeshComponent*            Dynamic_Mesh                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UMaterialInterface*               Material                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Asset_Tag                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class UStaticMesh**                     Out_SM                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_WaterLake_C::Bake_Mesh(class UDynamicMeshComponent* Dynamic_Mesh, class UMaterialInterface* Material, const class FString& Asset_Tag, class UStaticMesh** Out_SM)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Bake Mesh");

	Params::BP_WaterLake_C_Bake_Mesh Parms{};

	Parms.Dynamic_Mesh = Dynamic_Mesh;
	Parms.Material = Material;
	Parms.Asset_Tag = std::move(Asset_Tag);

	UObject::ProcessEvent(Func, &Parms);

	if (Out_SM != nullptr)
		*Out_SM = Parms.Out_SM;
}


// Function BP_WaterLake.BP_WaterLake_C.Bake Vertex Colors
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDynamicMeshComponent*            DynMesh                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_WaterLake_C::Bake_Vertex_Colors(class UDynamicMeshComponent* DynMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Bake Vertex Colors");

	Params::BP_WaterLake_C_Bake_Vertex_Colors Parms{};

	Parms.DynMesh = DynMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterLake.BP_WaterLake_C.Bake Water Meshes
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterLake_C::Bake_Water_Meshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Bake Water Meshes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterLake.BP_WaterLake_C.Build Display Mesh
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FVector2D>&         PolygonVertices                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ABP_WaterLake_C::Build_Display_Mesh(const TArray<struct FVector2D>& PolygonVertices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Build Display Mesh");

	Params::BP_WaterLake_C_Build_Display_Mesh Parms{};

	Parms.PolygonVertices = std::move(PolygonVertices);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterLake.BP_WaterLake_C.Build Profile for Spline
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Width                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Divisions                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector2D>*               Positions                                              (Parm, OutParm)
// TArray<double>*                         UVs                                                    (Parm, OutParm)

void ABP_WaterLake_C::Build_Profile_for_Spline(double Width, int32 Divisions, TArray<struct FVector2D>* Positions, TArray<double>* UVs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Build Profile for Spline");

	Params::BP_WaterLake_C_Build_Profile_for_Spline Parms{};

	Parms.Width = Width;
	Parms.Divisions = Divisions;

	UObject::ProcessEvent(Func, &Parms);

	if (Positions != nullptr)
		*Positions = std::move(Parms.Positions);

	if (UVs != nullptr)
		*UVs = std::move(Parms.UVs);
}


// Function BP_WaterLake.BP_WaterLake_C.Check if Mesh Asset Exists
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    Asset_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   Exists_                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMesh**                     Return_Mesh                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_WaterLake_C::Check_if_Mesh_Asset_Exists(const class FString& Asset_Name, bool* Exists_, class UStaticMesh** Return_Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Check if Mesh Asset Exists");

	Params::BP_WaterLake_C_Check_if_Mesh_Asset_Exists Parms{};

	Parms.Asset_Name = std::move(Asset_Name);

	UObject::ProcessEvent(Func, &Parms);

	if (Exists_ != nullptr)
		*Exists_ = Parms.Exists_;

	if (Return_Mesh != nullptr)
		*Return_Mesh = Parms.Return_Mesh;
}


// Function BP_WaterLake.BP_WaterLake_C.CheckInvalidateMeshes
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Invalidated                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterLake_C::CheckInvalidateMeshes(bool* Invalidated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "CheckInvalidateMeshes");

	Params::BP_WaterLake_C_CheckInvalidateMeshes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Invalidated != nullptr)
		*Invalidated = Parms.Invalidated;
}


// Function BP_WaterLake.BP_WaterLake_C.Decompose To Volume Transforms
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FTransform>*              Transforms                                             (Parm, OutParm)

void ABP_WaterLake_C::Decompose_To_Volume_Transforms(TArray<struct FTransform>* Transforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Decompose To Volume Transforms");

	Params::BP_WaterLake_C_Decompose_To_Volume_Transforms Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Transforms != nullptr)
		*Transforms = std::move(Parms.Transforms);
}


// Function BP_WaterLake.BP_WaterLake_C.Editor Water Tick
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterLake_C::Editor_Water_Tick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Editor Water Tick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterLake.BP_WaterLake_C.Editor Water Update
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterLake_C::Editor_Water_Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Editor Water Update");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterLake.BP_WaterLake_C.ExecuteUbergraph_BP_WaterLake
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterLake_C::ExecuteUbergraph_BP_WaterLake(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "ExecuteUbergraph_BP_WaterLake");

	Params::BP_WaterLake_C_ExecuteUbergraph_BP_WaterLake Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterLake.BP_WaterLake_C.Fix Up Meshes
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterLake_C::Fix_Up_Meshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Fix Up Meshes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterLake.BP_WaterLake_C.Get Current at Location
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   World_Location                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D*                       Current_Velocity                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterLake_C::Get_Current_at_Location(const struct FVector& World_Location, struct FVector2D* Current_Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Get Current at Location");

	Params::BP_WaterLake_C_Get_Current_at_Location Parms{};

	Parms.World_Location = std::move(World_Location);

	UObject::ProcessEvent(Func, &Parms);

	if (Current_Velocity != nullptr)
		*Current_Velocity = std::move(Parms.Current_Velocity);
}


// Function BP_WaterLake.BP_WaterLake_C.Get Samples From Spline
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class USplineComponent*           Spline_0                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// double                                  Spacing                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector2D>*               Frames_0                                               (Parm, OutParm)
// TArray<double>*                         FrameTimes                                             (Parm, OutParm)

void ABP_WaterLake_C::Get_Samples_From_Spline(const class USplineComponent* Spline_0, double Spacing, TArray<struct FVector2D>* Frames_0, TArray<double>* FrameTimes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Get Samples From Spline");

	Params::BP_WaterLake_C_Get_Samples_From_Spline Parms{};

	Parms.Spline_0 = Spline_0;
	Parms.Spacing = Spacing;

	UObject::ProcessEvent(Func, &Parms);

	if (Frames_0 != nullptr)
		*Frames_0 = std::move(Parms.Frames_0);

	if (FrameTimes != nullptr)
		*FrameTimes = std::move(Parms.FrameTimes);
}


// Function BP_WaterLake.BP_WaterLake_C.GetControlledPawnLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector*                         ControlledPawnLocation                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterLake_C::GetControlledPawnLocation(struct FVector* ControlledPawnLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "GetControlledPawnLocation");

	Params::BP_WaterLake_C_GetControlledPawnLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ControlledPawnLocation != nullptr)
		*ControlledPawnLocation = std::move(Parms.ControlledPawnLocation);
}


// Function BP_WaterLake.BP_WaterLake_C.GetPlayerControllerCameraRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FRotator*                        PlayerControllerCameraRotation                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_WaterLake_C::GetPlayerControllerCameraRotation(struct FRotator* PlayerControllerCameraRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "GetPlayerControllerCameraRotation");

	Params::BP_WaterLake_C_GetPlayerControllerCameraRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayerControllerCameraRotation != nullptr)
		*PlayerControllerCameraRotation = std::move(Parms.PlayerControllerCameraRotation);
}


// Function BP_WaterLake.BP_WaterLake_C.GetSplineComponent
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineComponent*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash)

class USplineComponent* ABP_WaterLake_C::GetSplineComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "GetSplineComponent");

	Params::BP_WaterLake_C_GetSplineComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_WaterLake.BP_WaterLake_C.GetSplineEmitterComponent
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash)

class USceneComponent* ABP_WaterLake_C::GetSplineEmitterComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "GetSplineEmitterComponent");

	Params::BP_WaterLake_C_GetSplineEmitterComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_WaterLake.BP_WaterLake_C.Outside Spline
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_WaterLake_C::Outside_Spline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Outside Spline");

	Params::BP_WaterLake_C_Outside_Spline Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_WaterLake.BP_WaterLake_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_WaterLake_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterLake.BP_WaterLake_C.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterLake_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "ReceiveEndPlay");

	Params::BP_WaterLake_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterLake.BP_WaterLake_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterLake_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "ReceiveTick");

	Params::BP_WaterLake_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterLake.BP_WaterLake_C.Refresh Water Info
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterLake_C::Refresh_Water_Info()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Refresh Water Info");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterLake.BP_WaterLake_C.Refresh Water Info Delayed
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterLake_C::Refresh_Water_Info_Delayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Refresh Water Info Delayed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterLake.BP_WaterLake_C.RenderingMinimap
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Rendering                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_WaterLake_C::RenderingMinimap(bool Rendering)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "RenderingMinimap");

	Params::BP_WaterLake_C_RenderingMinimap Parms{};

	Parms.Rendering = Rendering;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_WaterLake.BP_WaterLake_C.Setup Debug
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterLake_C::Setup_Debug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Setup Debug");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterLake.BP_WaterLake_C.Setup Dynamic Meshes
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterLake_C::Setup_Dynamic_Meshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Setup Dynamic Meshes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterLake.BP_WaterLake_C.Setup StaticMesh
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UStaticMeshComponent*             Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UStaticMesh*&                     Var                                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void ABP_WaterLake_C::Setup_StaticMesh(class UStaticMesh* Mesh, class UStaticMeshComponent* Component, class UStaticMesh*& Var)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Setup StaticMesh");

	Params::BP_WaterLake_C_Setup_StaticMesh Parms{};

	Parms.Mesh = Mesh;
	Parms.Component = Component;
	Parms.Var = Var;

	UObject::ProcessEvent(Func, &Parms);

	Var = Parms.Var;
}


// Function BP_WaterLake.BP_WaterLake_C.Update Mesh Visibility
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterLake_C::Update_Mesh_Visibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Update Mesh Visibility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterLake.BP_WaterLake_C.Update Static Meshes
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_WaterLake_C::Update_Static_Meshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "Update Static Meshes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_WaterLake.BP_WaterLake_C.UserConstructionScript
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_WaterLake_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_WaterLake_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}

}

