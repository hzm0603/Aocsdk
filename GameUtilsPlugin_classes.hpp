#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameUtilsPlugin

#include "Basic.hpp"

#include "GameUtilsPlugin_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class GameUtilsPlugin.GameAuthorityLibrary
// 0x0000 (0x0048 - 0x0048)
class UGameAuthorityLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsAuthorityOf(class AActor* Actor);
	static bool IsClientAuthorityOf(class AActor* Actor, bool bOrStandalone);
	static bool IsNoAuthority(class AActor* Actor);
	static bool IsProxying(class AActor* Actor);
	static bool IsRunningOnClient(class AActor* Actor, bool bOrStandalone);
	static bool IsRunningOnServer(class AActor* Actor, bool bOrStandalone);
	static bool IsRunningOnStandalone(class AActor* Actor);
	static bool IsServerAuthorityOf(class AActor* Actor);
	static bool IsSharedAuthorityOf(class AActor* Actor);
	static bool IsSharingAuthorityOf(class AActor* Actor);
	static bool IsSimulating(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameAuthorityLibrary">();
	}
	static class UGameAuthorityLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameAuthorityLibrary>();
	}
};
static_assert(alignof(UGameAuthorityLibrary) == 0x000008, "Wrong alignment on UGameAuthorityLibrary");
static_assert(sizeof(UGameAuthorityLibrary) == 0x000048, "Wrong size on UGameAuthorityLibrary");

// Class GameUtilsPlugin.GameBuildVersionInfo
// 0x0010 (0x02D0 - 0x02C0)
class UGameBuildVersionInfo : public UClass
{
public:
	class FString                                 BuildVersionIdentifier;                            // 0x02C0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FString GetBuildVersionString() const;
	bool IsDevVersion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameBuildVersionInfo">();
	}
	static class UGameBuildVersionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameBuildVersionInfo>();
	}
};
static_assert(alignof(UGameBuildVersionInfo) == 0x000008, "Wrong alignment on UGameBuildVersionInfo");
static_assert(sizeof(UGameBuildVersionInfo) == 0x0002D0, "Wrong size on UGameBuildVersionInfo");
static_assert(offsetof(UGameBuildVersionInfo, BuildVersionIdentifier) == 0x0002C0, "Member 'UGameBuildVersionInfo::BuildVersionIdentifier' has a wrong offset!");

// Class GameUtilsPlugin.GameBuildVersionInterface
// 0x0000 (0x0048 - 0x0048)
class IGameBuildVersionInterface final : public IInterface
{
public:
	class FString GetVersion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameBuildVersionInterface">();
	}
	static class IGameBuildVersionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameBuildVersionInterface>();
	}
};
static_assert(alignof(IGameBuildVersionInterface) == 0x000008, "Wrong alignment on IGameBuildVersionInterface");
static_assert(sizeof(IGameBuildVersionInterface) == 0x000048, "Wrong size on IGameBuildVersionInterface");

// Class GameUtilsPlugin.GameUtils
// 0x0000 (0x0048 - 0x0048)
class UGameUtils final : public UBlueprintFunctionLibrary
{
public:
	static uint32 AddFlag(uint32 Value, uint32 Flag);
	static class UPCGComponent* AddPCGComp(class AActor* InActor);
	static bool ComponentTraceSingle(class UPrimitiveComponent* Component, const struct FVector& Start, const struct FVector& End, bool bTraceComplex, const TArray<EObjectTypeQuery>& AddIgnoredObjectChannels, const TArray<class AActor*>& ActorsToIgnore, struct FHitResult* OutHit, bool bIgnoreSelf);
	static EConeAABBIntersectionResult ConeAABBIntersection(const struct FVector& ConeOrigin, const struct FVector& ConeNormal, float ConeHalfAngle, float ConeHeightMin, float ConeHeightMax, const struct FBox& AxisAlignedBox);
	static EConeAABBIntersectionResult ConeOrientedAABBIntersection(const struct FVector& ConeOrigin, const struct FVector& ConeNormal, float ConeHalfAngle, float ConeHeightMin, float ConeHeightMax, const struct FBox& Box, const struct FQuat& BoxOrientation);
	static struct FGameplayTag ConvertStringToGameplayTag(const class FString& TagString);
	static void DrawDebugRoundedCone(const class UObject* WorldContextObject, const struct FVector& ConeOrigin, const struct FVector& ConeNormal, float ConeHalfAngle, float ConeHeightMax);
	static void EditorClearPCGLinksKeepActor(class AActor* InActor);
	static void EditorGetBoundsFromUObject(class UObject* Object, struct FVector* Origin, struct FVector* Extents);
	static void EditorRegenPCG(class UPCGComponent* InPCGComp, bool bCleanupOnly);
	static struct FVector FindClosestPointOnFiniteLine(const struct FVector& Point, const struct FVector& LineStart, const struct FVector& LineEnd);
	static bool FindComponentSnapLocationNearestToSurface(class UWorld* World, class UPrimitiveComponent* Component, const struct FVector& SweepCenter, float MinSweepDist, float MaxSweepDist, float SweepIncrement, bool bIgnorePawn, struct FVector* OutComponentSnapLocation);
	static void GetEditorCameraPosition(struct FVector* CameraLocation, struct FRotator* CameraRotation);
	static TArray<int32> GetIndecesForSortedArray(const TArray<class FString>& StringList);
	static struct FAoCTargetInfo GetLookAtTarget(class APlayerController* PlayerController);
	static bool GetLowestLineTracedGroundImpact(struct FVector* Result, class UObject* WorldContextObject, const TArray<struct FVector>& TraceStartLocations, float RayDistance);
	static int32 GetNameHashIndex(class UObject* InObject);
	static class FString GetOnlyAlphanumeric(const class FString& Dirty);
	static bool GetOrientedBoundingBox(const class UPrimitiveComponent* PrimitiveComponent, struct FBox* OutBox, struct FQuat* OutOrientation);
	static class FString GetSystemEnvironmentValue(const class FString& EnvironmentVariable);
	static struct FAoCTargetInfo GetTargetUnderCursor(class APlayerController* PlayerController, bool bConsiderPlayer, bool bIgnoreHUD, bool bIgnorePawns, bool bAllowOverlapHits);
	static struct FAoCTargetInfo GetTargetUnderReticle(class APlayerController* PlayerController, bool bConsiderPlayer, bool bIgnorePawns, bool bAllowOverlapHits, float Distance);
	static bool HasFlag(uint32 Value, uint32 Flag);
	static bool IsWithEditor();
	static bool LineTraceSingleByObjectType(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, EObjectTypeQuery ObjectChannel, bool bTraceComplex, const TArray<EObjectTypeQuery>& IgnoredObjectChannels, const TArray<class AActor*>& ActorsToIgnore, struct FHitResult* OutHit);
	static bool LineTraceSingleByTraceType(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<EObjectTypeQuery>& IgnoredObjectChannels, const TArray<class AActor*>& ActorsToIgnore, struct FHitResult* OutHit);
	static void MoveFloor(class UPrimitiveComponent* Component, const struct FVector& WorldLocation);
	static void PreDestroyFloor(class UPrimitiveComponent* Component);
	static void PrepLevelInstanceForPCG();
	static uint32 RemoveFlag(uint32 Value, uint32 Flag);
	static void ResetGeometryCollectionPhysics(class UGeometryCollectionComponent* GeometryCollection);
	static EConeAABBIntersectionResult RoundedConeOrientedAABBIntersection(const struct FVector& ConeOrigin, const struct FVector& ConeNormal, float ConeHalfAngle, float ConeHeightMin, float ConeHeightMax, const struct FBox& Box, const struct FQuat& BoxOrientation, bool bDebugDraw, const class UObject* WorldContextObject);
	static bool SaveTextToFile(const class FString& FilePath, const class FString& Filename, const class FString& FileContent);
	static void SetActorOutline(class AActor* InActor, bool bOn, int32 InColor);
	static int32 ShiftArrayIndexCircular(int32 iRaw, int32 Shift, int32 ArrayLength);
	static bool SnapComponentToNearestSurface(class UPrimitiveComponent* Component, float MinSweepDist, float MaxSweepDist, float SweepIncrement, bool bIgnorePawn);
	static bool SphereOrientedAABBIntersection(const struct FVector& SphereCenter, const float RadiusSquared, const struct FBox& Box, const struct FQuat& BoxOrientation);
	static bool TryGetFloatCurveValue(const class UAnimMontage* Montage, const class FName CurveName, float Time, float* OutValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameUtils">();
	}
	static class UGameUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameUtils>();
	}
};
static_assert(alignof(UGameUtils) == 0x000008, "Wrong alignment on UGameUtils");
static_assert(sizeof(UGameUtils) == 0x000048, "Wrong size on UGameUtils");

// Class GameUtilsPlugin.InfiniteLoopMonitorLibrary
// 0x0000 (0x0048 - 0x0048)
class UInfiniteLoopMonitorLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UInfiniteLoopMonitor* CreateInfiniteLoopFileMonitor(class FName Name_0, const class FString& CrashFilePath, int32 CheckFrequencyMs);
	static class UInfiniteLoopMonitor* CreateInfiniteLoopHeartbeatMonitor(class FName Name_0, int32 HeartbeatTimeoutMs, int32 CheckFrequencyMs);
	static void RemoveInfiniteLoopMonitorByName(class FName Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfiniteLoopMonitorLibrary">();
	}
	static class UInfiniteLoopMonitorLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInfiniteLoopMonitorLibrary>();
	}
};
static_assert(alignof(UInfiniteLoopMonitorLibrary) == 0x000008, "Wrong alignment on UInfiniteLoopMonitorLibrary");
static_assert(sizeof(UInfiniteLoopMonitorLibrary) == 0x000048, "Wrong size on UInfiniteLoopMonitorLibrary");

// Class GameUtilsPlugin.InfiniteLoopMonitor
// 0x0038 (0x0080 - 0x0048)
class UInfiniteLoopMonitor final : public UObject
{
public:
	class FName                                   MonitorName;                                       // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeartbeatTimeoutMs;                                // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckFrequencyMs;                                  // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CrashFilePath;                                     // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Start();
	void Stop();

	void Pulse() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfiniteLoopMonitor">();
	}
	static class UInfiniteLoopMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInfiniteLoopMonitor>();
	}
};
static_assert(alignof(UInfiniteLoopMonitor) == 0x000008, "Wrong alignment on UInfiniteLoopMonitor");
static_assert(sizeof(UInfiniteLoopMonitor) == 0x000080, "Wrong size on UInfiniteLoopMonitor");
static_assert(offsetof(UInfiniteLoopMonitor, MonitorName) == 0x000048, "Member 'UInfiniteLoopMonitor::MonitorName' has a wrong offset!");
static_assert(offsetof(UInfiniteLoopMonitor, HeartbeatTimeoutMs) == 0x000050, "Member 'UInfiniteLoopMonitor::HeartbeatTimeoutMs' has a wrong offset!");
static_assert(offsetof(UInfiniteLoopMonitor, CheckFrequencyMs) == 0x000054, "Member 'UInfiniteLoopMonitor::CheckFrequencyMs' has a wrong offset!");
static_assert(offsetof(UInfiniteLoopMonitor, CrashFilePath) == 0x000058, "Member 'UInfiniteLoopMonitor::CrashFilePath' has a wrong offset!");

// Class GameUtilsPlugin.IntrepidLogUtils
// 0x0000 (0x0048 - 0x0048)
class UIntrepidLogUtils final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IntrepidLogUtils">();
	}
	static class UIntrepidLogUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIntrepidLogUtils>();
	}
};
static_assert(alignof(UIntrepidLogUtils) == 0x000008, "Wrong alignment on UIntrepidLogUtils");
static_assert(sizeof(UIntrepidLogUtils) == 0x000048, "Wrong size on UIntrepidLogUtils");

// Class GameUtilsPlugin.MathUtils
// 0x0000 (0x0048 - 0x0048)
class UMathUtils final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector2D InverseLerp2DClamped(const struct FBox2D& Range, const struct FVector2D& Input);
	static struct FVector2D InverseLerp2DUnclamped(const struct FBox2D& Range, const struct FVector2D& Input);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MathUtils">();
	}
	static class UMathUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMathUtils>();
	}
};
static_assert(alignof(UMathUtils) == 0x000008, "Wrong alignment on UMathUtils");
static_assert(sizeof(UMathUtils) == 0x000048, "Wrong size on UMathUtils");

// Class GameUtilsPlugin.MeshUtils
// 0x0000 (0x0048 - 0x0048)
class UMeshUtils final : public UBlueprintFunctionLibrary
{
public:
	static void GetSkeletalMeshVerts(TArray<struct FVector>* OutVertices, EVertexRenderType OutpuType, class USkeletalMeshComponent* InComponent, int32 Stride, int32 SpecificLodIndex);
	static void GetStaticMeshVerts(TArray<struct FVector>* OutVertices, EVertexRenderType OutpuType, class UStaticMeshComponent* InMesh, const struct FVector& InWorldLoc, const struct FTransform& InLocalTransform, int32 Stride, int32 SpecificLodIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshUtils">();
	}
	static class UMeshUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshUtils>();
	}
};
static_assert(alignof(UMeshUtils) == 0x000008, "Wrong alignment on UMeshUtils");
static_assert(sizeof(UMeshUtils) == 0x000048, "Wrong size on UMeshUtils");

// Class GameUtilsPlugin.OctreeUtil
// 0x0000 (0x0048 - 0x0048)
class UOctreeUtil final : public UBlueprintFunctionLibrary
{
public:
	static class UObject* FindFirstInBox(struct FOctree& Octree, const struct FTransform& Transform, const struct FVector& Extents);
	static class UObject* FindFirstInCapsule(struct FOctree& Octree, const struct FTransform& Transform, float Radius, float HalfHeight);
	static class UObject* FindFirstInSphere(struct FOctree& Octree, const struct FTransform& Transform, float Radius);
	static void FollowMovements(struct FOctree& Octree);
	static void GetAllInBox(struct FOctree& Octree, const struct FTransform& Transform, const struct FVector& Extents, TArray<class UObject*>* Results);
	static void GetAllInCapsule(struct FOctree& Octree, const struct FTransform& Transform, float Radius, float HalfHeight, TArray<class UObject*>* Results);
	static void GetAllInSphere(struct FOctree& Octree, const struct FTransform& Transform, float Radius, TArray<class UObject*>* Results);
	static bool InsertActorWithBox(struct FOctree& Octree, class AActor* Actor, const struct FVector& Extents, bool followMovement);
	static bool InsertActorWithCapsule(struct FOctree& Octree, class AActor* Actor, float Radius, float HalfHeight, bool followMovement);
	static bool InsertActorWithSphere(struct FOctree& Octree, class AActor* Actor, float Radius, bool followMovement);
	static bool InsertBox(struct FOctree& Octree, const struct FTransform& Transform, const struct FVector& Extents, class UObject* Object);
	static bool InsertCapsule(struct FOctree& Octree, const struct FTransform& Transform, float Radius, float HalfHeight, class UObject* Object);
	static bool InsertCharacter(struct FOctree& Octree, class ACharacter* Character, bool followMovement);
	static bool InsertPoint(struct FOctree& Octree, const struct FVector& Point, class UObject* Object);
	static bool InsertSphere(struct FOctree& Octree, const struct FTransform& Transform, float Radius, class UObject* Object);
	static void Move(struct FOctree& Octree, const struct FTransform& Transform, class UObject* Object);
	static void Remove(struct FOctree& Octree, class UObject* Object);
	static void RemoveAll(struct FOctree& Octree);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctreeUtil">();
	}
	static class UOctreeUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOctreeUtil>();
	}
};
static_assert(alignof(UOctreeUtil) == 0x000008, "Wrong alignment on UOctreeUtil");
static_assert(sizeof(UOctreeUtil) == 0x000048, "Wrong size on UOctreeUtil");

// Class GameUtilsPlugin.OctreeNodeObj
// 0x00A8 (0x00F0 - 0x0048)
class UOctreeNodeObj final : public UObject
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOctreeNode                            Node;                                              // 0x0050(0x00A0)(Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctreeNodeObj">();
	}
	static class UOctreeNodeObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOctreeNodeObj>();
	}
};
static_assert(alignof(UOctreeNodeObj) == 0x000010, "Wrong alignment on UOctreeNodeObj");
static_assert(sizeof(UOctreeNodeObj) == 0x0000F0, "Wrong size on UOctreeNodeObj");
static_assert(offsetof(UOctreeNodeObj, Node) == 0x000050, "Member 'UOctreeNodeObj::Node' has a wrong offset!");

// Class GameUtilsPlugin.OctreeTreeNodeObj
// 0x00B8 (0x0100 - 0x0048)
class UOctreeTreeNodeObj final : public UObject
{
public:
	struct FOctreeTreeNode                        TreeNode;                                          // 0x0048(0x00B8)(Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctreeTreeNodeObj">();
	}
	static class UOctreeTreeNodeObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOctreeTreeNodeObj>();
	}
};
static_assert(alignof(UOctreeTreeNodeObj) == 0x000008, "Wrong alignment on UOctreeTreeNodeObj");
static_assert(sizeof(UOctreeTreeNodeObj) == 0x000100, "Wrong size on UOctreeTreeNodeObj");
static_assert(offsetof(UOctreeTreeNodeObj, TreeNode) == 0x000048, "Member 'UOctreeTreeNodeObj::TreeNode' has a wrong offset!");

// Class GameUtilsPlugin.SerializationUtils
// 0x0000 (0x0048 - 0x0048)
class USerializationUtils final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SerializationUtils">();
	}
	static class USerializationUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<USerializationUtils>();
	}
};
static_assert(alignof(USerializationUtils) == 0x000008, "Wrong alignment on USerializationUtils");
static_assert(sizeof(USerializationUtils) == 0x000048, "Wrong size on USerializationUtils");

}

