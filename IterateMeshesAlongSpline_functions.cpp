#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: IterateMeshesAlongSpline

#include "Basic.hpp"

#include "IterateMeshesAlongSpline_classes.hpp"
#include "IterateMeshesAlongSpline_parameters.hpp"


namespace SDK
{

// Function IterateMeshesAlongSpline.IterateMeshesAlongSpline_C.Assign Length
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FAoCSplineMeshEntry&       Entry                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const struct FRandomStream&             Stream                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor)
// double*                                 Total_Length                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Scaled_Mesh_Length                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Scale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  Random_Padding                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  Random_Scale                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UIterateMeshesAlongSpline_C::Assign_Length(const struct FAoCSplineMeshEntry& Entry, const struct FRandomStream& Stream, double* Total_Length, double* Scaled_Mesh_Length, double* Scale, float* Random_Padding, float* Random_Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IterateMeshesAlongSpline_C", "Assign Length");

	Params::IterateMeshesAlongSpline_C_Assign_Length Parms{};

	Parms.Entry = std::move(Entry);
	Parms.Stream = std::move(Stream);

	UObject::ProcessEvent(Func, &Parms);

	if (Total_Length != nullptr)
		*Total_Length = Parms.Total_Length;

	if (Scaled_Mesh_Length != nullptr)
		*Scaled_Mesh_Length = Parms.Scaled_Mesh_Length;

	if (Scale != nullptr)
		*Scale = Parms.Scale;

	if (Random_Padding != nullptr)
		*Random_Padding = Parms.Random_Padding;

	if (Random_Scale != nullptr)
		*Random_Scale = Parms.Random_Scale;
}


// Function IterateMeshesAlongSpline.IterateMeshesAlongSpline_C.Choose Next Mesh Entry
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FIterationPointData>&     Point_Data_Array                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FAoCSplineMeshEntry>&     Mesh_Entry_List                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   Consecutive_Index                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Mesh_Found                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FIterationPointData*             Point_Data                                             (Parm, OutParm)

void UIterateMeshesAlongSpline_C::Choose_Next_Mesh_Entry(TArray<struct FIterationPointData>& Point_Data_Array, TArray<struct FAoCSplineMeshEntry>& Mesh_Entry_List, int32 Consecutive_Index, bool* Mesh_Found, struct FIterationPointData* Point_Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IterateMeshesAlongSpline_C", "Choose Next Mesh Entry");

	Params::IterateMeshesAlongSpline_C_Choose_Next_Mesh_Entry Parms{};

	Parms.Point_Data_Array = std::move(Point_Data_Array);
	Parms.Mesh_Entry_List = std::move(Mesh_Entry_List);
	Parms.Consecutive_Index = Consecutive_Index;

	UObject::ProcessEvent(Func, &Parms);

	Point_Data_Array = std::move(Parms.Point_Data_Array);
	Mesh_Entry_List = std::move(Parms.Mesh_Entry_List);

	if (Mesh_Found != nullptr)
		*Mesh_Found = Parms.Mesh_Found;

	if (Point_Data != nullptr)
		*Point_Data = std::move(Parms.Point_Data);
}


// Function IterateMeshesAlongSpline.IterateMeshesAlongSpline_C.ExecuteWithContext
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPCGContext&                     InContext                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const struct FPCGDataCollection&        Input                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FPCGDataCollection*              Output                                                 (Parm, OutParm)

void UIterateMeshesAlongSpline_C::ExecuteWithContext(struct FPCGContext& InContext, const struct FPCGDataCollection& Input, struct FPCGDataCollection* Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IterateMeshesAlongSpline_C", "ExecuteWithContext");

	Params::IterateMeshesAlongSpline_C_ExecuteWithContext Parms{};

	Parms.InContext = std::move(InContext);
	Parms.Input = std::move(Input);

	UObject::ProcessEvent(Func, &Parms);

	InContext = std::move(Parms.InContext);

	if (Output != nullptr)
		*Output = std::move(Parms.Output);
}


// Function IterateMeshesAlongSpline.IterateMeshesAlongSpline_C.Find Mesh To Fit Area
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FAoCSplineMeshEntry>&     Mesh_Entry_List                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FPCGPoint>&               All_Points                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   Mesh_Start_Index                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Final_Spline_Index                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Consecutive_Mesh_Index                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FIterationPointData&             End_Data                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// double                                  End_Scaled_Mesh_Length                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Mesh_Found_                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FIterationPointData*             Iteration_Point_Data                                   (Parm, OutParm)
// bool*                                   First_Placed                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Last_Placed                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UIterateMeshesAlongSpline_C::Find_Mesh_To_Fit_Area(TArray<struct FAoCSplineMeshEntry>& Mesh_Entry_List, TArray<struct FPCGPoint>& All_Points, int32 Mesh_Start_Index, int32 Final_Spline_Index, int32 Consecutive_Mesh_Index, struct FIterationPointData& End_Data, double End_Scaled_Mesh_Length, bool* Mesh_Found_, struct FIterationPointData* Iteration_Point_Data, bool* First_Placed, bool* Last_Placed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IterateMeshesAlongSpline_C", "Find Mesh To Fit Area");

	Params::IterateMeshesAlongSpline_C_Find_Mesh_To_Fit_Area Parms{};

	Parms.Mesh_Entry_List = std::move(Mesh_Entry_List);
	Parms.All_Points = std::move(All_Points);
	Parms.Mesh_Start_Index = Mesh_Start_Index;
	Parms.Final_Spline_Index = Final_Spline_Index;
	Parms.Consecutive_Mesh_Index = Consecutive_Mesh_Index;
	Parms.End_Data = std::move(End_Data);
	Parms.End_Scaled_Mesh_Length = End_Scaled_Mesh_Length;

	UObject::ProcessEvent(Func, &Parms);

	Mesh_Entry_List = std::move(Parms.Mesh_Entry_List);
	All_Points = std::move(Parms.All_Points);
	End_Data = std::move(Parms.End_Data);

	if (Mesh_Found_ != nullptr)
		*Mesh_Found_ = Parms.Mesh_Found_;

	if (Iteration_Point_Data != nullptr)
		*Iteration_Point_Data = std::move(Parms.Iteration_Point_Data);

	if (First_Placed != nullptr)
		*First_Placed = Parms.First_Placed;

	if (Last_Placed != nullptr)
		*Last_Placed = Parms.Last_Placed;
}


// Function IterateMeshesAlongSpline.IterateMeshesAlongSpline_C.Get Curvature of Spline Between Points
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Start_Point_Index                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   End_Point_Index                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FPCGPoint>&               All_Points                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// double*                                 Average_Curvature                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UIterateMeshesAlongSpline_C::Get_Curvature_of_Spline_Between_Points(int32 Start_Point_Index, int32 End_Point_Index, TArray<struct FPCGPoint>& All_Points, double* Average_Curvature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IterateMeshesAlongSpline_C", "Get Curvature of Spline Between Points");

	Params::IterateMeshesAlongSpline_C_Get_Curvature_of_Spline_Between_Points Parms{};

	Parms.Start_Point_Index = Start_Point_Index;
	Parms.End_Point_Index = End_Point_Index;
	Parms.All_Points = std::move(All_Points);

	UObject::ProcessEvent(Func, &Parms);

	All_Points = std::move(Parms.All_Points);

	if (Average_Curvature != nullptr)
		*Average_Curvature = Parms.Average_Curvature;
}


// Function IterateMeshesAlongSpline.IterateMeshesAlongSpline_C.Get Distance Along Spline Between Points
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Start_Point_Index                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   End_Point_Index                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FPCGPoint>&               All_Points                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// double*                                 Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UIterateMeshesAlongSpline_C::Get_Distance_Along_Spline_Between_Points(int32 Start_Point_Index, int32 End_Point_Index, TArray<struct FPCGPoint>& All_Points, double* Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IterateMeshesAlongSpline_C", "Get Distance Along Spline Between Points");

	Params::IterateMeshesAlongSpline_C_Get_Distance_Along_Spline_Between_Points Parms{};

	Parms.Start_Point_Index = Start_Point_Index;
	Parms.End_Point_Index = End_Point_Index;
	Parms.All_Points = std::move(All_Points);

	UObject::ProcessEvent(Func, &Parms);

	All_Points = std::move(Parms.All_Points);

	if (Distance != nullptr)
		*Distance = Parms.Distance;
}


// Function IterateMeshesAlongSpline.IterateMeshesAlongSpline_C.Get Point Closest to Location
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FPCGPoint>&               Points                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32*                                  Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UIterateMeshesAlongSpline_C::Get_Point_Closest_to_Location(const struct FVector& Location, TArray<struct FPCGPoint>& Points, int32* Index_0, bool* Found)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IterateMeshesAlongSpline_C", "Get Point Closest to Location");

	Params::IterateMeshesAlongSpline_C_Get_Point_Closest_to_Location Parms{};

	Parms.Location = std::move(Location);
	Parms.Points = std::move(Points);

	UObject::ProcessEvent(Func, &Parms);

	Points = std::move(Parms.Points);

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;

	if (Found != nullptr)
		*Found = Parms.Found;
}


// Function IterateMeshesAlongSpline.IterateMeshesAlongSpline_C.NodeTitleOverride
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class FName UIterateMeshesAlongSpline_C::NodeTitleOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IterateMeshesAlongSpline_C", "NodeTitleOverride");

	Params::IterateMeshesAlongSpline_C_NodeTitleOverride Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function IterateMeshesAlongSpline.IterateMeshesAlongSpline_C.PointLoopBody
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// const struct FPCGContext&               InContext                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const class UPCGPointData*              InData                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FPCGPoint&                 InPoint                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// struct FPCGPoint*                       OutPoint                                               (Parm, OutParm, NoDestructor)
// class UPCGMetadata*                     OutMetadata                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UIterateMeshesAlongSpline_C::PointLoopBody(const struct FPCGContext& InContext, const class UPCGPointData* InData, const struct FPCGPoint& InPoint, struct FPCGPoint* OutPoint, class UPCGMetadata* OutMetadata) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IterateMeshesAlongSpline_C", "PointLoopBody");

	Params::IterateMeshesAlongSpline_C_PointLoopBody Parms{};

	Parms.InContext = std::move(InContext);
	Parms.InData = InData;
	Parms.InPoint = std::move(InPoint);
	Parms.OutMetadata = OutMetadata;

	UObject::ProcessEvent(Func, &Parms);

	if (OutPoint != nullptr)
		*OutPoint = std::move(Parms.OutPoint);

	return Parms.ReturnValue;
}

}

