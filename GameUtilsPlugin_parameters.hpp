#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameUtilsPlugin

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "GameUtilsPlugin_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK::Params
{

// Function GameUtilsPlugin.GameAuthorityLibrary.IsAuthorityOf
// 0x0010 (0x0010 - 0x0000)
struct GameAuthorityLibrary_IsAuthorityOf final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameAuthorityLibrary_IsAuthorityOf) == 0x000008, "Wrong alignment on GameAuthorityLibrary_IsAuthorityOf");
static_assert(sizeof(GameAuthorityLibrary_IsAuthorityOf) == 0x000010, "Wrong size on GameAuthorityLibrary_IsAuthorityOf");
static_assert(offsetof(GameAuthorityLibrary_IsAuthorityOf, Actor) == 0x000000, "Member 'GameAuthorityLibrary_IsAuthorityOf::Actor' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsAuthorityOf, ReturnValue) == 0x000008, "Member 'GameAuthorityLibrary_IsAuthorityOf::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameAuthorityLibrary.IsClientAuthorityOf
// 0x0010 (0x0010 - 0x0000)
struct GameAuthorityLibrary_IsClientAuthorityOf final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOrStandalone;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameAuthorityLibrary_IsClientAuthorityOf) == 0x000008, "Wrong alignment on GameAuthorityLibrary_IsClientAuthorityOf");
static_assert(sizeof(GameAuthorityLibrary_IsClientAuthorityOf) == 0x000010, "Wrong size on GameAuthorityLibrary_IsClientAuthorityOf");
static_assert(offsetof(GameAuthorityLibrary_IsClientAuthorityOf, Actor) == 0x000000, "Member 'GameAuthorityLibrary_IsClientAuthorityOf::Actor' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsClientAuthorityOf, bOrStandalone) == 0x000008, "Member 'GameAuthorityLibrary_IsClientAuthorityOf::bOrStandalone' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsClientAuthorityOf, ReturnValue) == 0x000009, "Member 'GameAuthorityLibrary_IsClientAuthorityOf::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameAuthorityLibrary.IsNoAuthority
// 0x0010 (0x0010 - 0x0000)
struct GameAuthorityLibrary_IsNoAuthority final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameAuthorityLibrary_IsNoAuthority) == 0x000008, "Wrong alignment on GameAuthorityLibrary_IsNoAuthority");
static_assert(sizeof(GameAuthorityLibrary_IsNoAuthority) == 0x000010, "Wrong size on GameAuthorityLibrary_IsNoAuthority");
static_assert(offsetof(GameAuthorityLibrary_IsNoAuthority, Actor) == 0x000000, "Member 'GameAuthorityLibrary_IsNoAuthority::Actor' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsNoAuthority, ReturnValue) == 0x000008, "Member 'GameAuthorityLibrary_IsNoAuthority::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameAuthorityLibrary.IsProxying
// 0x0010 (0x0010 - 0x0000)
struct GameAuthorityLibrary_IsProxying final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameAuthorityLibrary_IsProxying) == 0x000008, "Wrong alignment on GameAuthorityLibrary_IsProxying");
static_assert(sizeof(GameAuthorityLibrary_IsProxying) == 0x000010, "Wrong size on GameAuthorityLibrary_IsProxying");
static_assert(offsetof(GameAuthorityLibrary_IsProxying, Actor) == 0x000000, "Member 'GameAuthorityLibrary_IsProxying::Actor' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsProxying, ReturnValue) == 0x000008, "Member 'GameAuthorityLibrary_IsProxying::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameAuthorityLibrary.IsRunningOnClient
// 0x0010 (0x0010 - 0x0000)
struct GameAuthorityLibrary_IsRunningOnClient final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOrStandalone;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameAuthorityLibrary_IsRunningOnClient) == 0x000008, "Wrong alignment on GameAuthorityLibrary_IsRunningOnClient");
static_assert(sizeof(GameAuthorityLibrary_IsRunningOnClient) == 0x000010, "Wrong size on GameAuthorityLibrary_IsRunningOnClient");
static_assert(offsetof(GameAuthorityLibrary_IsRunningOnClient, Actor) == 0x000000, "Member 'GameAuthorityLibrary_IsRunningOnClient::Actor' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsRunningOnClient, bOrStandalone) == 0x000008, "Member 'GameAuthorityLibrary_IsRunningOnClient::bOrStandalone' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsRunningOnClient, ReturnValue) == 0x000009, "Member 'GameAuthorityLibrary_IsRunningOnClient::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameAuthorityLibrary.IsRunningOnServer
// 0x0010 (0x0010 - 0x0000)
struct GameAuthorityLibrary_IsRunningOnServer final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOrStandalone;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameAuthorityLibrary_IsRunningOnServer) == 0x000008, "Wrong alignment on GameAuthorityLibrary_IsRunningOnServer");
static_assert(sizeof(GameAuthorityLibrary_IsRunningOnServer) == 0x000010, "Wrong size on GameAuthorityLibrary_IsRunningOnServer");
static_assert(offsetof(GameAuthorityLibrary_IsRunningOnServer, Actor) == 0x000000, "Member 'GameAuthorityLibrary_IsRunningOnServer::Actor' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsRunningOnServer, bOrStandalone) == 0x000008, "Member 'GameAuthorityLibrary_IsRunningOnServer::bOrStandalone' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsRunningOnServer, ReturnValue) == 0x000009, "Member 'GameAuthorityLibrary_IsRunningOnServer::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameAuthorityLibrary.IsRunningOnStandalone
// 0x0010 (0x0010 - 0x0000)
struct GameAuthorityLibrary_IsRunningOnStandalone final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameAuthorityLibrary_IsRunningOnStandalone) == 0x000008, "Wrong alignment on GameAuthorityLibrary_IsRunningOnStandalone");
static_assert(sizeof(GameAuthorityLibrary_IsRunningOnStandalone) == 0x000010, "Wrong size on GameAuthorityLibrary_IsRunningOnStandalone");
static_assert(offsetof(GameAuthorityLibrary_IsRunningOnStandalone, Actor) == 0x000000, "Member 'GameAuthorityLibrary_IsRunningOnStandalone::Actor' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsRunningOnStandalone, ReturnValue) == 0x000008, "Member 'GameAuthorityLibrary_IsRunningOnStandalone::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameAuthorityLibrary.IsServerAuthorityOf
// 0x0010 (0x0010 - 0x0000)
struct GameAuthorityLibrary_IsServerAuthorityOf final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameAuthorityLibrary_IsServerAuthorityOf) == 0x000008, "Wrong alignment on GameAuthorityLibrary_IsServerAuthorityOf");
static_assert(sizeof(GameAuthorityLibrary_IsServerAuthorityOf) == 0x000010, "Wrong size on GameAuthorityLibrary_IsServerAuthorityOf");
static_assert(offsetof(GameAuthorityLibrary_IsServerAuthorityOf, Actor) == 0x000000, "Member 'GameAuthorityLibrary_IsServerAuthorityOf::Actor' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsServerAuthorityOf, ReturnValue) == 0x000008, "Member 'GameAuthorityLibrary_IsServerAuthorityOf::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameAuthorityLibrary.IsSharedAuthorityOf
// 0x0010 (0x0010 - 0x0000)
struct GameAuthorityLibrary_IsSharedAuthorityOf final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameAuthorityLibrary_IsSharedAuthorityOf) == 0x000008, "Wrong alignment on GameAuthorityLibrary_IsSharedAuthorityOf");
static_assert(sizeof(GameAuthorityLibrary_IsSharedAuthorityOf) == 0x000010, "Wrong size on GameAuthorityLibrary_IsSharedAuthorityOf");
static_assert(offsetof(GameAuthorityLibrary_IsSharedAuthorityOf, Actor) == 0x000000, "Member 'GameAuthorityLibrary_IsSharedAuthorityOf::Actor' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsSharedAuthorityOf, ReturnValue) == 0x000008, "Member 'GameAuthorityLibrary_IsSharedAuthorityOf::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameAuthorityLibrary.IsSharingAuthorityOf
// 0x0010 (0x0010 - 0x0000)
struct GameAuthorityLibrary_IsSharingAuthorityOf final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameAuthorityLibrary_IsSharingAuthorityOf) == 0x000008, "Wrong alignment on GameAuthorityLibrary_IsSharingAuthorityOf");
static_assert(sizeof(GameAuthorityLibrary_IsSharingAuthorityOf) == 0x000010, "Wrong size on GameAuthorityLibrary_IsSharingAuthorityOf");
static_assert(offsetof(GameAuthorityLibrary_IsSharingAuthorityOf, Actor) == 0x000000, "Member 'GameAuthorityLibrary_IsSharingAuthorityOf::Actor' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsSharingAuthorityOf, ReturnValue) == 0x000008, "Member 'GameAuthorityLibrary_IsSharingAuthorityOf::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameAuthorityLibrary.IsSimulating
// 0x0010 (0x0010 - 0x0000)
struct GameAuthorityLibrary_IsSimulating final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameAuthorityLibrary_IsSimulating) == 0x000008, "Wrong alignment on GameAuthorityLibrary_IsSimulating");
static_assert(sizeof(GameAuthorityLibrary_IsSimulating) == 0x000010, "Wrong size on GameAuthorityLibrary_IsSimulating");
static_assert(offsetof(GameAuthorityLibrary_IsSimulating, Actor) == 0x000000, "Member 'GameAuthorityLibrary_IsSimulating::Actor' has a wrong offset!");
static_assert(offsetof(GameAuthorityLibrary_IsSimulating, ReturnValue) == 0x000008, "Member 'GameAuthorityLibrary_IsSimulating::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameBuildVersionInfo.GetBuildVersionString
// 0x0010 (0x0010 - 0x0000)
struct GameBuildVersionInfo_GetBuildVersionString final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameBuildVersionInfo_GetBuildVersionString) == 0x000008, "Wrong alignment on GameBuildVersionInfo_GetBuildVersionString");
static_assert(sizeof(GameBuildVersionInfo_GetBuildVersionString) == 0x000010, "Wrong size on GameBuildVersionInfo_GetBuildVersionString");
static_assert(offsetof(GameBuildVersionInfo_GetBuildVersionString, ReturnValue) == 0x000000, "Member 'GameBuildVersionInfo_GetBuildVersionString::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameBuildVersionInfo.IsDevVersion
// 0x0001 (0x0001 - 0x0000)
struct GameBuildVersionInfo_IsDevVersion final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameBuildVersionInfo_IsDevVersion) == 0x000001, "Wrong alignment on GameBuildVersionInfo_IsDevVersion");
static_assert(sizeof(GameBuildVersionInfo_IsDevVersion) == 0x000001, "Wrong size on GameBuildVersionInfo_IsDevVersion");
static_assert(offsetof(GameBuildVersionInfo_IsDevVersion, ReturnValue) == 0x000000, "Member 'GameBuildVersionInfo_IsDevVersion::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameBuildVersionInterface.GetVersion
// 0x0010 (0x0010 - 0x0000)
struct GameBuildVersionInterface_GetVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameBuildVersionInterface_GetVersion) == 0x000008, "Wrong alignment on GameBuildVersionInterface_GetVersion");
static_assert(sizeof(GameBuildVersionInterface_GetVersion) == 0x000010, "Wrong size on GameBuildVersionInterface_GetVersion");
static_assert(offsetof(GameBuildVersionInterface_GetVersion, ReturnValue) == 0x000000, "Member 'GameBuildVersionInterface_GetVersion::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.AddFlag
// 0x000C (0x000C - 0x0000)
struct GameUtils_AddFlag final
{
public:
	uint32                                        Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Flag;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_AddFlag) == 0x000004, "Wrong alignment on GameUtils_AddFlag");
static_assert(sizeof(GameUtils_AddFlag) == 0x00000C, "Wrong size on GameUtils_AddFlag");
static_assert(offsetof(GameUtils_AddFlag, Value) == 0x000000, "Member 'GameUtils_AddFlag::Value' has a wrong offset!");
static_assert(offsetof(GameUtils_AddFlag, Flag) == 0x000004, "Member 'GameUtils_AddFlag::Flag' has a wrong offset!");
static_assert(offsetof(GameUtils_AddFlag, ReturnValue) == 0x000008, "Member 'GameUtils_AddFlag::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.AddPCGComp
// 0x0010 (0x0010 - 0x0000)
struct GameUtils_AddPCGComp final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPCGComponent*                          ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_AddPCGComp) == 0x000008, "Wrong alignment on GameUtils_AddPCGComp");
static_assert(sizeof(GameUtils_AddPCGComp) == 0x000010, "Wrong size on GameUtils_AddPCGComp");
static_assert(offsetof(GameUtils_AddPCGComp, InActor) == 0x000000, "Member 'GameUtils_AddPCGComp::InActor' has a wrong offset!");
static_assert(offsetof(GameUtils_AddPCGComp, ReturnValue) == 0x000008, "Member 'GameUtils_AddPCGComp::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.ComponentTraceSingle
// 0x0150 (0x0150 - 0x0000)
struct GameUtils_ComponentTraceSingle final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      AddIgnoredObjectChannels;                          // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHitResult                             OutHit;                                            // 0x0060(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0148(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0149(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A[0x6];                                      // 0x014A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_ComponentTraceSingle) == 0x000008, "Wrong alignment on GameUtils_ComponentTraceSingle");
static_assert(sizeof(GameUtils_ComponentTraceSingle) == 0x000150, "Wrong size on GameUtils_ComponentTraceSingle");
static_assert(offsetof(GameUtils_ComponentTraceSingle, Component) == 0x000000, "Member 'GameUtils_ComponentTraceSingle::Component' has a wrong offset!");
static_assert(offsetof(GameUtils_ComponentTraceSingle, Start) == 0x000008, "Member 'GameUtils_ComponentTraceSingle::Start' has a wrong offset!");
static_assert(offsetof(GameUtils_ComponentTraceSingle, End) == 0x000020, "Member 'GameUtils_ComponentTraceSingle::End' has a wrong offset!");
static_assert(offsetof(GameUtils_ComponentTraceSingle, bTraceComplex) == 0x000038, "Member 'GameUtils_ComponentTraceSingle::bTraceComplex' has a wrong offset!");
static_assert(offsetof(GameUtils_ComponentTraceSingle, AddIgnoredObjectChannels) == 0x000040, "Member 'GameUtils_ComponentTraceSingle::AddIgnoredObjectChannels' has a wrong offset!");
static_assert(offsetof(GameUtils_ComponentTraceSingle, ActorsToIgnore) == 0x000050, "Member 'GameUtils_ComponentTraceSingle::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(GameUtils_ComponentTraceSingle, OutHit) == 0x000060, "Member 'GameUtils_ComponentTraceSingle::OutHit' has a wrong offset!");
static_assert(offsetof(GameUtils_ComponentTraceSingle, bIgnoreSelf) == 0x000148, "Member 'GameUtils_ComponentTraceSingle::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(GameUtils_ComponentTraceSingle, ReturnValue) == 0x000149, "Member 'GameUtils_ComponentTraceSingle::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.ConeAABBIntersection
// 0x0080 (0x0080 - 0x0000)
struct GameUtils_ConeAABBIntersection final
{
public:
	struct FVector                                ConeOrigin;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConeNormal;                                        // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHalfAngle;                                     // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHeightMin;                                     // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHeightMax;                                     // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   AxisAlignedBox;                                    // 0x0040(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EConeAABBIntersectionResult                   ReturnValue;                                       // 0x0078(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_ConeAABBIntersection) == 0x000008, "Wrong alignment on GameUtils_ConeAABBIntersection");
static_assert(sizeof(GameUtils_ConeAABBIntersection) == 0x000080, "Wrong size on GameUtils_ConeAABBIntersection");
static_assert(offsetof(GameUtils_ConeAABBIntersection, ConeOrigin) == 0x000000, "Member 'GameUtils_ConeAABBIntersection::ConeOrigin' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeAABBIntersection, ConeNormal) == 0x000018, "Member 'GameUtils_ConeAABBIntersection::ConeNormal' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeAABBIntersection, ConeHalfAngle) == 0x000030, "Member 'GameUtils_ConeAABBIntersection::ConeHalfAngle' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeAABBIntersection, ConeHeightMin) == 0x000034, "Member 'GameUtils_ConeAABBIntersection::ConeHeightMin' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeAABBIntersection, ConeHeightMax) == 0x000038, "Member 'GameUtils_ConeAABBIntersection::ConeHeightMax' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeAABBIntersection, AxisAlignedBox) == 0x000040, "Member 'GameUtils_ConeAABBIntersection::AxisAlignedBox' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeAABBIntersection, ReturnValue) == 0x000078, "Member 'GameUtils_ConeAABBIntersection::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.ConeOrientedAABBIntersection
// 0x00B0 (0x00B0 - 0x0000)
struct GameUtils_ConeOrientedAABBIntersection final
{
public:
	struct FVector                                ConeOrigin;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConeNormal;                                        // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHalfAngle;                                     // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHeightMin;                                     // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHeightMax;                                     // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Box;                                               // 0x0040(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  BoxOrientation;                                    // 0x0080(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConeAABBIntersectionResult                   ReturnValue;                                       // 0x00A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0xF];                                       // 0x00A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_ConeOrientedAABBIntersection) == 0x000010, "Wrong alignment on GameUtils_ConeOrientedAABBIntersection");
static_assert(sizeof(GameUtils_ConeOrientedAABBIntersection) == 0x0000B0, "Wrong size on GameUtils_ConeOrientedAABBIntersection");
static_assert(offsetof(GameUtils_ConeOrientedAABBIntersection, ConeOrigin) == 0x000000, "Member 'GameUtils_ConeOrientedAABBIntersection::ConeOrigin' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeOrientedAABBIntersection, ConeNormal) == 0x000018, "Member 'GameUtils_ConeOrientedAABBIntersection::ConeNormal' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeOrientedAABBIntersection, ConeHalfAngle) == 0x000030, "Member 'GameUtils_ConeOrientedAABBIntersection::ConeHalfAngle' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeOrientedAABBIntersection, ConeHeightMin) == 0x000034, "Member 'GameUtils_ConeOrientedAABBIntersection::ConeHeightMin' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeOrientedAABBIntersection, ConeHeightMax) == 0x000038, "Member 'GameUtils_ConeOrientedAABBIntersection::ConeHeightMax' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeOrientedAABBIntersection, Box) == 0x000040, "Member 'GameUtils_ConeOrientedAABBIntersection::Box' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeOrientedAABBIntersection, BoxOrientation) == 0x000080, "Member 'GameUtils_ConeOrientedAABBIntersection::BoxOrientation' has a wrong offset!");
static_assert(offsetof(GameUtils_ConeOrientedAABBIntersection, ReturnValue) == 0x0000A0, "Member 'GameUtils_ConeOrientedAABBIntersection::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.ConvertStringToGameplayTag
// 0x0018 (0x0018 - 0x0000)
struct GameUtils_ConvertStringToGameplayTag final
{
public:
	class FString                                 TagString;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_ConvertStringToGameplayTag) == 0x000008, "Wrong alignment on GameUtils_ConvertStringToGameplayTag");
static_assert(sizeof(GameUtils_ConvertStringToGameplayTag) == 0x000018, "Wrong size on GameUtils_ConvertStringToGameplayTag");
static_assert(offsetof(GameUtils_ConvertStringToGameplayTag, TagString) == 0x000000, "Member 'GameUtils_ConvertStringToGameplayTag::TagString' has a wrong offset!");
static_assert(offsetof(GameUtils_ConvertStringToGameplayTag, ReturnValue) == 0x000010, "Member 'GameUtils_ConvertStringToGameplayTag::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.DrawDebugRoundedCone
// 0x0040 (0x0040 - 0x0000)
struct GameUtils_DrawDebugRoundedCone final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConeOrigin;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConeNormal;                                        // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHalfAngle;                                     // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHeightMax;                                     // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_DrawDebugRoundedCone) == 0x000008, "Wrong alignment on GameUtils_DrawDebugRoundedCone");
static_assert(sizeof(GameUtils_DrawDebugRoundedCone) == 0x000040, "Wrong size on GameUtils_DrawDebugRoundedCone");
static_assert(offsetof(GameUtils_DrawDebugRoundedCone, WorldContextObject) == 0x000000, "Member 'GameUtils_DrawDebugRoundedCone::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameUtils_DrawDebugRoundedCone, ConeOrigin) == 0x000008, "Member 'GameUtils_DrawDebugRoundedCone::ConeOrigin' has a wrong offset!");
static_assert(offsetof(GameUtils_DrawDebugRoundedCone, ConeNormal) == 0x000020, "Member 'GameUtils_DrawDebugRoundedCone::ConeNormal' has a wrong offset!");
static_assert(offsetof(GameUtils_DrawDebugRoundedCone, ConeHalfAngle) == 0x000038, "Member 'GameUtils_DrawDebugRoundedCone::ConeHalfAngle' has a wrong offset!");
static_assert(offsetof(GameUtils_DrawDebugRoundedCone, ConeHeightMax) == 0x00003C, "Member 'GameUtils_DrawDebugRoundedCone::ConeHeightMax' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.EditorClearPCGLinksKeepActor
// 0x0008 (0x0008 - 0x0000)
struct GameUtils_EditorClearPCGLinksKeepActor final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_EditorClearPCGLinksKeepActor) == 0x000008, "Wrong alignment on GameUtils_EditorClearPCGLinksKeepActor");
static_assert(sizeof(GameUtils_EditorClearPCGLinksKeepActor) == 0x000008, "Wrong size on GameUtils_EditorClearPCGLinksKeepActor");
static_assert(offsetof(GameUtils_EditorClearPCGLinksKeepActor, InActor) == 0x000000, "Member 'GameUtils_EditorClearPCGLinksKeepActor::InActor' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.EditorGetBoundsFromUObject
// 0x0038 (0x0038 - 0x0000)
struct GameUtils_EditorGetBoundsFromUObject final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extents;                                           // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_EditorGetBoundsFromUObject) == 0x000008, "Wrong alignment on GameUtils_EditorGetBoundsFromUObject");
static_assert(sizeof(GameUtils_EditorGetBoundsFromUObject) == 0x000038, "Wrong size on GameUtils_EditorGetBoundsFromUObject");
static_assert(offsetof(GameUtils_EditorGetBoundsFromUObject, Object) == 0x000000, "Member 'GameUtils_EditorGetBoundsFromUObject::Object' has a wrong offset!");
static_assert(offsetof(GameUtils_EditorGetBoundsFromUObject, Origin) == 0x000008, "Member 'GameUtils_EditorGetBoundsFromUObject::Origin' has a wrong offset!");
static_assert(offsetof(GameUtils_EditorGetBoundsFromUObject, Extents) == 0x000020, "Member 'GameUtils_EditorGetBoundsFromUObject::Extents' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.EditorRegenPCG
// 0x0010 (0x0010 - 0x0000)
struct GameUtils_EditorRegenPCG final
{
public:
	class UPCGComponent*                          InPCGComp;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCleanupOnly;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_EditorRegenPCG) == 0x000008, "Wrong alignment on GameUtils_EditorRegenPCG");
static_assert(sizeof(GameUtils_EditorRegenPCG) == 0x000010, "Wrong size on GameUtils_EditorRegenPCG");
static_assert(offsetof(GameUtils_EditorRegenPCG, InPCGComp) == 0x000000, "Member 'GameUtils_EditorRegenPCG::InPCGComp' has a wrong offset!");
static_assert(offsetof(GameUtils_EditorRegenPCG, bCleanupOnly) == 0x000008, "Member 'GameUtils_EditorRegenPCG::bCleanupOnly' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.FindClosestPointOnFiniteLine
// 0x0060 (0x0060 - 0x0000)
struct GameUtils_FindClosestPointOnFiniteLine final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineStart;                                         // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0048(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_FindClosestPointOnFiniteLine) == 0x000008, "Wrong alignment on GameUtils_FindClosestPointOnFiniteLine");
static_assert(sizeof(GameUtils_FindClosestPointOnFiniteLine) == 0x000060, "Wrong size on GameUtils_FindClosestPointOnFiniteLine");
static_assert(offsetof(GameUtils_FindClosestPointOnFiniteLine, Point) == 0x000000, "Member 'GameUtils_FindClosestPointOnFiniteLine::Point' has a wrong offset!");
static_assert(offsetof(GameUtils_FindClosestPointOnFiniteLine, LineStart) == 0x000018, "Member 'GameUtils_FindClosestPointOnFiniteLine::LineStart' has a wrong offset!");
static_assert(offsetof(GameUtils_FindClosestPointOnFiniteLine, LineEnd) == 0x000030, "Member 'GameUtils_FindClosestPointOnFiniteLine::LineEnd' has a wrong offset!");
static_assert(offsetof(GameUtils_FindClosestPointOnFiniteLine, ReturnValue) == 0x000048, "Member 'GameUtils_FindClosestPointOnFiniteLine::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.FindComponentSnapLocationNearestToSurface
// 0x0058 (0x0058 - 0x0000)
struct GameUtils_FindComponentSnapLocationNearestToSurface final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    Component;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SweepCenter;                                       // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSweepDist;                                      // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSweepDist;                                      // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepIncrement;                                    // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorePawn;                                       // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OutComponentSnapLocation;                          // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_FindComponentSnapLocationNearestToSurface) == 0x000008, "Wrong alignment on GameUtils_FindComponentSnapLocationNearestToSurface");
static_assert(sizeof(GameUtils_FindComponentSnapLocationNearestToSurface) == 0x000058, "Wrong size on GameUtils_FindComponentSnapLocationNearestToSurface");
static_assert(offsetof(GameUtils_FindComponentSnapLocationNearestToSurface, World) == 0x000000, "Member 'GameUtils_FindComponentSnapLocationNearestToSurface::World' has a wrong offset!");
static_assert(offsetof(GameUtils_FindComponentSnapLocationNearestToSurface, Component) == 0x000008, "Member 'GameUtils_FindComponentSnapLocationNearestToSurface::Component' has a wrong offset!");
static_assert(offsetof(GameUtils_FindComponentSnapLocationNearestToSurface, SweepCenter) == 0x000010, "Member 'GameUtils_FindComponentSnapLocationNearestToSurface::SweepCenter' has a wrong offset!");
static_assert(offsetof(GameUtils_FindComponentSnapLocationNearestToSurface, MinSweepDist) == 0x000028, "Member 'GameUtils_FindComponentSnapLocationNearestToSurface::MinSweepDist' has a wrong offset!");
static_assert(offsetof(GameUtils_FindComponentSnapLocationNearestToSurface, MaxSweepDist) == 0x00002C, "Member 'GameUtils_FindComponentSnapLocationNearestToSurface::MaxSweepDist' has a wrong offset!");
static_assert(offsetof(GameUtils_FindComponentSnapLocationNearestToSurface, SweepIncrement) == 0x000030, "Member 'GameUtils_FindComponentSnapLocationNearestToSurface::SweepIncrement' has a wrong offset!");
static_assert(offsetof(GameUtils_FindComponentSnapLocationNearestToSurface, bIgnorePawn) == 0x000034, "Member 'GameUtils_FindComponentSnapLocationNearestToSurface::bIgnorePawn' has a wrong offset!");
static_assert(offsetof(GameUtils_FindComponentSnapLocationNearestToSurface, OutComponentSnapLocation) == 0x000038, "Member 'GameUtils_FindComponentSnapLocationNearestToSurface::OutComponentSnapLocation' has a wrong offset!");
static_assert(offsetof(GameUtils_FindComponentSnapLocationNearestToSurface, ReturnValue) == 0x000050, "Member 'GameUtils_FindComponentSnapLocationNearestToSurface::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.GetEditorCameraPosition
// 0x0030 (0x0030 - 0x0000)
struct GameUtils_GetEditorCameraPosition final
{
public:
	struct FVector                                CameraLocation;                                    // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotation;                                    // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_GetEditorCameraPosition) == 0x000008, "Wrong alignment on GameUtils_GetEditorCameraPosition");
static_assert(sizeof(GameUtils_GetEditorCameraPosition) == 0x000030, "Wrong size on GameUtils_GetEditorCameraPosition");
static_assert(offsetof(GameUtils_GetEditorCameraPosition, CameraLocation) == 0x000000, "Member 'GameUtils_GetEditorCameraPosition::CameraLocation' has a wrong offset!");
static_assert(offsetof(GameUtils_GetEditorCameraPosition, CameraRotation) == 0x000018, "Member 'GameUtils_GetEditorCameraPosition::CameraRotation' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.GetIndecesForSortedArray
// 0x0020 (0x0020 - 0x0000)
struct GameUtils_GetIndecesForSortedArray final
{
public:
	TArray<class FString>                         StringList;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_GetIndecesForSortedArray) == 0x000008, "Wrong alignment on GameUtils_GetIndecesForSortedArray");
static_assert(sizeof(GameUtils_GetIndecesForSortedArray) == 0x000020, "Wrong size on GameUtils_GetIndecesForSortedArray");
static_assert(offsetof(GameUtils_GetIndecesForSortedArray, StringList) == 0x000000, "Member 'GameUtils_GetIndecesForSortedArray::StringList' has a wrong offset!");
static_assert(offsetof(GameUtils_GetIndecesForSortedArray, ReturnValue) == 0x000010, "Member 'GameUtils_GetIndecesForSortedArray::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.GetLookAtTarget
// 0x0058 (0x0058 - 0x0000)
struct GameUtils_GetLookAtTarget final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAoCTargetInfo                         ReturnValue;                                       // 0x0008(0x0050)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_GetLookAtTarget) == 0x000008, "Wrong alignment on GameUtils_GetLookAtTarget");
static_assert(sizeof(GameUtils_GetLookAtTarget) == 0x000058, "Wrong size on GameUtils_GetLookAtTarget");
static_assert(offsetof(GameUtils_GetLookAtTarget, PlayerController) == 0x000000, "Member 'GameUtils_GetLookAtTarget::PlayerController' has a wrong offset!");
static_assert(offsetof(GameUtils_GetLookAtTarget, ReturnValue) == 0x000008, "Member 'GameUtils_GetLookAtTarget::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.GetLowestLineTracedGroundImpact
// 0x0038 (0x0038 - 0x0000)
struct GameUtils_GetLowestLineTracedGroundImpact final
{
public:
	struct FVector                                Result;                                            // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        TraceStartLocations;                               // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         RayDistance;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_GetLowestLineTracedGroundImpact) == 0x000008, "Wrong alignment on GameUtils_GetLowestLineTracedGroundImpact");
static_assert(sizeof(GameUtils_GetLowestLineTracedGroundImpact) == 0x000038, "Wrong size on GameUtils_GetLowestLineTracedGroundImpact");
static_assert(offsetof(GameUtils_GetLowestLineTracedGroundImpact, Result) == 0x000000, "Member 'GameUtils_GetLowestLineTracedGroundImpact::Result' has a wrong offset!");
static_assert(offsetof(GameUtils_GetLowestLineTracedGroundImpact, WorldContextObject) == 0x000018, "Member 'GameUtils_GetLowestLineTracedGroundImpact::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameUtils_GetLowestLineTracedGroundImpact, TraceStartLocations) == 0x000020, "Member 'GameUtils_GetLowestLineTracedGroundImpact::TraceStartLocations' has a wrong offset!");
static_assert(offsetof(GameUtils_GetLowestLineTracedGroundImpact, RayDistance) == 0x000030, "Member 'GameUtils_GetLowestLineTracedGroundImpact::RayDistance' has a wrong offset!");
static_assert(offsetof(GameUtils_GetLowestLineTracedGroundImpact, ReturnValue) == 0x000034, "Member 'GameUtils_GetLowestLineTracedGroundImpact::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.GetNameHashIndex
// 0x0010 (0x0010 - 0x0000)
struct GameUtils_GetNameHashIndex final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_GetNameHashIndex) == 0x000008, "Wrong alignment on GameUtils_GetNameHashIndex");
static_assert(sizeof(GameUtils_GetNameHashIndex) == 0x000010, "Wrong size on GameUtils_GetNameHashIndex");
static_assert(offsetof(GameUtils_GetNameHashIndex, InObject) == 0x000000, "Member 'GameUtils_GetNameHashIndex::InObject' has a wrong offset!");
static_assert(offsetof(GameUtils_GetNameHashIndex, ReturnValue) == 0x000008, "Member 'GameUtils_GetNameHashIndex::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.GetOnlyAlphanumeric
// 0x0020 (0x0020 - 0x0000)
struct GameUtils_GetOnlyAlphanumeric final
{
public:
	class FString                                 Dirty;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_GetOnlyAlphanumeric) == 0x000008, "Wrong alignment on GameUtils_GetOnlyAlphanumeric");
static_assert(sizeof(GameUtils_GetOnlyAlphanumeric) == 0x000020, "Wrong size on GameUtils_GetOnlyAlphanumeric");
static_assert(offsetof(GameUtils_GetOnlyAlphanumeric, Dirty) == 0x000000, "Member 'GameUtils_GetOnlyAlphanumeric::Dirty' has a wrong offset!");
static_assert(offsetof(GameUtils_GetOnlyAlphanumeric, ReturnValue) == 0x000010, "Member 'GameUtils_GetOnlyAlphanumeric::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.GetOrientedBoundingBox
// 0x0070 (0x0070 - 0x0000)
struct GameUtils_GetOrientedBoundingBox final
{
public:
	const class UPrimitiveComponent*              PrimitiveComponent;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   OutBox;                                            // 0x0008(0x0038)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  OutOrientation;                                    // 0x0040(0x0020)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0xF];                                       // 0x0061(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_GetOrientedBoundingBox) == 0x000010, "Wrong alignment on GameUtils_GetOrientedBoundingBox");
static_assert(sizeof(GameUtils_GetOrientedBoundingBox) == 0x000070, "Wrong size on GameUtils_GetOrientedBoundingBox");
static_assert(offsetof(GameUtils_GetOrientedBoundingBox, PrimitiveComponent) == 0x000000, "Member 'GameUtils_GetOrientedBoundingBox::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(GameUtils_GetOrientedBoundingBox, OutBox) == 0x000008, "Member 'GameUtils_GetOrientedBoundingBox::OutBox' has a wrong offset!");
static_assert(offsetof(GameUtils_GetOrientedBoundingBox, OutOrientation) == 0x000040, "Member 'GameUtils_GetOrientedBoundingBox::OutOrientation' has a wrong offset!");
static_assert(offsetof(GameUtils_GetOrientedBoundingBox, ReturnValue) == 0x000060, "Member 'GameUtils_GetOrientedBoundingBox::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.GetSystemEnvironmentValue
// 0x0020 (0x0020 - 0x0000)
struct GameUtils_GetSystemEnvironmentValue final
{
public:
	class FString                                 EnvironmentVariable;                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_GetSystemEnvironmentValue) == 0x000008, "Wrong alignment on GameUtils_GetSystemEnvironmentValue");
static_assert(sizeof(GameUtils_GetSystemEnvironmentValue) == 0x000020, "Wrong size on GameUtils_GetSystemEnvironmentValue");
static_assert(offsetof(GameUtils_GetSystemEnvironmentValue, EnvironmentVariable) == 0x000000, "Member 'GameUtils_GetSystemEnvironmentValue::EnvironmentVariable' has a wrong offset!");
static_assert(offsetof(GameUtils_GetSystemEnvironmentValue, ReturnValue) == 0x000010, "Member 'GameUtils_GetSystemEnvironmentValue::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.GetTargetUnderCursor
// 0x0060 (0x0060 - 0x0000)
struct GameUtils_GetTargetUnderCursor final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsiderPlayer;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreHUD;                                        // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorePawns;                                      // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowOverlapHits;                                 // 0x000B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAoCTargetInfo                         ReturnValue;                                       // 0x0010(0x0050)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_GetTargetUnderCursor) == 0x000008, "Wrong alignment on GameUtils_GetTargetUnderCursor");
static_assert(sizeof(GameUtils_GetTargetUnderCursor) == 0x000060, "Wrong size on GameUtils_GetTargetUnderCursor");
static_assert(offsetof(GameUtils_GetTargetUnderCursor, PlayerController) == 0x000000, "Member 'GameUtils_GetTargetUnderCursor::PlayerController' has a wrong offset!");
static_assert(offsetof(GameUtils_GetTargetUnderCursor, bConsiderPlayer) == 0x000008, "Member 'GameUtils_GetTargetUnderCursor::bConsiderPlayer' has a wrong offset!");
static_assert(offsetof(GameUtils_GetTargetUnderCursor, bIgnoreHUD) == 0x000009, "Member 'GameUtils_GetTargetUnderCursor::bIgnoreHUD' has a wrong offset!");
static_assert(offsetof(GameUtils_GetTargetUnderCursor, bIgnorePawns) == 0x00000A, "Member 'GameUtils_GetTargetUnderCursor::bIgnorePawns' has a wrong offset!");
static_assert(offsetof(GameUtils_GetTargetUnderCursor, bAllowOverlapHits) == 0x00000B, "Member 'GameUtils_GetTargetUnderCursor::bAllowOverlapHits' has a wrong offset!");
static_assert(offsetof(GameUtils_GetTargetUnderCursor, ReturnValue) == 0x000010, "Member 'GameUtils_GetTargetUnderCursor::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.GetTargetUnderReticle
// 0x0060 (0x0060 - 0x0000)
struct GameUtils_GetTargetUnderReticle final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsiderPlayer;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorePawns;                                      // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowOverlapHits;                                 // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAoCTargetInfo                         ReturnValue;                                       // 0x0010(0x0050)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_GetTargetUnderReticle) == 0x000008, "Wrong alignment on GameUtils_GetTargetUnderReticle");
static_assert(sizeof(GameUtils_GetTargetUnderReticle) == 0x000060, "Wrong size on GameUtils_GetTargetUnderReticle");
static_assert(offsetof(GameUtils_GetTargetUnderReticle, PlayerController) == 0x000000, "Member 'GameUtils_GetTargetUnderReticle::PlayerController' has a wrong offset!");
static_assert(offsetof(GameUtils_GetTargetUnderReticle, bConsiderPlayer) == 0x000008, "Member 'GameUtils_GetTargetUnderReticle::bConsiderPlayer' has a wrong offset!");
static_assert(offsetof(GameUtils_GetTargetUnderReticle, bIgnorePawns) == 0x000009, "Member 'GameUtils_GetTargetUnderReticle::bIgnorePawns' has a wrong offset!");
static_assert(offsetof(GameUtils_GetTargetUnderReticle, bAllowOverlapHits) == 0x00000A, "Member 'GameUtils_GetTargetUnderReticle::bAllowOverlapHits' has a wrong offset!");
static_assert(offsetof(GameUtils_GetTargetUnderReticle, Distance) == 0x00000C, "Member 'GameUtils_GetTargetUnderReticle::Distance' has a wrong offset!");
static_assert(offsetof(GameUtils_GetTargetUnderReticle, ReturnValue) == 0x000010, "Member 'GameUtils_GetTargetUnderReticle::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.HasFlag
// 0x000C (0x000C - 0x0000)
struct GameUtils_HasFlag final
{
public:
	uint32                                        Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Flag;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_HasFlag) == 0x000004, "Wrong alignment on GameUtils_HasFlag");
static_assert(sizeof(GameUtils_HasFlag) == 0x00000C, "Wrong size on GameUtils_HasFlag");
static_assert(offsetof(GameUtils_HasFlag, Value) == 0x000000, "Member 'GameUtils_HasFlag::Value' has a wrong offset!");
static_assert(offsetof(GameUtils_HasFlag, Flag) == 0x000004, "Member 'GameUtils_HasFlag::Flag' has a wrong offset!");
static_assert(offsetof(GameUtils_HasFlag, ReturnValue) == 0x000008, "Member 'GameUtils_HasFlag::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.IsWithEditor
// 0x0001 (0x0001 - 0x0000)
struct GameUtils_IsWithEditor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_IsWithEditor) == 0x000001, "Wrong alignment on GameUtils_IsWithEditor");
static_assert(sizeof(GameUtils_IsWithEditor) == 0x000001, "Wrong size on GameUtils_IsWithEditor");
static_assert(offsetof(GameUtils_IsWithEditor, ReturnValue) == 0x000000, "Member 'GameUtils_IsWithEditor::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.LineTraceSingleByObjectType
// 0x0150 (0x0150 - 0x0000)
struct GameUtils_LineTraceSingleByObjectType final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectTypeQuery                              ObjectChannel;                                     // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      IgnoredObjectChannels;                             // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHitResult                             OutHit;                                            // 0x0060(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0148(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_LineTraceSingleByObjectType) == 0x000008, "Wrong alignment on GameUtils_LineTraceSingleByObjectType");
static_assert(sizeof(GameUtils_LineTraceSingleByObjectType) == 0x000150, "Wrong size on GameUtils_LineTraceSingleByObjectType");
static_assert(offsetof(GameUtils_LineTraceSingleByObjectType, WorldContextObject) == 0x000000, "Member 'GameUtils_LineTraceSingleByObjectType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByObjectType, Start) == 0x000008, "Member 'GameUtils_LineTraceSingleByObjectType::Start' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByObjectType, End) == 0x000020, "Member 'GameUtils_LineTraceSingleByObjectType::End' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByObjectType, ObjectChannel) == 0x000038, "Member 'GameUtils_LineTraceSingleByObjectType::ObjectChannel' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByObjectType, bTraceComplex) == 0x000039, "Member 'GameUtils_LineTraceSingleByObjectType::bTraceComplex' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByObjectType, IgnoredObjectChannels) == 0x000040, "Member 'GameUtils_LineTraceSingleByObjectType::IgnoredObjectChannels' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByObjectType, ActorsToIgnore) == 0x000050, "Member 'GameUtils_LineTraceSingleByObjectType::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByObjectType, OutHit) == 0x000060, "Member 'GameUtils_LineTraceSingleByObjectType::OutHit' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByObjectType, ReturnValue) == 0x000148, "Member 'GameUtils_LineTraceSingleByObjectType::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.LineTraceSingleByTraceType
// 0x0150 (0x0150 - 0x0000)
struct GameUtils_LineTraceSingleByTraceType final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      IgnoredObjectChannels;                             // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHitResult                             OutHit;                                            // 0x0060(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0148(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_LineTraceSingleByTraceType) == 0x000008, "Wrong alignment on GameUtils_LineTraceSingleByTraceType");
static_assert(sizeof(GameUtils_LineTraceSingleByTraceType) == 0x000150, "Wrong size on GameUtils_LineTraceSingleByTraceType");
static_assert(offsetof(GameUtils_LineTraceSingleByTraceType, WorldContextObject) == 0x000000, "Member 'GameUtils_LineTraceSingleByTraceType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByTraceType, Start) == 0x000008, "Member 'GameUtils_LineTraceSingleByTraceType::Start' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByTraceType, End) == 0x000020, "Member 'GameUtils_LineTraceSingleByTraceType::End' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByTraceType, TraceChannel) == 0x000038, "Member 'GameUtils_LineTraceSingleByTraceType::TraceChannel' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByTraceType, bTraceComplex) == 0x000039, "Member 'GameUtils_LineTraceSingleByTraceType::bTraceComplex' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByTraceType, IgnoredObjectChannels) == 0x000040, "Member 'GameUtils_LineTraceSingleByTraceType::IgnoredObjectChannels' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByTraceType, ActorsToIgnore) == 0x000050, "Member 'GameUtils_LineTraceSingleByTraceType::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByTraceType, OutHit) == 0x000060, "Member 'GameUtils_LineTraceSingleByTraceType::OutHit' has a wrong offset!");
static_assert(offsetof(GameUtils_LineTraceSingleByTraceType, ReturnValue) == 0x000148, "Member 'GameUtils_LineTraceSingleByTraceType::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.MoveFloor
// 0x0020 (0x0020 - 0x0000)
struct GameUtils_MoveFloor final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_MoveFloor) == 0x000008, "Wrong alignment on GameUtils_MoveFloor");
static_assert(sizeof(GameUtils_MoveFloor) == 0x000020, "Wrong size on GameUtils_MoveFloor");
static_assert(offsetof(GameUtils_MoveFloor, Component) == 0x000000, "Member 'GameUtils_MoveFloor::Component' has a wrong offset!");
static_assert(offsetof(GameUtils_MoveFloor, WorldLocation) == 0x000008, "Member 'GameUtils_MoveFloor::WorldLocation' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.PreDestroyFloor
// 0x0008 (0x0008 - 0x0000)
struct GameUtils_PreDestroyFloor final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_PreDestroyFloor) == 0x000008, "Wrong alignment on GameUtils_PreDestroyFloor");
static_assert(sizeof(GameUtils_PreDestroyFloor) == 0x000008, "Wrong size on GameUtils_PreDestroyFloor");
static_assert(offsetof(GameUtils_PreDestroyFloor, Component) == 0x000000, "Member 'GameUtils_PreDestroyFloor::Component' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.RemoveFlag
// 0x000C (0x000C - 0x0000)
struct GameUtils_RemoveFlag final
{
public:
	uint32                                        Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Flag;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_RemoveFlag) == 0x000004, "Wrong alignment on GameUtils_RemoveFlag");
static_assert(sizeof(GameUtils_RemoveFlag) == 0x00000C, "Wrong size on GameUtils_RemoveFlag");
static_assert(offsetof(GameUtils_RemoveFlag, Value) == 0x000000, "Member 'GameUtils_RemoveFlag::Value' has a wrong offset!");
static_assert(offsetof(GameUtils_RemoveFlag, Flag) == 0x000004, "Member 'GameUtils_RemoveFlag::Flag' has a wrong offset!");
static_assert(offsetof(GameUtils_RemoveFlag, ReturnValue) == 0x000008, "Member 'GameUtils_RemoveFlag::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.ResetGeometryCollectionPhysics
// 0x0008 (0x0008 - 0x0000)
struct GameUtils_ResetGeometryCollectionPhysics final
{
public:
	class UGeometryCollectionComponent*           GeometryCollection;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_ResetGeometryCollectionPhysics) == 0x000008, "Wrong alignment on GameUtils_ResetGeometryCollectionPhysics");
static_assert(sizeof(GameUtils_ResetGeometryCollectionPhysics) == 0x000008, "Wrong size on GameUtils_ResetGeometryCollectionPhysics");
static_assert(offsetof(GameUtils_ResetGeometryCollectionPhysics, GeometryCollection) == 0x000000, "Member 'GameUtils_ResetGeometryCollectionPhysics::GeometryCollection' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.RoundedConeOrientedAABBIntersection
// 0x00C0 (0x00C0 - 0x0000)
struct GameUtils_RoundedConeOrientedAABBIntersection final
{
public:
	struct FVector                                ConeOrigin;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConeNormal;                                        // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHalfAngle;                                     // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHeightMin;                                     // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHeightMax;                                     // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Box;                                               // 0x0040(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  BoxOrientation;                                    // 0x0080(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x00A0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UObject*                          WorldContextObject;                                // 0x00A8(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConeAABBIntersectionResult                   ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_RoundedConeOrientedAABBIntersection) == 0x000010, "Wrong alignment on GameUtils_RoundedConeOrientedAABBIntersection");
static_assert(sizeof(GameUtils_RoundedConeOrientedAABBIntersection) == 0x0000C0, "Wrong size on GameUtils_RoundedConeOrientedAABBIntersection");
static_assert(offsetof(GameUtils_RoundedConeOrientedAABBIntersection, ConeOrigin) == 0x000000, "Member 'GameUtils_RoundedConeOrientedAABBIntersection::ConeOrigin' has a wrong offset!");
static_assert(offsetof(GameUtils_RoundedConeOrientedAABBIntersection, ConeNormal) == 0x000018, "Member 'GameUtils_RoundedConeOrientedAABBIntersection::ConeNormal' has a wrong offset!");
static_assert(offsetof(GameUtils_RoundedConeOrientedAABBIntersection, ConeHalfAngle) == 0x000030, "Member 'GameUtils_RoundedConeOrientedAABBIntersection::ConeHalfAngle' has a wrong offset!");
static_assert(offsetof(GameUtils_RoundedConeOrientedAABBIntersection, ConeHeightMin) == 0x000034, "Member 'GameUtils_RoundedConeOrientedAABBIntersection::ConeHeightMin' has a wrong offset!");
static_assert(offsetof(GameUtils_RoundedConeOrientedAABBIntersection, ConeHeightMax) == 0x000038, "Member 'GameUtils_RoundedConeOrientedAABBIntersection::ConeHeightMax' has a wrong offset!");
static_assert(offsetof(GameUtils_RoundedConeOrientedAABBIntersection, Box) == 0x000040, "Member 'GameUtils_RoundedConeOrientedAABBIntersection::Box' has a wrong offset!");
static_assert(offsetof(GameUtils_RoundedConeOrientedAABBIntersection, BoxOrientation) == 0x000080, "Member 'GameUtils_RoundedConeOrientedAABBIntersection::BoxOrientation' has a wrong offset!");
static_assert(offsetof(GameUtils_RoundedConeOrientedAABBIntersection, bDebugDraw) == 0x0000A0, "Member 'GameUtils_RoundedConeOrientedAABBIntersection::bDebugDraw' has a wrong offset!");
static_assert(offsetof(GameUtils_RoundedConeOrientedAABBIntersection, WorldContextObject) == 0x0000A8, "Member 'GameUtils_RoundedConeOrientedAABBIntersection::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameUtils_RoundedConeOrientedAABBIntersection, ReturnValue) == 0x0000B0, "Member 'GameUtils_RoundedConeOrientedAABBIntersection::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.SaveTextToFile
// 0x0038 (0x0038 - 0x0000)
struct GameUtils_SaveTextToFile final
{
public:
	class FString                                 FilePath;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FileContent;                                       // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_SaveTextToFile) == 0x000008, "Wrong alignment on GameUtils_SaveTextToFile");
static_assert(sizeof(GameUtils_SaveTextToFile) == 0x000038, "Wrong size on GameUtils_SaveTextToFile");
static_assert(offsetof(GameUtils_SaveTextToFile, FilePath) == 0x000000, "Member 'GameUtils_SaveTextToFile::FilePath' has a wrong offset!");
static_assert(offsetof(GameUtils_SaveTextToFile, Filename) == 0x000010, "Member 'GameUtils_SaveTextToFile::Filename' has a wrong offset!");
static_assert(offsetof(GameUtils_SaveTextToFile, FileContent) == 0x000020, "Member 'GameUtils_SaveTextToFile::FileContent' has a wrong offset!");
static_assert(offsetof(GameUtils_SaveTextToFile, ReturnValue) == 0x000030, "Member 'GameUtils_SaveTextToFile::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.SetActorOutline
// 0x0010 (0x0010 - 0x0000)
struct GameUtils_SetActorOutline final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOn;                                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InColor;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_SetActorOutline) == 0x000008, "Wrong alignment on GameUtils_SetActorOutline");
static_assert(sizeof(GameUtils_SetActorOutline) == 0x000010, "Wrong size on GameUtils_SetActorOutline");
static_assert(offsetof(GameUtils_SetActorOutline, InActor) == 0x000000, "Member 'GameUtils_SetActorOutline::InActor' has a wrong offset!");
static_assert(offsetof(GameUtils_SetActorOutline, bOn) == 0x000008, "Member 'GameUtils_SetActorOutline::bOn' has a wrong offset!");
static_assert(offsetof(GameUtils_SetActorOutline, InColor) == 0x00000C, "Member 'GameUtils_SetActorOutline::InColor' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.ShiftArrayIndexCircular
// 0x0010 (0x0010 - 0x0000)
struct GameUtils_ShiftArrayIndexCircular final
{
public:
	int32                                         iRaw;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shift;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArrayLength;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUtils_ShiftArrayIndexCircular) == 0x000004, "Wrong alignment on GameUtils_ShiftArrayIndexCircular");
static_assert(sizeof(GameUtils_ShiftArrayIndexCircular) == 0x000010, "Wrong size on GameUtils_ShiftArrayIndexCircular");
static_assert(offsetof(GameUtils_ShiftArrayIndexCircular, iRaw) == 0x000000, "Member 'GameUtils_ShiftArrayIndexCircular::iRaw' has a wrong offset!");
static_assert(offsetof(GameUtils_ShiftArrayIndexCircular, Shift) == 0x000004, "Member 'GameUtils_ShiftArrayIndexCircular::Shift' has a wrong offset!");
static_assert(offsetof(GameUtils_ShiftArrayIndexCircular, ArrayLength) == 0x000008, "Member 'GameUtils_ShiftArrayIndexCircular::ArrayLength' has a wrong offset!");
static_assert(offsetof(GameUtils_ShiftArrayIndexCircular, ReturnValue) == 0x00000C, "Member 'GameUtils_ShiftArrayIndexCircular::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.SnapComponentToNearestSurface
// 0x0018 (0x0018 - 0x0000)
struct GameUtils_SnapComponentToNearestSurface final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSweepDist;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSweepDist;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepIncrement;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorePawn;                                       // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0015(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_SnapComponentToNearestSurface) == 0x000008, "Wrong alignment on GameUtils_SnapComponentToNearestSurface");
static_assert(sizeof(GameUtils_SnapComponentToNearestSurface) == 0x000018, "Wrong size on GameUtils_SnapComponentToNearestSurface");
static_assert(offsetof(GameUtils_SnapComponentToNearestSurface, Component) == 0x000000, "Member 'GameUtils_SnapComponentToNearestSurface::Component' has a wrong offset!");
static_assert(offsetof(GameUtils_SnapComponentToNearestSurface, MinSweepDist) == 0x000008, "Member 'GameUtils_SnapComponentToNearestSurface::MinSweepDist' has a wrong offset!");
static_assert(offsetof(GameUtils_SnapComponentToNearestSurface, MaxSweepDist) == 0x00000C, "Member 'GameUtils_SnapComponentToNearestSurface::MaxSweepDist' has a wrong offset!");
static_assert(offsetof(GameUtils_SnapComponentToNearestSurface, SweepIncrement) == 0x000010, "Member 'GameUtils_SnapComponentToNearestSurface::SweepIncrement' has a wrong offset!");
static_assert(offsetof(GameUtils_SnapComponentToNearestSurface, bIgnorePawn) == 0x000014, "Member 'GameUtils_SnapComponentToNearestSurface::bIgnorePawn' has a wrong offset!");
static_assert(offsetof(GameUtils_SnapComponentToNearestSurface, ReturnValue) == 0x000015, "Member 'GameUtils_SnapComponentToNearestSurface::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.SphereOrientedAABBIntersection
// 0x0090 (0x0090 - 0x0000)
struct GameUtils_SphereOrientedAABBIntersection final
{
public:
	struct FVector                                SphereCenter;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusSquared;                                     // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Box;                                               // 0x0020(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  BoxOrientation;                                    // 0x0060(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0080(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0xF];                                       // 0x0081(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_SphereOrientedAABBIntersection) == 0x000010, "Wrong alignment on GameUtils_SphereOrientedAABBIntersection");
static_assert(sizeof(GameUtils_SphereOrientedAABBIntersection) == 0x000090, "Wrong size on GameUtils_SphereOrientedAABBIntersection");
static_assert(offsetof(GameUtils_SphereOrientedAABBIntersection, SphereCenter) == 0x000000, "Member 'GameUtils_SphereOrientedAABBIntersection::SphereCenter' has a wrong offset!");
static_assert(offsetof(GameUtils_SphereOrientedAABBIntersection, RadiusSquared) == 0x000018, "Member 'GameUtils_SphereOrientedAABBIntersection::RadiusSquared' has a wrong offset!");
static_assert(offsetof(GameUtils_SphereOrientedAABBIntersection, Box) == 0x000020, "Member 'GameUtils_SphereOrientedAABBIntersection::Box' has a wrong offset!");
static_assert(offsetof(GameUtils_SphereOrientedAABBIntersection, BoxOrientation) == 0x000060, "Member 'GameUtils_SphereOrientedAABBIntersection::BoxOrientation' has a wrong offset!");
static_assert(offsetof(GameUtils_SphereOrientedAABBIntersection, ReturnValue) == 0x000080, "Member 'GameUtils_SphereOrientedAABBIntersection::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.GameUtils.TryGetFloatCurveValue
// 0x0020 (0x0020 - 0x0000)
struct GameUtils_TryGetFloatCurveValue final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutValue;                                          // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameUtils_TryGetFloatCurveValue) == 0x000008, "Wrong alignment on GameUtils_TryGetFloatCurveValue");
static_assert(sizeof(GameUtils_TryGetFloatCurveValue) == 0x000020, "Wrong size on GameUtils_TryGetFloatCurveValue");
static_assert(offsetof(GameUtils_TryGetFloatCurveValue, Montage) == 0x000000, "Member 'GameUtils_TryGetFloatCurveValue::Montage' has a wrong offset!");
static_assert(offsetof(GameUtils_TryGetFloatCurveValue, CurveName) == 0x000008, "Member 'GameUtils_TryGetFloatCurveValue::CurveName' has a wrong offset!");
static_assert(offsetof(GameUtils_TryGetFloatCurveValue, Time) == 0x000010, "Member 'GameUtils_TryGetFloatCurveValue::Time' has a wrong offset!");
static_assert(offsetof(GameUtils_TryGetFloatCurveValue, OutValue) == 0x000014, "Member 'GameUtils_TryGetFloatCurveValue::OutValue' has a wrong offset!");
static_assert(offsetof(GameUtils_TryGetFloatCurveValue, ReturnValue) == 0x000018, "Member 'GameUtils_TryGetFloatCurveValue::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.InfiniteLoopMonitorLibrary.CreateInfiniteLoopFileMonitor
// 0x0028 (0x0028 - 0x0000)
struct InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CrashFilePath;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckFrequencyMs;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInfiniteLoopMonitor*                   ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor) == 0x000008, "Wrong alignment on InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor");
static_assert(sizeof(InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor) == 0x000028, "Wrong size on InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor");
static_assert(offsetof(InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor, Name_0) == 0x000000, "Member 'InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor::Name_0' has a wrong offset!");
static_assert(offsetof(InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor, CrashFilePath) == 0x000008, "Member 'InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor::CrashFilePath' has a wrong offset!");
static_assert(offsetof(InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor, CheckFrequencyMs) == 0x000018, "Member 'InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor::CheckFrequencyMs' has a wrong offset!");
static_assert(offsetof(InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor, ReturnValue) == 0x000020, "Member 'InfiniteLoopMonitorLibrary_CreateInfiniteLoopFileMonitor::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.InfiniteLoopMonitorLibrary.CreateInfiniteLoopHeartbeatMonitor
// 0x0018 (0x0018 - 0x0000)
struct InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeartbeatTimeoutMs;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckFrequencyMs;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInfiniteLoopMonitor*                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor) == 0x000008, "Wrong alignment on InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor");
static_assert(sizeof(InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor) == 0x000018, "Wrong size on InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor");
static_assert(offsetof(InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor, Name_0) == 0x000000, "Member 'InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor::Name_0' has a wrong offset!");
static_assert(offsetof(InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor, HeartbeatTimeoutMs) == 0x000008, "Member 'InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor::HeartbeatTimeoutMs' has a wrong offset!");
static_assert(offsetof(InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor, CheckFrequencyMs) == 0x00000C, "Member 'InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor::CheckFrequencyMs' has a wrong offset!");
static_assert(offsetof(InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor, ReturnValue) == 0x000010, "Member 'InfiniteLoopMonitorLibrary_CreateInfiniteLoopHeartbeatMonitor::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.InfiniteLoopMonitorLibrary.RemoveInfiniteLoopMonitorByName
// 0x0008 (0x0008 - 0x0000)
struct InfiniteLoopMonitorLibrary_RemoveInfiniteLoopMonitorByName final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InfiniteLoopMonitorLibrary_RemoveInfiniteLoopMonitorByName) == 0x000004, "Wrong alignment on InfiniteLoopMonitorLibrary_RemoveInfiniteLoopMonitorByName");
static_assert(sizeof(InfiniteLoopMonitorLibrary_RemoveInfiniteLoopMonitorByName) == 0x000008, "Wrong size on InfiniteLoopMonitorLibrary_RemoveInfiniteLoopMonitorByName");
static_assert(offsetof(InfiniteLoopMonitorLibrary_RemoveInfiniteLoopMonitorByName, Name_0) == 0x000000, "Member 'InfiniteLoopMonitorLibrary_RemoveInfiniteLoopMonitorByName::Name_0' has a wrong offset!");

// Function GameUtilsPlugin.MathUtils.InverseLerp2DClamped
// 0x0048 (0x0048 - 0x0000)
struct MathUtils_InverseLerp2DClamped final
{
public:
	struct FBox2D                                 Range;                                             // 0x0000(0x0028)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              Input;                                             // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MathUtils_InverseLerp2DClamped) == 0x000008, "Wrong alignment on MathUtils_InverseLerp2DClamped");
static_assert(sizeof(MathUtils_InverseLerp2DClamped) == 0x000048, "Wrong size on MathUtils_InverseLerp2DClamped");
static_assert(offsetof(MathUtils_InverseLerp2DClamped, Range) == 0x000000, "Member 'MathUtils_InverseLerp2DClamped::Range' has a wrong offset!");
static_assert(offsetof(MathUtils_InverseLerp2DClamped, Input) == 0x000028, "Member 'MathUtils_InverseLerp2DClamped::Input' has a wrong offset!");
static_assert(offsetof(MathUtils_InverseLerp2DClamped, ReturnValue) == 0x000038, "Member 'MathUtils_InverseLerp2DClamped::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.MathUtils.InverseLerp2DUnclamped
// 0x0048 (0x0048 - 0x0000)
struct MathUtils_InverseLerp2DUnclamped final
{
public:
	struct FBox2D                                 Range;                                             // 0x0000(0x0028)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              Input;                                             // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MathUtils_InverseLerp2DUnclamped) == 0x000008, "Wrong alignment on MathUtils_InverseLerp2DUnclamped");
static_assert(sizeof(MathUtils_InverseLerp2DUnclamped) == 0x000048, "Wrong size on MathUtils_InverseLerp2DUnclamped");
static_assert(offsetof(MathUtils_InverseLerp2DUnclamped, Range) == 0x000000, "Member 'MathUtils_InverseLerp2DUnclamped::Range' has a wrong offset!");
static_assert(offsetof(MathUtils_InverseLerp2DUnclamped, Input) == 0x000028, "Member 'MathUtils_InverseLerp2DUnclamped::Input' has a wrong offset!");
static_assert(offsetof(MathUtils_InverseLerp2DUnclamped, ReturnValue) == 0x000038, "Member 'MathUtils_InverseLerp2DUnclamped::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.MeshUtils.GetSkeletalMeshVerts
// 0x0028 (0x0028 - 0x0000)
struct MeshUtils_GetSkeletalMeshVerts final
{
public:
	TArray<struct FVector>                        OutVertices;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	EVertexRenderType                             OutpuType;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 InComponent;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stride;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecificLodIndex;                                  // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MeshUtils_GetSkeletalMeshVerts) == 0x000008, "Wrong alignment on MeshUtils_GetSkeletalMeshVerts");
static_assert(sizeof(MeshUtils_GetSkeletalMeshVerts) == 0x000028, "Wrong size on MeshUtils_GetSkeletalMeshVerts");
static_assert(offsetof(MeshUtils_GetSkeletalMeshVerts, OutVertices) == 0x000000, "Member 'MeshUtils_GetSkeletalMeshVerts::OutVertices' has a wrong offset!");
static_assert(offsetof(MeshUtils_GetSkeletalMeshVerts, OutpuType) == 0x000010, "Member 'MeshUtils_GetSkeletalMeshVerts::OutpuType' has a wrong offset!");
static_assert(offsetof(MeshUtils_GetSkeletalMeshVerts, InComponent) == 0x000018, "Member 'MeshUtils_GetSkeletalMeshVerts::InComponent' has a wrong offset!");
static_assert(offsetof(MeshUtils_GetSkeletalMeshVerts, Stride) == 0x000020, "Member 'MeshUtils_GetSkeletalMeshVerts::Stride' has a wrong offset!");
static_assert(offsetof(MeshUtils_GetSkeletalMeshVerts, SpecificLodIndex) == 0x000024, "Member 'MeshUtils_GetSkeletalMeshVerts::SpecificLodIndex' has a wrong offset!");

// Function GameUtilsPlugin.MeshUtils.GetStaticMeshVerts
// 0x00B0 (0x00B0 - 0x0000)
struct MeshUtils_GetStaticMeshVerts final
{
public:
	TArray<struct FVector>                        OutVertices;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	EVertexRenderType                             OutpuType;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   InMesh;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InWorldLoc;                                        // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InLocalTransform;                                  // 0x0040(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stride;                                            // 0x00A0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecificLodIndex;                                  // 0x00A4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MeshUtils_GetStaticMeshVerts) == 0x000010, "Wrong alignment on MeshUtils_GetStaticMeshVerts");
static_assert(sizeof(MeshUtils_GetStaticMeshVerts) == 0x0000B0, "Wrong size on MeshUtils_GetStaticMeshVerts");
static_assert(offsetof(MeshUtils_GetStaticMeshVerts, OutVertices) == 0x000000, "Member 'MeshUtils_GetStaticMeshVerts::OutVertices' has a wrong offset!");
static_assert(offsetof(MeshUtils_GetStaticMeshVerts, OutpuType) == 0x000010, "Member 'MeshUtils_GetStaticMeshVerts::OutpuType' has a wrong offset!");
static_assert(offsetof(MeshUtils_GetStaticMeshVerts, InMesh) == 0x000018, "Member 'MeshUtils_GetStaticMeshVerts::InMesh' has a wrong offset!");
static_assert(offsetof(MeshUtils_GetStaticMeshVerts, InWorldLoc) == 0x000020, "Member 'MeshUtils_GetStaticMeshVerts::InWorldLoc' has a wrong offset!");
static_assert(offsetof(MeshUtils_GetStaticMeshVerts, InLocalTransform) == 0x000040, "Member 'MeshUtils_GetStaticMeshVerts::InLocalTransform' has a wrong offset!");
static_assert(offsetof(MeshUtils_GetStaticMeshVerts, Stride) == 0x0000A0, "Member 'MeshUtils_GetStaticMeshVerts::Stride' has a wrong offset!");
static_assert(offsetof(MeshUtils_GetStaticMeshVerts, SpecificLodIndex) == 0x0000A4, "Member 'MeshUtils_GetStaticMeshVerts::SpecificLodIndex' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.FindFirstInBox
// 0x0230 (0x0230 - 0x0000)
struct OctreeUtil_FindFirstInBox final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01B0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extents;                                           // 0x0210(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0228(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctreeUtil_FindFirstInBox) == 0x000010, "Wrong alignment on OctreeUtil_FindFirstInBox");
static_assert(sizeof(OctreeUtil_FindFirstInBox) == 0x000230, "Wrong size on OctreeUtil_FindFirstInBox");
static_assert(offsetof(OctreeUtil_FindFirstInBox, Octree) == 0x000000, "Member 'OctreeUtil_FindFirstInBox::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_FindFirstInBox, Transform) == 0x0001B0, "Member 'OctreeUtil_FindFirstInBox::Transform' has a wrong offset!");
static_assert(offsetof(OctreeUtil_FindFirstInBox, Extents) == 0x000210, "Member 'OctreeUtil_FindFirstInBox::Extents' has a wrong offset!");
static_assert(offsetof(OctreeUtil_FindFirstInBox, ReturnValue) == 0x000228, "Member 'OctreeUtil_FindFirstInBox::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.FindFirstInCapsule
// 0x0220 (0x0220 - 0x0000)
struct OctreeUtil_FindFirstInCapsule final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01B0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0210(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0214(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0218(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctreeUtil_FindFirstInCapsule) == 0x000010, "Wrong alignment on OctreeUtil_FindFirstInCapsule");
static_assert(sizeof(OctreeUtil_FindFirstInCapsule) == 0x000220, "Wrong size on OctreeUtil_FindFirstInCapsule");
static_assert(offsetof(OctreeUtil_FindFirstInCapsule, Octree) == 0x000000, "Member 'OctreeUtil_FindFirstInCapsule::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_FindFirstInCapsule, Transform) == 0x0001B0, "Member 'OctreeUtil_FindFirstInCapsule::Transform' has a wrong offset!");
static_assert(offsetof(OctreeUtil_FindFirstInCapsule, Radius) == 0x000210, "Member 'OctreeUtil_FindFirstInCapsule::Radius' has a wrong offset!");
static_assert(offsetof(OctreeUtil_FindFirstInCapsule, HalfHeight) == 0x000214, "Member 'OctreeUtil_FindFirstInCapsule::HalfHeight' has a wrong offset!");
static_assert(offsetof(OctreeUtil_FindFirstInCapsule, ReturnValue) == 0x000218, "Member 'OctreeUtil_FindFirstInCapsule::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.FindFirstInSphere
// 0x0220 (0x0220 - 0x0000)
struct OctreeUtil_FindFirstInSphere final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01B0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0210(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ReturnValue;                                       // 0x0218(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctreeUtil_FindFirstInSphere) == 0x000010, "Wrong alignment on OctreeUtil_FindFirstInSphere");
static_assert(sizeof(OctreeUtil_FindFirstInSphere) == 0x000220, "Wrong size on OctreeUtil_FindFirstInSphere");
static_assert(offsetof(OctreeUtil_FindFirstInSphere, Octree) == 0x000000, "Member 'OctreeUtil_FindFirstInSphere::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_FindFirstInSphere, Transform) == 0x0001B0, "Member 'OctreeUtil_FindFirstInSphere::Transform' has a wrong offset!");
static_assert(offsetof(OctreeUtil_FindFirstInSphere, Radius) == 0x000210, "Member 'OctreeUtil_FindFirstInSphere::Radius' has a wrong offset!");
static_assert(offsetof(OctreeUtil_FindFirstInSphere, ReturnValue) == 0x000218, "Member 'OctreeUtil_FindFirstInSphere::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.FollowMovements
// 0x01B0 (0x01B0 - 0x0000)
struct OctreeUtil_FollowMovements final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctreeUtil_FollowMovements) == 0x000008, "Wrong alignment on OctreeUtil_FollowMovements");
static_assert(sizeof(OctreeUtil_FollowMovements) == 0x0001B0, "Wrong size on OctreeUtil_FollowMovements");
static_assert(offsetof(OctreeUtil_FollowMovements, Octree) == 0x000000, "Member 'OctreeUtil_FollowMovements::Octree' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.GetAllInBox
// 0x0240 (0x0240 - 0x0000)
struct OctreeUtil_GetAllInBox final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01B0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extents;                                           // 0x0210(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        Results;                                           // 0x0228(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctreeUtil_GetAllInBox) == 0x000010, "Wrong alignment on OctreeUtil_GetAllInBox");
static_assert(sizeof(OctreeUtil_GetAllInBox) == 0x000240, "Wrong size on OctreeUtil_GetAllInBox");
static_assert(offsetof(OctreeUtil_GetAllInBox, Octree) == 0x000000, "Member 'OctreeUtil_GetAllInBox::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_GetAllInBox, Transform) == 0x0001B0, "Member 'OctreeUtil_GetAllInBox::Transform' has a wrong offset!");
static_assert(offsetof(OctreeUtil_GetAllInBox, Extents) == 0x000210, "Member 'OctreeUtil_GetAllInBox::Extents' has a wrong offset!");
static_assert(offsetof(OctreeUtil_GetAllInBox, Results) == 0x000228, "Member 'OctreeUtil_GetAllInBox::Results' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.GetAllInCapsule
// 0x0230 (0x0230 - 0x0000)
struct OctreeUtil_GetAllInCapsule final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01B0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0210(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0214(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        Results;                                           // 0x0218(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctreeUtil_GetAllInCapsule) == 0x000010, "Wrong alignment on OctreeUtil_GetAllInCapsule");
static_assert(sizeof(OctreeUtil_GetAllInCapsule) == 0x000230, "Wrong size on OctreeUtil_GetAllInCapsule");
static_assert(offsetof(OctreeUtil_GetAllInCapsule, Octree) == 0x000000, "Member 'OctreeUtil_GetAllInCapsule::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_GetAllInCapsule, Transform) == 0x0001B0, "Member 'OctreeUtil_GetAllInCapsule::Transform' has a wrong offset!");
static_assert(offsetof(OctreeUtil_GetAllInCapsule, Radius) == 0x000210, "Member 'OctreeUtil_GetAllInCapsule::Radius' has a wrong offset!");
static_assert(offsetof(OctreeUtil_GetAllInCapsule, HalfHeight) == 0x000214, "Member 'OctreeUtil_GetAllInCapsule::HalfHeight' has a wrong offset!");
static_assert(offsetof(OctreeUtil_GetAllInCapsule, Results) == 0x000218, "Member 'OctreeUtil_GetAllInCapsule::Results' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.GetAllInSphere
// 0x0230 (0x0230 - 0x0000)
struct OctreeUtil_GetAllInSphere final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01B0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0210(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        Results;                                           // 0x0218(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctreeUtil_GetAllInSphere) == 0x000010, "Wrong alignment on OctreeUtil_GetAllInSphere");
static_assert(sizeof(OctreeUtil_GetAllInSphere) == 0x000230, "Wrong size on OctreeUtil_GetAllInSphere");
static_assert(offsetof(OctreeUtil_GetAllInSphere, Octree) == 0x000000, "Member 'OctreeUtil_GetAllInSphere::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_GetAllInSphere, Transform) == 0x0001B0, "Member 'OctreeUtil_GetAllInSphere::Transform' has a wrong offset!");
static_assert(offsetof(OctreeUtil_GetAllInSphere, Radius) == 0x000210, "Member 'OctreeUtil_GetAllInSphere::Radius' has a wrong offset!");
static_assert(offsetof(OctreeUtil_GetAllInSphere, Results) == 0x000218, "Member 'OctreeUtil_GetAllInSphere::Results' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.InsertActorWithBox
// 0x01D8 (0x01D8 - 0x0000)
struct OctreeUtil_InsertActorWithBox final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x01B0(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extents;                                           // 0x01B8(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          followMovement;                                    // 0x01D0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01D1(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D2[0x6];                                      // 0x01D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctreeUtil_InsertActorWithBox) == 0x000008, "Wrong alignment on OctreeUtil_InsertActorWithBox");
static_assert(sizeof(OctreeUtil_InsertActorWithBox) == 0x0001D8, "Wrong size on OctreeUtil_InsertActorWithBox");
static_assert(offsetof(OctreeUtil_InsertActorWithBox, Octree) == 0x000000, "Member 'OctreeUtil_InsertActorWithBox::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithBox, Actor) == 0x0001B0, "Member 'OctreeUtil_InsertActorWithBox::Actor' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithBox, Extents) == 0x0001B8, "Member 'OctreeUtil_InsertActorWithBox::Extents' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithBox, followMovement) == 0x0001D0, "Member 'OctreeUtil_InsertActorWithBox::followMovement' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithBox, ReturnValue) == 0x0001D1, "Member 'OctreeUtil_InsertActorWithBox::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.InsertActorWithCapsule
// 0x01C8 (0x01C8 - 0x0000)
struct OctreeUtil_InsertActorWithCapsule final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x01B0(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x01B8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x01BC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          followMovement;                                    // 0x01C0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01C1(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C2[0x6];                                      // 0x01C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctreeUtil_InsertActorWithCapsule) == 0x000008, "Wrong alignment on OctreeUtil_InsertActorWithCapsule");
static_assert(sizeof(OctreeUtil_InsertActorWithCapsule) == 0x0001C8, "Wrong size on OctreeUtil_InsertActorWithCapsule");
static_assert(offsetof(OctreeUtil_InsertActorWithCapsule, Octree) == 0x000000, "Member 'OctreeUtil_InsertActorWithCapsule::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithCapsule, Actor) == 0x0001B0, "Member 'OctreeUtil_InsertActorWithCapsule::Actor' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithCapsule, Radius) == 0x0001B8, "Member 'OctreeUtil_InsertActorWithCapsule::Radius' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithCapsule, HalfHeight) == 0x0001BC, "Member 'OctreeUtil_InsertActorWithCapsule::HalfHeight' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithCapsule, followMovement) == 0x0001C0, "Member 'OctreeUtil_InsertActorWithCapsule::followMovement' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithCapsule, ReturnValue) == 0x0001C1, "Member 'OctreeUtil_InsertActorWithCapsule::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.InsertActorWithSphere
// 0x01C0 (0x01C0 - 0x0000)
struct OctreeUtil_InsertActorWithSphere final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x01B0(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x01B8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          followMovement;                                    // 0x01BC(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01BD(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BE[0x2];                                      // 0x01BE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctreeUtil_InsertActorWithSphere) == 0x000008, "Wrong alignment on OctreeUtil_InsertActorWithSphere");
static_assert(sizeof(OctreeUtil_InsertActorWithSphere) == 0x0001C0, "Wrong size on OctreeUtil_InsertActorWithSphere");
static_assert(offsetof(OctreeUtil_InsertActorWithSphere, Octree) == 0x000000, "Member 'OctreeUtil_InsertActorWithSphere::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithSphere, Actor) == 0x0001B0, "Member 'OctreeUtil_InsertActorWithSphere::Actor' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithSphere, Radius) == 0x0001B8, "Member 'OctreeUtil_InsertActorWithSphere::Radius' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithSphere, followMovement) == 0x0001BC, "Member 'OctreeUtil_InsertActorWithSphere::followMovement' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertActorWithSphere, ReturnValue) == 0x0001BD, "Member 'OctreeUtil_InsertActorWithSphere::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.InsertBox
// 0x0240 (0x0240 - 0x0000)
struct OctreeUtil_InsertBox final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01B0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extents;                                           // 0x0210(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0228(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0230(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0xF];                                      // 0x0231(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctreeUtil_InsertBox) == 0x000010, "Wrong alignment on OctreeUtil_InsertBox");
static_assert(sizeof(OctreeUtil_InsertBox) == 0x000240, "Wrong size on OctreeUtil_InsertBox");
static_assert(offsetof(OctreeUtil_InsertBox, Octree) == 0x000000, "Member 'OctreeUtil_InsertBox::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertBox, Transform) == 0x0001B0, "Member 'OctreeUtil_InsertBox::Transform' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertBox, Extents) == 0x000210, "Member 'OctreeUtil_InsertBox::Extents' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertBox, Object) == 0x000228, "Member 'OctreeUtil_InsertBox::Object' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertBox, ReturnValue) == 0x000230, "Member 'OctreeUtil_InsertBox::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.InsertCapsule
// 0x0230 (0x0230 - 0x0000)
struct OctreeUtil_InsertCapsule final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01B0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0210(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0214(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0218(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0220(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0xF];                                      // 0x0221(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctreeUtil_InsertCapsule) == 0x000010, "Wrong alignment on OctreeUtil_InsertCapsule");
static_assert(sizeof(OctreeUtil_InsertCapsule) == 0x000230, "Wrong size on OctreeUtil_InsertCapsule");
static_assert(offsetof(OctreeUtil_InsertCapsule, Octree) == 0x000000, "Member 'OctreeUtil_InsertCapsule::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertCapsule, Transform) == 0x0001B0, "Member 'OctreeUtil_InsertCapsule::Transform' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertCapsule, Radius) == 0x000210, "Member 'OctreeUtil_InsertCapsule::Radius' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertCapsule, HalfHeight) == 0x000214, "Member 'OctreeUtil_InsertCapsule::HalfHeight' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertCapsule, Object) == 0x000218, "Member 'OctreeUtil_InsertCapsule::Object' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertCapsule, ReturnValue) == 0x000220, "Member 'OctreeUtil_InsertCapsule::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.InsertCharacter
// 0x01C0 (0x01C0 - 0x0000)
struct OctreeUtil_InsertCharacter final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class ACharacter*                             Character;                                         // 0x01B0(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          followMovement;                                    // 0x01B8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01B9(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BA[0x6];                                      // 0x01BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctreeUtil_InsertCharacter) == 0x000008, "Wrong alignment on OctreeUtil_InsertCharacter");
static_assert(sizeof(OctreeUtil_InsertCharacter) == 0x0001C0, "Wrong size on OctreeUtil_InsertCharacter");
static_assert(offsetof(OctreeUtil_InsertCharacter, Octree) == 0x000000, "Member 'OctreeUtil_InsertCharacter::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertCharacter, Character) == 0x0001B0, "Member 'OctreeUtil_InsertCharacter::Character' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertCharacter, followMovement) == 0x0001B8, "Member 'OctreeUtil_InsertCharacter::followMovement' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertCharacter, ReturnValue) == 0x0001B9, "Member 'OctreeUtil_InsertCharacter::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.InsertPoint
// 0x01D8 (0x01D8 - 0x0000)
struct OctreeUtil_InsertPoint final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Point;                                             // 0x01B0(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x01C8(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01D0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctreeUtil_InsertPoint) == 0x000008, "Wrong alignment on OctreeUtil_InsertPoint");
static_assert(sizeof(OctreeUtil_InsertPoint) == 0x0001D8, "Wrong size on OctreeUtil_InsertPoint");
static_assert(offsetof(OctreeUtil_InsertPoint, Octree) == 0x000000, "Member 'OctreeUtil_InsertPoint::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertPoint, Point) == 0x0001B0, "Member 'OctreeUtil_InsertPoint::Point' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertPoint, Object) == 0x0001C8, "Member 'OctreeUtil_InsertPoint::Object' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertPoint, ReturnValue) == 0x0001D0, "Member 'OctreeUtil_InsertPoint::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.InsertSphere
// 0x0230 (0x0230 - 0x0000)
struct OctreeUtil_InsertSphere final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01B0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0210(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Object;                                            // 0x0218(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0220(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0xF];                                      // 0x0221(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctreeUtil_InsertSphere) == 0x000010, "Wrong alignment on OctreeUtil_InsertSphere");
static_assert(sizeof(OctreeUtil_InsertSphere) == 0x000230, "Wrong size on OctreeUtil_InsertSphere");
static_assert(offsetof(OctreeUtil_InsertSphere, Octree) == 0x000000, "Member 'OctreeUtil_InsertSphere::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertSphere, Transform) == 0x0001B0, "Member 'OctreeUtil_InsertSphere::Transform' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertSphere, Radius) == 0x000210, "Member 'OctreeUtil_InsertSphere::Radius' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertSphere, Object) == 0x000218, "Member 'OctreeUtil_InsertSphere::Object' has a wrong offset!");
static_assert(offsetof(OctreeUtil_InsertSphere, ReturnValue) == 0x000220, "Member 'OctreeUtil_InsertSphere::ReturnValue' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.Move
// 0x0220 (0x0220 - 0x0000)
struct OctreeUtil_Move final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01B0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0210(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctreeUtil_Move) == 0x000010, "Wrong alignment on OctreeUtil_Move");
static_assert(sizeof(OctreeUtil_Move) == 0x000220, "Wrong size on OctreeUtil_Move");
static_assert(offsetof(OctreeUtil_Move, Octree) == 0x000000, "Member 'OctreeUtil_Move::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_Move, Transform) == 0x0001B0, "Member 'OctreeUtil_Move::Transform' has a wrong offset!");
static_assert(offsetof(OctreeUtil_Move, Object) == 0x000210, "Member 'OctreeUtil_Move::Object' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.Remove
// 0x01B8 (0x01B8 - 0x0000)
struct OctreeUtil_Remove final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x01B0(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctreeUtil_Remove) == 0x000008, "Wrong alignment on OctreeUtil_Remove");
static_assert(sizeof(OctreeUtil_Remove) == 0x0001B8, "Wrong size on OctreeUtil_Remove");
static_assert(offsetof(OctreeUtil_Remove, Octree) == 0x000000, "Member 'OctreeUtil_Remove::Octree' has a wrong offset!");
static_assert(offsetof(OctreeUtil_Remove, Object) == 0x0001B0, "Member 'OctreeUtil_Remove::Object' has a wrong offset!");

// Function GameUtilsPlugin.OctreeUtil.RemoveAll
// 0x01B0 (0x01B0 - 0x0000)
struct OctreeUtil_RemoveAll final
{
public:
	struct FOctree                                Octree;                                            // 0x0000(0x01B0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctreeUtil_RemoveAll) == 0x000008, "Wrong alignment on OctreeUtil_RemoveAll");
static_assert(sizeof(OctreeUtil_RemoveAll) == 0x0001B0, "Wrong size on OctreeUtil_RemoveAll");
static_assert(offsetof(OctreeUtil_RemoveAll, Octree) == 0x000000, "Member 'OctreeUtil_RemoveAll::Octree' has a wrong offset!");

}

