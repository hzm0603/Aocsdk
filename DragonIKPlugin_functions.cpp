#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DragonIKPlugin

#include "Basic.hpp"

#include "DragonIKPlugin_classes.hpp"
#include "DragonIKPlugin_parameters.hpp"


namespace SDK
{

// Function DragonIKPlugin.DragonIKFootStepsComponent.CallFootSteps
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class FName                             bone_name                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                foot_transform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   height_difference                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                hit_info                                               (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDragonIKFootStepsComponent::CallFootSteps(class FName bone_name, const struct FTransform& foot_transform, float height_difference, const struct FHitResult& hit_info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKFootStepsComponent", "CallFootSteps");

	Params::DragonIKFootStepsComponent_CallFootSteps Parms{};

	Parms.bone_name = bone_name;
	Parms.foot_transform = std::move(foot_transform);
	Parms.height_difference = height_difference;
	Parms.hit_info = std::move(hit_info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.CacheSimulationStates
// (Final, Native, Public, BlueprintCallable)

void UDragonIKPhysicsComponent::CacheSimulationStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "CacheSimulationStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Control_Bone_Handle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             bone_name                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                override_transform                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Control_Bone_Handle(class FName bone_name, const struct FTransform& override_transform, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Control_Bone_Handle");

	Params::DragonIKPhysicsComponent_Control_Bone_Handle Parms{};

	Parms.bone_name = bone_name;
	Parms.override_transform = std::move(override_transform);
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.FirstTimeInitialization
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::FirstTimeInitialization(class USkeletalMeshComponent* skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "FirstTimeInitialization");

	Params::DragonIKPhysicsComponent_FirstTimeInitialization Parms{};

	Parms.skeleton_input = skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Modify_Reset_Bone_Info
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              bone_list                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Modify_Reset_Bone_Info(const TArray<class FName>& bone_list)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Modify_Reset_Bone_Info");

	Params::DragonIKPhysicsComponent_Modify_Reset_Bone_Info Parms{};

	Parms.bone_list = std::move(bone_list);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_CacheSimulationStates
// (Net, Native, Event, NetMulticast, Public, NetValidate)

void UDragonIKPhysicsComponent::Multicast_CacheSimulationStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_CacheSimulationStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_Control_Bone_Handle
// (Net, Native, Event, NetMulticast, Public, HasDefaults, NetValidate)
// Parameters:
// class FName                             bone_name                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                override_transform                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_Control_Bone_Handle(class FName bone_name, const struct FTransform& override_transform, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_Control_Bone_Handle");

	Params::DragonIKPhysicsComponent_Multicast_Control_Bone_Handle Parms{};

	Parms.bone_name = bone_name;
	Parms.override_transform = std::move(override_transform);
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_DragonIKSimulatePhysics
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           SKMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_DragonIKSimulatePhysics(class USkeletalMeshComponent* SKMesh, class FName BoneName, bool IncludeSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_DragonIKSimulatePhysics");

	Params::DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics Parms{};

	Parms.SKMesh = SKMesh;
	Parms.BoneName = BoneName;
	Parms.IncludeSelf = IncludeSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_FirstTimeInitialization
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_FirstTimeInitialization(class USkeletalMeshComponent* skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_FirstTimeInitialization");

	Params::DragonIKPhysicsComponent_Multicast_FirstTimeInitialization Parms{};

	Parms.skeleton_input = skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_Modify_Reset_Bone_Info
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// const TArray<class FName>&              bone_list                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_Modify_Reset_Bone_Info(const TArray<class FName>& bone_list)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_Modify_Reset_Bone_Info");

	Params::DragonIKPhysicsComponent_Multicast_Modify_Reset_Bone_Info Parms{};

	Parms.bone_list = std::move(bone_list);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_OnHitCallback
// (Net, Native, Event, NetMulticast, Public, HasDefaults, NetValidate)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class FName                       Optional_Override_Hit_Bone_Name                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   hit_location                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   hit_impulse_direction                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      hit_bone_name                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_OnHitCallback(const struct FHitResult& Hit, const class FName Optional_Override_Hit_Bone_Name, const struct FVector& hit_location, const struct FVector& hit_impulse_direction, const class FName& hit_bone_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_OnHitCallback");

	Params::DragonIKPhysicsComponent_Multicast_OnHitCallback Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Optional_Override_Hit_Bone_Name = Optional_Override_Hit_Bone_Name;
	Parms.hit_location = std::move(hit_location);
	Parms.hit_impulse_direction = std::move(hit_impulse_direction);
	Parms.hit_bone_name = hit_bone_name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_PerformActiveRagdoll
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// float                                   pelvis_mass_override                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_PerformActiveRagdoll(float pelvis_mass_override)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_PerformActiveRagdoll");

	Params::DragonIKPhysicsComponent_Multicast_PerformActiveRagdoll Parms{};

	Parms.pelvis_mass_override = pelvis_mass_override;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_ReGrabAllHandles
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// bool                                    exit_ragdoll                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_ReGrabAllHandles(bool exit_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_ReGrabAllHandles");

	Params::DragonIKPhysicsComponent_Multicast_ReGrabAllHandles Parms{};

	Parms.exit_ragdoll = exit_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_ReleaseAllHandles
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// bool                                    go_ragdoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_ReleaseAllHandles(bool go_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_ReleaseAllHandles");

	Params::DragonIKPhysicsComponent_Multicast_ReleaseAllHandles Parms{};

	Parms.go_ragdoll = go_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_SetInterpolation
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// int32                                   inter_value                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_SetInterpolation(int32 inter_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_SetInterpolation");

	Params::DragonIKPhysicsComponent_Multicast_SetInterpolation Parms{};

	Parms.inter_value = inter_value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_UpdatePhysanimData
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// int32                                   LinearStrength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LinearDamp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularDamp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_UpdatePhysanimData(int32 LinearStrength, int32 AngularStrength, int32 LinearDamp, int32 AngularDamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_UpdatePhysanimData");

	Params::DragonIKPhysicsComponent_Multicast_UpdatePhysanimData Parms{};

	Parms.LinearStrength = LinearStrength;
	Parms.AngularStrength = AngularStrength;
	Parms.LinearDamp = LinearDamp;
	Parms.AngularDamp = AngularDamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.OnHitCallback
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             Optional_Override_Hit_Bone_Name                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         hit_location                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         hit_impulse_direction                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            hit_bone_name                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::OnHitCallback(const struct FHitResult& Hit, class FName Optional_Override_Hit_Bone_Name, struct FVector* hit_location, struct FVector* hit_impulse_direction, class FName* hit_bone_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "OnHitCallback");

	Params::DragonIKPhysicsComponent_OnHitCallback Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Optional_Override_Hit_Bone_Name = Optional_Override_Hit_Bone_Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (hit_location != nullptr)
		*hit_location = std::move(Parms.hit_location);

	if (hit_impulse_direction != nullptr)
		*hit_impulse_direction = std::move(Parms.hit_impulse_direction);

	if (hit_bone_name != nullptr)
		*hit_bone_name = Parms.hit_bone_name;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.PerformActiveRagdoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   pelvis_mass_override                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::PerformActiveRagdoll(float pelvis_mass_override)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "PerformActiveRagdoll");

	Params::DragonIKPhysicsComponent_PerformActiveRagdoll Parms{};

	Parms.pelvis_mass_override = pelvis_mass_override;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.ReGrabAllHandles
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    exit_ragdoll                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::ReGrabAllHandles(bool exit_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "ReGrabAllHandles");

	Params::DragonIKPhysicsComponent_ReGrabAllHandles Parms{};

	Parms.exit_ragdoll = exit_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.ReleaseAllHandles
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    go_ragdoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::ReleaseAllHandles(bool go_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "ReleaseAllHandles");

	Params::DragonIKPhysicsComponent_ReleaseAllHandles Parms{};

	Parms.go_ragdoll = go_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_CacheSimulationStates
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void UDragonIKPhysicsComponent::Server_CacheSimulationStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_CacheSimulationStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_Control_Bone_Handle
// (Net, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             bone_name                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                override_transform                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_Control_Bone_Handle(class FName bone_name, const struct FTransform& override_transform, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_Control_Bone_Handle");

	Params::DragonIKPhysicsComponent_Server_Control_Bone_Handle Parms{};

	Parms.bone_name = bone_name;
	Parms.override_transform = std::move(override_transform);
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_DragonIKSimulatePhysics
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           SKMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_DragonIKSimulatePhysics(class USkeletalMeshComponent* SKMesh, class FName BoneName, bool IncludeSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_DragonIKSimulatePhysics");

	Params::DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics Parms{};

	Parms.SKMesh = SKMesh;
	Parms.BoneName = BoneName;
	Parms.IncludeSelf = IncludeSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_FirstTimeInitialization
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_FirstTimeInitialization(class USkeletalMeshComponent* skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_FirstTimeInitialization");

	Params::DragonIKPhysicsComponent_Server_FirstTimeInitialization Parms{};

	Parms.skeleton_input = skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_Modify_Reset_Bone_Info
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// const TArray<class FName>&              bone_list                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_Modify_Reset_Bone_Info(const TArray<class FName>& bone_list)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_Modify_Reset_Bone_Info");

	Params::DragonIKPhysicsComponent_Server_Modify_Reset_Bone_Info Parms{};

	Parms.bone_list = std::move(bone_list);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_OnHitCallback
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class FName                       Optional_Override_Hit_Bone_Name                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   hit_location                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   hit_impulse_direction                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      hit_bone_name                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_OnHitCallback(const struct FHitResult& Hit, const class FName Optional_Override_Hit_Bone_Name, const struct FVector& hit_location, const struct FVector& hit_impulse_direction, const class FName& hit_bone_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_OnHitCallback");

	Params::DragonIKPhysicsComponent_Server_OnHitCallback Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Optional_Override_Hit_Bone_Name = Optional_Override_Hit_Bone_Name;
	Parms.hit_location = std::move(hit_location);
	Parms.hit_impulse_direction = std::move(hit_impulse_direction);
	Parms.hit_bone_name = hit_bone_name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_PerformActiveRagdoll
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// float                                   pelvis_mass_override                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_PerformActiveRagdoll(float pelvis_mass_override)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_PerformActiveRagdoll");

	Params::DragonIKPhysicsComponent_Server_PerformActiveRagdoll Parms{};

	Parms.pelvis_mass_override = pelvis_mass_override;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_ReGrabAllHandles
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    exit_ragdoll                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_ReGrabAllHandles(bool exit_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_ReGrabAllHandles");

	Params::DragonIKPhysicsComponent_Server_ReGrabAllHandles Parms{};

	Parms.exit_ragdoll = exit_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_ReleaseAllHandles
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    go_ragdoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_ReleaseAllHandles(bool go_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_ReleaseAllHandles");

	Params::DragonIKPhysicsComponent_Server_ReleaseAllHandles Parms{};

	Parms.go_ragdoll = go_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_SetInterpolation
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// int32                                   inter_value                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_SetInterpolation(int32 inter_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_SetInterpolation");

	Params::DragonIKPhysicsComponent_Server_SetInterpolation Parms{};

	Parms.inter_value = inter_value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_UpdatePhysanimData
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// int32                                   LinearStrength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LinearDamp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularDamp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_UpdatePhysanimData(int32 LinearStrength, int32 AngularStrength, int32 LinearDamp, int32 AngularDamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_UpdatePhysanimData");

	Params::DragonIKPhysicsComponent_Server_UpdatePhysanimData Parms{};

	Parms.LinearStrength = LinearStrength;
	Parms.AngularStrength = AngularStrength;
	Parms.LinearDamp = LinearDamp;
	Parms.AngularDamp = AngularDamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.SetInterpolation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   inter_value                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::SetInterpolation(int32 inter_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "SetInterpolation");

	Params::DragonIKPhysicsComponent_SetInterpolation Parms{};

	Parms.inter_value = inter_value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.UpdatePhysanimData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LinearStrength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LinearDamp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularDamp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::UpdatePhysanimData(int32 LinearStrength, int32 AngularStrength, int32 LinearDamp, int32 AngularDamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "UpdatePhysanimData");

	Params::DragonIKPhysicsComponent_UpdatePhysanimData Parms{};

	Parms.LinearStrength = LinearStrength;
	Parms.AngularStrength = AngularStrength;
	Parms.LinearDamp = LinearDamp;
	Parms.AngularDamp = AngularDamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKTraceManagerComponent.SpineSolverTraceData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FDragonIKTraceKeyValuePair>&hit_data_pair                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDragonIKTraceManagerComponent::SpineSolverTraceData(const TArray<struct FDragonIKTraceKeyValuePair>& hit_data_pair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKTraceManagerComponent", "SpineSolverTraceData");

	Params::DragonIKTraceManagerComponent_SpineSolverTraceData Parms{};

	Parms.hit_data_pair = std::move(hit_data_pair);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Attach_Hand_Only
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    arm_position_recalibrate                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Attach_Hand_Only(class FName hand_bone, bool arm_position_recalibrate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Attach_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Attach_Hand_Only Parms{};

	Parms.hand_bone = hand_bone;
	Parms.arm_position_recalibrate = arm_position_recalibrate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Destroy_Weapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Destroy_Weapon(class AActor* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Destroy_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Destroy_Weapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.DisableWeaponsArms
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    reset_weapon_transform                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::DisableWeaponsArms(bool reset_weapon_transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "DisableWeaponsArms");

	Params::DragonIKWeaponPhysicsComponent_DisableWeaponsArms Parms{};

	Parms.reset_weapon_transform = reset_weapon_transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.EnableWeaponsArms
// (Final, Native, Public, BlueprintCallable)

void UDragonIKWeaponPhysicsComponent::EnableWeaponsArms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "EnableWeaponsArms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.FirstTimeInitialization
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::FirstTimeInitialization(class USkeletalMeshComponent* skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "FirstTimeInitialization");

	Params::DragonIKWeaponPhysicsComponent_FirstTimeInitialization Parms{};

	Parms.skeleton_input = skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Freeze_Elbows_Function
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Freeze_Elbows_Function(class FName hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Freeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function Parms{};

	Parms.hand_bone = hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Grab_Weapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             grabbed_bone                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    simulate_physics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Grab_Weapon(class FName grabbed_bone, bool simulate_physics, bool use_gravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Grab_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Grab_Weapon Parms{};

	Parms.grabbed_bone = grabbed_bone;
	Parms.simulate_physics = simulate_physics;
	Parms.use_gravity = use_gravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Attach_Hand_Only
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    arm_position_recalibrate                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Attach_Hand_Only(class FName hand_bone, bool arm_position_recalibrate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Attach_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Attach_Hand_Only Parms{};

	Parms.hand_bone = hand_bone;
	Parms.arm_position_recalibrate = arm_position_recalibrate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Destroy_Weapon
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Destroy_Weapon(class AActor* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Destroy_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Destroy_Weapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_DisableWeaponsArms
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// bool                                    reset_weapon_transform                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_DisableWeaponsArms(bool reset_weapon_transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_DisableWeaponsArms");

	Params::DragonIKWeaponPhysicsComponent_Multicast_DisableWeaponsArms Parms{};

	Parms.reset_weapon_transform = reset_weapon_transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_EnableWeaponsArms
// (Net, Native, Event, NetMulticast, Public, NetValidate)

void UDragonIKWeaponPhysicsComponent::Multicast_EnableWeaponsArms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_EnableWeaponsArms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_FirstTimeInitialization
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_FirstTimeInitialization(class USkeletalMeshComponent* skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_FirstTimeInitialization");

	Params::DragonIKWeaponPhysicsComponent_Multicast_FirstTimeInitialization Parms{};

	Parms.skeleton_input = skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Freeze_Elbows_Function
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Freeze_Elbows_Function(class FName hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Freeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Freeze_Elbows_Function Parms{};

	Parms.hand_bone = hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Grab_Weapon
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class FName                             grabbed_bone                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    simulate_physics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Grab_Weapon(class FName grabbed_bone, bool simulate_physics, bool use_gravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Grab_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon Parms{};

	Parms.grabbed_bone = grabbed_bone;
	Parms.simulate_physics = simulate_physics;
	Parms.use_gravity = use_gravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Release_Hand_Only
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Release_Hand_Only(class FName hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Release_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Only Parms{};

	Parms.hand_bone = hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Release_Hand_Plus_Override
// (Net, Native, Event, NetMulticast, Public, HasDefaults, NetValidate)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                hand_transform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    override_hand_location                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Override_Hand_Rotation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Release_Hand_Plus_Override(class FName hand_bone, const struct FTransform& hand_transform, bool override_hand_location, bool Override_Hand_Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Release_Hand_Plus_Override");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override Parms{};

	Parms.hand_bone = hand_bone;
	Parms.hand_transform = std::move(hand_transform);
	Parms.override_hand_location = override_hand_location;
	Parms.Override_Hand_Rotation = Override_Hand_Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Release_Weapon
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// bool                                    should_simulatephysics                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeep_Attachment                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Release_Weapon(bool should_simulatephysics, bool use_gravity, bool bKeep_Attachment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Release_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon Parms{};

	Parms.should_simulatephysics = should_simulatephysics;
	Parms.use_gravity = use_gravity;
	Parms.bKeep_Attachment = bKeep_Attachment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Unfreeze_Elbows_Function
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Unfreeze_Elbows_Function(class FName hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Unfreeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Unfreeze_Elbows_Function Parms{};

	Parms.hand_bone = hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Weapon_Transform_Override
// (Net, Native, Event, NetMulticast, Public, HasDefaults, NetValidate)
// Parameters:
// const struct FTransform&                Weapon_Transform                                       (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShould_Override_Weapon_Transform                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Weapon_Transform_Override(const struct FTransform& Weapon_Transform, bool bShould_Override_Weapon_Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Weapon_Transform_Override");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Weapon_Transform_Override Parms{};

	Parms.Weapon_Transform = std::move(Weapon_Transform);
	Parms.bShould_Override_Weapon_Transform = bShould_Override_Weapon_Transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Hand_Only
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Release_Hand_Only(class FName hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Release_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Release_Hand_Only Parms{};

	Parms.hand_bone = hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Hand_Plus_Override
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                hand_transform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    override_hand_location                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Override_Hand_Rotation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Release_Hand_Plus_Override(class FName hand_bone, const struct FTransform& hand_transform, bool override_hand_location, bool Override_Hand_Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Release_Hand_Plus_Override");

	Params::DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override Parms{};

	Parms.hand_bone = hand_bone;
	Parms.hand_transform = std::move(hand_transform);
	Parms.override_hand_location = override_hand_location;
	Parms.Override_Hand_Rotation = Override_Hand_Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Weapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    should_simulatephysics                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeep_Attachment                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Release_Weapon(bool should_simulatephysics, bool use_gravity, bool bKeep_Attachment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Release_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Release_Weapon Parms{};

	Parms.should_simulatephysics = should_simulatephysics;
	Parms.use_gravity = use_gravity;
	Parms.bKeep_Attachment = bKeep_Attachment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Attach_Hand_Only
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    arm_position_recalibrate                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Attach_Hand_Only(class FName hand_bone, bool arm_position_recalibrate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Attach_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Server_Attach_Hand_Only Parms{};

	Parms.hand_bone = hand_bone;
	Parms.arm_position_recalibrate = arm_position_recalibrate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Destroy_Weapon
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Destroy_Weapon(class AActor* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Destroy_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Server_Destroy_Weapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_DisableWeaponsArms
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    reset_weapon_transform                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_DisableWeaponsArms(bool reset_weapon_transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_DisableWeaponsArms");

	Params::DragonIKWeaponPhysicsComponent_Server_DisableWeaponsArms Parms{};

	Parms.reset_weapon_transform = reset_weapon_transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_EnableWeaponsArms
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void UDragonIKWeaponPhysicsComponent::Server_EnableWeaponsArms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_EnableWeaponsArms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_FirstTimeInitialization
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_FirstTimeInitialization(class USkeletalMeshComponent* skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_FirstTimeInitialization");

	Params::DragonIKWeaponPhysicsComponent_Server_FirstTimeInitialization Parms{};

	Parms.skeleton_input = skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Freeze_Elbows_Function
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Freeze_Elbows_Function(class FName hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Freeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Server_Freeze_Elbows_Function Parms{};

	Parms.hand_bone = hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Grab_Weapon
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             grabbed_bone                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    simulate_physics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Grab_Weapon(class FName grabbed_bone, bool simulate_physics, bool use_gravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Grab_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Server_Grab_Weapon Parms{};

	Parms.grabbed_bone = grabbed_bone;
	Parms.simulate_physics = simulate_physics;
	Parms.use_gravity = use_gravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Release_Hand_Only
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Release_Hand_Only(class FName hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Release_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Server_Release_Hand_Only Parms{};

	Parms.hand_bone = hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Release_Hand_Plus_Override
// (Net, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                hand_transform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    override_hand_location                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Override_Hand_Rotation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Release_Hand_Plus_Override(class FName hand_bone, const struct FTransform& hand_transform, bool override_hand_location, bool Override_Hand_Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Release_Hand_Plus_Override");

	Params::DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override Parms{};

	Parms.hand_bone = hand_bone;
	Parms.hand_transform = std::move(hand_transform);
	Parms.override_hand_location = override_hand_location;
	Parms.Override_Hand_Rotation = Override_Hand_Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Release_Weapon
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    should_simulatephysics                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeep_Attachment                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Release_Weapon(bool should_simulatephysics, bool use_gravity, bool bKeep_Attachment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Release_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Server_Release_Weapon Parms{};

	Parms.should_simulatephysics = should_simulatephysics;
	Parms.use_gravity = use_gravity;
	Parms.bKeep_Attachment = bKeep_Attachment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Unfreeze_Elbows_Function
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Unfreeze_Elbows_Function(class FName hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Unfreeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Server_Unfreeze_Elbows_Function Parms{};

	Parms.hand_bone = hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Weapon_Transform_Override
// (Net, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// const struct FTransform&                Weapon_Transform                                       (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShould_Override_Weapon_Transform                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Weapon_Transform_Override(const struct FTransform& Weapon_Transform, bool bShould_Override_Weapon_Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Weapon_Transform_Override");

	Params::DragonIKWeaponPhysicsComponent_Server_Weapon_Transform_Override Parms{};

	Parms.Weapon_Transform = std::move(Weapon_Transform);
	Parms.bShould_Override_Weapon_Transform = bShould_Override_Weapon_Transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Unfreeze_Elbows_Function
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Unfreeze_Elbows_Function(class FName hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Unfreeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function Parms{};

	Parms.hand_bone = hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Weapon_Transform_Override
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                Weapon_Transform                                       (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShould_Override_Weapon_Transform                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Weapon_Transform_Override(const struct FTransform& Weapon_Transform, bool bShould_Override_Weapon_Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Weapon_Transform_Override");

	Params::DragonIKWeaponPhysicsComponent_Weapon_Transform_Override Parms{};

	Parms.Weapon_Transform = std::move(Weapon_Transform);
	Parms.bShould_Override_Weapon_Transform = bShould_Override_Weapon_Transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIK_Library.CustomLookRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   lookAt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   upDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDragonIK_Library::CustomLookRotation(const struct FVector& lookAt, const struct FVector& upDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DragonIK_Library", "CustomLookRotation");

	Params::DragonIK_Library_CustomLookRotation Parms{};

	Parms.lookAt = std::move(lookAt);
	Parms.upDirection = std::move(upDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DragonIKPlugin.DragonIK_Library.LookAtRotation_V3
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   UpVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDragonIK_Library::LookAtRotation_V3(const struct FVector& Source, const struct FVector& Target, const struct FVector& UpVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DragonIK_Library", "LookAtRotation_V3");

	Params::DragonIK_Library_LookAtRotation_V3 Parms{};

	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);
	Parms.UpVector = std::move(UpVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DragonIKPlugin.DragonIK_Library.LookAtVector_V2
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Source_Location                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   lookAt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   upDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDragonIK_Library::LookAtVector_V2(const struct FVector& Source_Location, const struct FVector& lookAt, const struct FVector& upDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DragonIK_Library", "LookAtVector_V2");

	Params::DragonIK_Library_LookAtVector_V2 Parms{};

	Parms.Source_Location = std::move(Source_Location);
	Parms.lookAt = std::move(lookAt);
	Parms.upDirection = std::move(upDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DragonIKPlugin.DragonIK_Library.QuatLookXatLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTransform&                LookAtFromTransform                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LookAtTarget                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UDragonIK_Library::QuatLookXatLocation(const struct FTransform& LookAtFromTransform, const struct FVector& LookAtTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DragonIK_Library", "QuatLookXatLocation");

	Params::DragonIK_Library_QuatLookXatLocation Parms{};

	Parms.LookAtFromTransform = std::move(LookAtFromTransform);
	Parms.LookAtTarget = std::move(LookAtTarget);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

