#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameUtilsPlugin

#include "Basic.hpp"


namespace SDK
{

// Enum GameUtilsPlugin.EInteractDisplayType
// NumValues: 0x0004
enum class EInteractDisplayType : uint8
{
	Invalid                                  = 0,
	Discovered                               = 1,
	Prompt                                   = 2,
	EInteractDisplayType_MAX                 = 3,
};

// Enum GameUtilsPlugin.EConeAABBIntersectionResult
// NumValues: 0x0005
enum class EConeAABBIntersectionResult : uint8
{
	Intersection                             = 0,
	OutOfArc                                 = 1,
	OutOfRange                               = 2,
	InvalidTest                              = 3,
	EConeAABBIntersectionResult_MAX          = 4,
};

// Enum GameUtilsPlugin.EVertexRenderType
// NumValues: 0x0005
enum class EVertexRenderType : uint8
{
	None                                     = 0,
	Vertices                                 = 1,
	Faces                                    = 2,
	cCount                                   = 3,
	EVertexRenderType_MAX                    = 4,
};

// ScriptStruct GameUtilsPlugin.NamedTextArg
// 0x0020 (0x0020 - 0x0000)
struct FNamedTextArg final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedTextArg) == 0x000008, "Wrong alignment on FNamedTextArg");
static_assert(sizeof(FNamedTextArg) == 0x000020, "Wrong size on FNamedTextArg");
static_assert(offsetof(FNamedTextArg, Key) == 0x000000, "Member 'FNamedTextArg::Key' has a wrong offset!");
static_assert(offsetof(FNamedTextArg, Value) == 0x000010, "Member 'FNamedTextArg::Value' has a wrong offset!");

// ScriptStruct GameUtilsPlugin.TextLookupArg
// 0x0020 (0x0020 - 0x0000)
struct FTextLookupArg final
{
public:
	class FString                                 TableId;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextLookupArg) == 0x000008, "Wrong alignment on FTextLookupArg");
static_assert(sizeof(FTextLookupArg) == 0x000020, "Wrong size on FTextLookupArg");
static_assert(offsetof(FTextLookupArg, TableId) == 0x000000, "Member 'FTextLookupArg::TableId' has a wrong offset!");
static_assert(offsetof(FTextLookupArg, Key) == 0x000010, "Member 'FTextLookupArg::Key' has a wrong offset!");

// ScriptStruct GameUtilsPlugin.NamedTextLookupArg
// 0x0030 (0x0030 - 0x0000)
struct FNamedTextLookupArg final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTextLookupArg                         Value;                                             // 0x0010(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedTextLookupArg) == 0x000008, "Wrong alignment on FNamedTextLookupArg");
static_assert(sizeof(FNamedTextLookupArg) == 0x000030, "Wrong size on FNamedTextLookupArg");
static_assert(offsetof(FNamedTextLookupArg, Key) == 0x000000, "Member 'FNamedTextLookupArg::Key' has a wrong offset!");
static_assert(offsetof(FNamedTextLookupArg, Value) == 0x000010, "Member 'FNamedTextLookupArg::Value' has a wrong offset!");

// ScriptStruct GameUtilsPlugin.LocalizedMessage
// 0x0040 (0x0040 - 0x0000)
struct FLocalizedMessage final
{
public:
	class FString                                 StringTableId;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNamedTextArg>                  FormatArgs;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FNamedTextLookupArg>            LookupArgs;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocalizedMessage) == 0x000008, "Wrong alignment on FLocalizedMessage");
static_assert(sizeof(FLocalizedMessage) == 0x000040, "Wrong size on FLocalizedMessage");
static_assert(offsetof(FLocalizedMessage, StringTableId) == 0x000000, "Member 'FLocalizedMessage::StringTableId' has a wrong offset!");
static_assert(offsetof(FLocalizedMessage, Key) == 0x000010, "Member 'FLocalizedMessage::Key' has a wrong offset!");
static_assert(offsetof(FLocalizedMessage, FormatArgs) == 0x000020, "Member 'FLocalizedMessage::FormatArgs' has a wrong offset!");
static_assert(offsetof(FLocalizedMessage, LookupArgs) == 0x000030, "Member 'FLocalizedMessage::LookupArgs' has a wrong offset!");

// ScriptStruct GameUtilsPlugin.CyclicalTime
// 0x0004 (0x0004 - 0x0000)
struct FCyclicalTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCyclicalTime) == 0x000004, "Wrong alignment on FCyclicalTime");
static_assert(sizeof(FCyclicalTime) == 0x000004, "Wrong size on FCyclicalTime");
static_assert(offsetof(FCyclicalTime, Time) == 0x000000, "Member 'FCyclicalTime::Time' has a wrong offset!");

// ScriptStruct GameUtilsPlugin.CyclicalTimeWithWorldContext
// 0x0008 (0x0008 - 0x0000)
struct FCyclicalTimeWithWorldContext final
{
public:
	struct FCyclicalTime                          CyclicalTime;                                      // 0x0000(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         NoRep_WorldContextTime;                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCyclicalTimeWithWorldContext) == 0x000004, "Wrong alignment on FCyclicalTimeWithWorldContext");
static_assert(sizeof(FCyclicalTimeWithWorldContext) == 0x000008, "Wrong size on FCyclicalTimeWithWorldContext");
static_assert(offsetof(FCyclicalTimeWithWorldContext, CyclicalTime) == 0x000000, "Member 'FCyclicalTimeWithWorldContext::CyclicalTime' has a wrong offset!");
static_assert(offsetof(FCyclicalTimeWithWorldContext, NoRep_WorldContextTime) == 0x000004, "Member 'FCyclicalTimeWithWorldContext::NoRep_WorldContextTime' has a wrong offset!");

// ScriptStruct GameUtilsPlugin.AoCTargetInfo
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FAoCTargetInfo final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAoCTargetInfo) == 0x000008, "Wrong alignment on FAoCTargetInfo");
static_assert(sizeof(FAoCTargetInfo) == 0x000050, "Wrong size on FAoCTargetInfo");

// ScriptStruct GameUtilsPlugin.IntrepidBitArray
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FIntrepidBitArray final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIntrepidBitArray) == 0x000008, "Wrong alignment on FIntrepidBitArray");
static_assert(sizeof(FIntrepidBitArray) == 0x000010, "Wrong size on FIntrepidBitArray");

// ScriptStruct GameUtilsPlugin.OctreeNode
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x10) FOctreeNode final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOctreeNode) == 0x000010, "Wrong alignment on FOctreeNode");
static_assert(sizeof(FOctreeNode) == 0x0000A0, "Wrong size on FOctreeNode");

// ScriptStruct GameUtilsPlugin.OctreeTreeNode
// 0x00B8 (0x00B8 - 0x0000)
struct alignas(0x08) FOctreeTreeNode final
{
public:
	uint8                                         Pad_0[0xB8];                                       // 0x0000(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOctreeTreeNode) == 0x000008, "Wrong alignment on FOctreeTreeNode");
static_assert(sizeof(FOctreeTreeNode) == 0x0000B8, "Wrong size on FOctreeTreeNode");

// ScriptStruct GameUtilsPlugin.Octree
// 0x01B0 (0x01B0 - 0x0000)
struct FOctree final
{
public:
	struct FOctreeTreeNode                        Root;                                              // 0x0000(0x00B8)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MinimumSplitSize;                                  // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LargestSize;                                       // 0x00BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0xC0];                                      // 0x00C0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOctreeNodeObj*>                 OctreeNodes;                                       // 0x0180(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UOctreeTreeNodeObj*>             OctreeTreeNodes;                                   // 0x0190(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UOctreeNodeObj>>  FollowMovementActors;                              // 0x01A0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
};
static_assert(alignof(FOctree) == 0x000008, "Wrong alignment on FOctree");
static_assert(sizeof(FOctree) == 0x0001B0, "Wrong size on FOctree");
static_assert(offsetof(FOctree, Root) == 0x000000, "Member 'FOctree::Root' has a wrong offset!");
static_assert(offsetof(FOctree, MinimumSplitSize) == 0x0000B8, "Member 'FOctree::MinimumSplitSize' has a wrong offset!");
static_assert(offsetof(FOctree, LargestSize) == 0x0000BC, "Member 'FOctree::LargestSize' has a wrong offset!");
static_assert(offsetof(FOctree, OctreeNodes) == 0x000180, "Member 'FOctree::OctreeNodes' has a wrong offset!");
static_assert(offsetof(FOctree, OctreeTreeNodes) == 0x000190, "Member 'FOctree::OctreeTreeNodes' has a wrong offset!");
static_assert(offsetof(FOctree, FollowMovementActors) == 0x0001A0, "Member 'FOctree::FollowMovementActors' has a wrong offset!");

}

